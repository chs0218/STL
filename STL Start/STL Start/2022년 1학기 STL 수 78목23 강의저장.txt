파일이름: 소스.cpp
파일크기: 1660
저장시간: 2022-03-02 17:09:31 GMT+9
파일이름: 소스.cpp
파일크기: 1729
저장시간: 2022-03-02 17:11:55 GMT+9
파일이름: 소스.cpp
파일크기: 1952
저장시간: 2022-03-02 17:15:16 GMT+9
//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 2일 수요일(1주 1일)
// 
// - 강의소개, 출석점수없음
// - 교과서, cppreference.com
// - google coding convention을 참고
// - 프로젝트 환경설정 Release/x64
//		메뉴 - 프로젝트 - 설정 - C++언어: 최신언어초안
// - 공부란 무엇인가?
// 할 일 - 한학기 코딩한 내용을 저장할 수 있게 save 기능 완성
//-----------------------------------------------------------------------------
#include <iostream>
#include <string_view>
#include <filesystem>
#include <chrono>	// 시간 관련 함수
#include <fstream>
#include <vector>
#include <algorithm>

//using namespace std;
//void save(const string&);
void save(std::string_view);

int main()
{
	// string과 string_view 크기 확인
	
	std::cout << "string 크기:"<< sizeof(std::string) << std::endl;
	std::cout << "string_view 크기:"<< sizeof(std::string_view) << std::endl;
	save("소스.cpp");
}

void save(std::string_view fname)
{
	// 읽을 파일을 연다
	std::ifstream in{ fname.data() };


	// 쓸 파일도 연다
	std::ofstream out{ "2022년 1학기 STL 수 78목23 강의저장.txt", std::ios::app };


	// 저장할 파일이름과 크기(C++17)를 출력한다.
	out << "파일이름: " << fname << std::endl;
	out << "파일크기: " << std::filesystem::file_size(fname) << std::endl;
	

	// 현재 날짜와 시간(C++20)을 출력한다.
	auto time = floor<std::chrono::seconds>(std::chrono::system_clock::now());
	out << "저장시간: " << std::chrono::zoned_time("Asia/Seoul", time) << std::endl;
	

	// 읽은 파일을 강의저장 파일에 덧붙인다.
	// 1. 벡터에 파일을 읽어온다.
	// std::vector<char> v{ std::istream_iterator<char>{in}, {} };
	std::vector<char> v{ std::istreambuf_iterator<char>{in}, {} };		// 띄어쓰기도 포함해서 저장
	
	/*for (char c : v)
		out << c;*/

	// 2. copy 알고리즘으로 벡터에 있는 글자를 강의저장파일로 복사한다
	std::copy(v.begin(), v.end(), std::ostream_iterator<char>{out});

}

파일이름: 소스.cpp
파일크기: 2053


저장시간: 2022-03-02 17:16:11 GMT+9


//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 2일 수요일(1주 1일)
// 
// - 강의소개, 출석점수없음
// - 교과서, cppreference.com
// - google coding convention을 참고
// - 프로젝트 환경설정 Release/x64
//		메뉴 - 프로젝트 - 설정 - C++언어: 최신언어초안
// - 공부란 무엇인가?
// 할 일 - 한학기 코딩한 내용을 저장할 수 있게 save 기능 완성
//-----------------------------------------------------------------------------
#include <iostream>
#include <string_view>
#include <filesystem>
#include <chrono>	// 시간 관련 함수
#include <fstream>
#include <vector>
#include <algorithm>

//using namespace std;
//void save(const string&);
void save(std::string_view);

int main()
{
	// string과 string_view 크기 확인
	
	std::cout << "string 크기:"<< sizeof(std::string) << std::endl;
	std::cout << "string_view 크기:"<< sizeof(std::string_view) << std::endl;
	save("소스.cpp");
}

void save(std::string_view fname)
{
	// 읽을 파일을 연다
	std::ifstream in{ fname.data() };


	// 쓸 파일도 연다
	std::ofstream out{ "2022년 1학기 STL 수 78목23 강의저장.txt", std::ios::app };


	// 저장할 파일이름과 크기(C++17)를 출력한다.
	out << std::endl << std::endl;
	out << "파일이름: " << fname << std::endl;
	out << "파일크기: " << std::filesystem::file_size(fname) << std::endl;
	

	// 현재 날짜와 시간(C++20)을 출력한다.
	out << std::endl << std::endl;
	auto time = floor<std::chrono::seconds>(std::chrono::system_clock::now());
	out << "저장시간: " << std::chrono::zoned_time("Asia/Seoul", time) << std::endl;
	

	// 읽은 파일을 강의저장 파일에 덧붙인다.
	// 1. 벡터에 파일을 읽어온다.
	out << std::endl << std::endl;

	// std::vector<char> v{ std::istream_iterator<char>{in}, {} };
	std::vector<char> v{ std::istreambuf_iterator<char>{in}, {} };		// 띄어쓰기도 포함해서 저장
	
	/*for (char c : v)
		out << c;*/

	// 2. copy 알고리즘으로 벡터에 있는 글자를 강의저장파일로 복사한다
	std::copy(v.begin(), v.end(), std::ostream_iterator<char>{out});

}

파일이름: 소스.cpp
파일크기: 2245


저장시간: 2022-03-03 10:38:15 GMT+9


//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 2일 수요일(1주 1일)
// 
// - 강의소개, 출석점수없음
// - 교과서, cppreference.com
// - google coding convention을 참고
// - 프로젝트 환경설정 Release/x64
//		메뉴 - 프로젝트 - 설정 - C++언어: 최신언어초안
// - 공부란 무엇인가?
// 할 일 - 한학기 코딩한 내용을 저장할 수 있게 save 기능 완성
// 
// 읽은 파일의 정보를 읽어 쓸 파일에 덧붙여 쓴다
// Youtube - Back to Basics Classic STL 강의를 볼 수 있다면 도움이 될 것임
//-----------------------------------------------------------------------------
#include <iostream>
#include <string_view>
#include <filesystem>
#include <chrono>	// 시간 관련 함수
#include <fstream>
#include <vector>
#include <algorithm>

//using namespace std;
//void save(const string&);
void save(std::string_view);

int main()
{
	// string과 string_view 크기 확인
	
	std::cout << "string 크기:"<< sizeof(std::string) << std::endl;
	std::cout << "string_view 크기:"<< sizeof(std::string_view) << std::endl;
	save("소스.cpp");
}

void save(std::string_view fname)
{
	// 읽을 파일을 연다 - RALL
	std::ifstream in{ fname.data() };


	// 쓸 파일도 연다
	std::ofstream out{ "2022년 1학기 STL 수 78목23 강의저장.txt", std::ios::app };


	// 저장할 파일이름과 크기(C++17)를 출력한다.
	out << std::endl << std::endl;
	out << "파일이름: " << fname << std::endl;
	out << "파일크기: " << std::filesystem::file_size(fname) << std::endl;
	

	// 현재 날짜와 시간(C++20)을 출력한다.
	out << std::endl << std::endl;
	auto time = floor<std::chrono::seconds>(std::chrono::system_clock::now());
	out << "저장시간: " << std::chrono::zoned_time("Asia/Seoul", time) << std::endl;
	

	// 읽은 파일을 강의저장 파일에 덧붙인다.
	// 1. 벡터에 파일을 읽어온다.
	out << std::endl << std::endl;

	// std::vector<char> v{ std::istream_iterator<char>{in}, {} };

	// 1. 벡터에 파일을 읽어온다 - 컨테이너(자료구조)
	std::vector<char> v{ std::istreambuf_iterator<char>{in}, {} };		// 띄어쓰기도 포함해서 저장
	
	/*for (char c : v)
		out << c;*/

	// 2. copy 알고리즘으로 벡터에 있는 글자를 강의저장파일로 복사한다
	std::copy(v.begin(), v.end(), std::ostream_iterator<char>{out});

}

파일이름: 소스.cpp
파일크기: 692


저장시간: 2022-03-03 10:41:59 GMT+9


//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일(1주 2일)
// 
// 할 일 - 어제 코딩한 save 함수를 save.cpp로 분리한 후 실행되도록 수정
// 
// Youtube - Back to Basics Classic STL 강의를 볼 수 있다면 도움이 될 것임
//-----------------------------------------------------------------------------
#include <iostream>


//using namespace std;
//void save(const string&);
void save(std::string_view);

int main()
{
	// string과 string_view 크기 확인
	
	std::cout << "string 크기:"<< sizeof(std::string) << std::endl;
	std::cout << "string_view 크기:"<< sizeof(std::string_view) << std::endl;
	save("소스.cpp");
}

파일이름: 소스.cpp
파일크기: 650


저장시간: 2022-03-03 10:46:55 GMT+9


//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일(1주 2일)
// 
// 할 일 - 어제 코딩한 save 함수를 save.cpp로 분리한 후 실행되도록 수정
// 
// Youtube - Back to Basics Classic STL 강의를 볼 수 있다면 도움이 될 것임
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"

//using namespace std;

int main()
{
	// string과 string_view 크기 확인
	
	std::cout << "string 크기:"<< sizeof(std::string) << std::endl;
	std::cout << "string_view 크기:"<< sizeof(std::string_view) << std::endl;
	save("소스.cpp");
}

파일이름: save.h
파일크기: 97


저장시간: 2022-03-03 11:03:24 GMT+9


#pragma once
#include <string_view>

//void save(const string&);
void save(std::string_view);

파일이름: save.cpp
파일크기: 1646


저장시간: 2022-03-03 11:03:24 GMT+9


//-----------------------------------------------------------------------------
// Save.cpp
// 
// 이 함수를 호출하면 "2022년 1학기 STL 수78목23 강의저장.txt"에
// 전달된 이름의 파일을 읽어 덧붙인다.
// 
// 2022.3.3	Programmed by HS
//-----------------------------------------------------------------------------

#include <filesystem>
#include <fstream>
#include <vector>
#include <chrono>	// 시간 관련 함수
#include <algorithm>
#include <cmath>	// floor
#include "save.h"

void save(std::string_view fname)
{
	// 읽을 파일을 연다 - RALL
	std::ifstream in{ fname.data() };


	// 쓸 파일도 연다
	std::ofstream out{ "2022년 1학기 STL 수 78목23 강의저장.txt", std::ios::app };


	// 저장할 파일이름과 크기(C++17)를 출력한다.
	out << std::endl << std::endl;
	out << "파일이름: " << fname << std::endl;
	out << "파일크기: " << std::filesystem::file_size(fname) << std::endl;


	// 현재 날짜와 시간(C++20)을 출력한다.
	out << std::endl << std::endl;
	auto time = floor<std::chrono::seconds>(std::chrono::system_clock::now());
	out << "저장시간: " << std::chrono::zoned_time("Asia/Seoul", time) << std::endl;


	// 읽은 파일을 강의저장 파일에 덧붙인다.
	// 1. 벡터에 파일을 읽어온다.
	out << std::endl << std::endl;

	// std::vector<char> v{ std::istream_iterator<char>{in}, {} };

	// 1. 벡터에 파일을 읽어온다 - 컨테이너(자료구조)
	std::vector<char> v{ std::istreambuf_iterator<char>{in}, {} };		// 띄어쓰기도 포함해서 저장

	/*for (char c : v)
		out << c;*/

	// 2. copy 알고리즘으로 벡터에 있는 글자를 강의저장파일로 복사한다
	std::copy(v.begin(), v.end(), std::ostream_iterator<char>{out});

}

파일이름: 소스.cpp
파일크기: 507


저장시간: 2022-03-03 11:03:24 GMT+9


//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일(1주 2일)
// 
// 할 일 - 어제 코딩한 save 함수를 save.cpp로 분리한 후 실행되도록 수정
// 
// Youtube - Back to Basics Classic STL 강의를 볼 수 있다면 도움이 될 것임
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"

//using namespace std;

int main()
{
	save("save.h");
	save("save.cpp");
	save("소스.cpp");
}

파일이름: save.h
파일크기: 97
저장시간: 2022-03-03 11:05:46 GMT+9

#pragma once
#include <string_view>

//void save(const string&);
void save(std::string_view);

파일이름: save.cpp
파일크기: 1600
저장시간: 2022-03-03 11:05:46 GMT+9

//-----------------------------------------------------------------------------
// Save.cpp
// 
// 이 함수를 호출하면 "2022년 1학기 STL 수78목23 강의저장.txt"에
// 전달된 이름의 파일을 읽어 덧붙인다.
// 
// 2022.3.3	Programmed by HS
//-----------------------------------------------------------------------------

#include <filesystem>
#include <fstream>
#include <vector>
#include <chrono>	// 시간 관련 함수
#include <algorithm>
#include <cmath>	// floor
#include "save.h"

void save(std::string_view fname)
{
	// 읽을 파일을 연다 - RALL
	std::ifstream in{ fname.data() };


	// 쓸 파일도 연다
	std::ofstream out{ "2022년 1학기 STL 수 78목23 강의저장.txt", std::ios::app };


	// 저장할 파일이름과 크기(C++17)를 출력한다.
	out << std::endl << std::endl;
	out << "파일이름: " << fname << std::endl;
	out << "파일크기: " << std::filesystem::file_size(fname) << std::endl;


	// 현재 날짜와 시간(C++20)을 출력한다.
	auto time = floor<std::chrono::seconds>(std::chrono::system_clock::now());
	out << "저장시간: " << std::chrono::zoned_time("Asia/Seoul", time) << std::endl;


	// 읽은 파일을 강의저장 파일에 덧붙인다.
	// 1. 벡터에 파일을 읽어온다.
	out << std::endl;

	// std::vector<char> v{ std::istream_iterator<char>{in}, {} };

	// 1. 벡터에 파일을 읽어온다 - 컨테이너(자료구조)
	std::vector<char> v{ std::istreambuf_iterator<char>{in}, {} };		// 띄어쓰기도 포함해서 저장

	/*for (char c : v)
		out << c;*/

	// 2. copy 알고리즘으로 벡터에 있는 글자를 강의저장파일로 복사한다
	std::copy(v.begin(), v.end(), std::ostream_iterator<char>{out});

}

파일이름: 소스.cpp
파일크기: 507
저장시간: 2022-03-03 11:05:46 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일(1주 2일)
// 
// 할 일 - 어제 코딩한 save 함수를 save.cpp로 분리한 후 실행되도록 수정
// 
// Youtube - Back to Basics Classic STL 강의를 볼 수 있다면 도움이 될 것임
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"

//using namespace std;

int main()
{
	save("save.h");
	save("save.cpp");
	save("소스.cpp");
}

파일이름: 소스.cpp
파일크기: 756
저장시간: 2022-03-03 11:16:28 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일(1주 2일)
// 
// 할 일 - 어제 코딩한 save 함수를 save.cpp로 분리한 후 실행되도록 수정
// 
// Youtube - Back to Basics Classic STL 강의를 볼 수 있다면 도움이 될 것임
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"

//using namespace std;

// [문제] main()을 변경하면 안된다.
// 실행하면 a와 b의 값ㅇ이 서로 바뀌어야한다.

void change(int&, int&);

int main()
{
	int a{ 1 };
	int b{ 2 };

	change(a, b);

	std::cout << a << ", " << b << std::endl;
	save("소스.cpp");
}

void change(int& a, int& b)
{
	int tmp;
	tmp = a;
	a = b;
	b = tmp;

}

파일이름: 소스.cpp
파일크기: 778
저장시간: 2022-03-03 11:36:47 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일(1주 2일)
// 
// 할 일 - 어제 코딩한 save 함수를 save.cpp로 분리한 후 실행되도록 수정
// 
// Youtube - Back to Basics Classic STL 강의를 볼 수 있다면 도움이 될 것임
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"

//using namespace std;

// [문제] main()을 변경하면 안된다.
// 실행하면 a와 b의 값ㅇ이 서로 바뀌어야한다.

void change(int&, int&);

int main()
{
	int a{ 1 };
	int b{ 2 };

	change(a, b);

	std::cout << a << ", " << b << std::endl;
	save("소스.cpp");
}

void change(int& a, int& b)
{
	int tmp{};	// default 초기화

	tmp = a;
	a = b;
	b = tmp;

}

파일이름: 소스.cpp
파일크기: 1154
저장시간: 2022-03-03 11:47:05 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일(1주 2일)
// 
// 할 일 - 어제 코딩한 save 함수를 save.cpp로 분리한 후 실행되도록 수정
// 
// Youtube - Back to Basics Classic STL 강의를 볼 수 있다면 도움이 될 것임
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"

//using namespace std;

// [문제] main()을 변경하면 안된다.
// 실행하면 a와 b의 값이 서로 바뀌어야한다.

class Dog {
	int age;
public:
	Dog() {
		age = 0;
	}

	Dog(int i) :age(i) {

	}

	int getAge()
	{
		return age;
	}

	void changeAge(int i)
	{
		age = i;
	}
};

void change(Dog&, Dog&);
std::ostream& operator <<(std::ostream&, Dog&);

int main()
{
	Dog a{ 1 };
	Dog b{ 2 };

	change(a, b);

	std::cout << a << ", " << b << std::endl;
	save("소스.cpp");
}

void change(Dog& a, Dog& b)
{
	Dog tmp{};	// default 초기화

	tmp.changeAge(a.getAge());
	a.changeAge(b.getAge());
	b.changeAge(tmp.getAge());
}

std::ostream& operator <<(std::ostream& c, Dog& dog)
{
	c << dog.getAge();
	return c;
}

파일이름: 소스.cpp
파일크기: 1169
저장시간: 2022-03-03 12:13:23 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일(1주 2일)
// 
// 할 일 - 어제 코딩한 save 함수를 save.cpp로 분리한 후 실행되도록 수정
// 
// Youtube - Back to Basics Classic STL 강의를 볼 수 있다면 도움이 될 것임
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"

//using namespace std;

// [문제] main()을 변경하면 안된다.
// 실행하면 a와 b의 값이 서로 바뀌어야한다.

class Dog {
	int age;
public:
	Dog() = default;

	Dog(int i) :age{ i } {};

	int getAge() const
	{
		return age;
	}

	void changeAge(const int i)
	{
		age = i;
	}
};

void change(Dog&, Dog&);
std::ostream& operator <<(std::ostream&, const Dog&);

int main()
{
	Dog a{ 1 };
	Dog b{ 2 };

	change(a, b);

	std::cout << a << ", " << b << std::endl;
	save("소스.cpp");
}

void change(Dog& a, Dog& b)
{
	Dog tmp{};	// default 초기화

	tmp.changeAge(a.getAge());
	a.changeAge(b.getAge());
	b.changeAge(tmp.getAge());
}

std::ostream& operator <<(std::ostream& c, const Dog& dog)
{
	c << dog.getAge();
	return c;
}

파일이름: 소스.cpp
파일크기: 813
저장시간: 2022-03-10 10:58:24 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일(2주 1일)
// 
// 할 일 -
// 템플릿
// 많은 데이터를 다루는 연습 - 파일
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"

//using namespace std;

using namespace std::string_literals;

template<typename T>
void change(T& a, T& b) {
	T tmp{};
	tmp = a;
	a = b;
	b = tmp;
}

// [문제] change를 한번만 선언하고 정의하여
// main()이 수정없이 실행되도록 하라(5분)
//----
int main()
//----
{
	{
		int a{ 1 }, b{ 2 };
		change(a, b);
		std::cout << a << "," << b << std::endl;
	}
	{
		std::string a{ "1"s}, b{"2"s};
		change(a, b);
		std::cout << a << "," << b << std::endl;
	}
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 952
저장시간: 2022-03-10 10:59:34 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일(2주 1일)
// 
// 할 일 -
// 템플릿
// 많은 데이터를 다루는 연습 - 파일
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"

//using namespace std;

using namespace std::string_literals;

template<typename T>
void change(T& a, T& b) {
	T tmp{};
	tmp = a;
	a = b;
	b = tmp;
}

template<>
void change(int& a, int& b)
{
	std::cout << "int 인자의 경우 불리는 함수\n";
	int tmp;
	tmp = a;
	a = b;
	b = tmp;
}

// [문제] change를 한번만 선언하고 정의하여
// main()이 수정없이 실행되도록 하라(5분)
//----
int main()
//----
{
	{
		int a{ 1 }, b{ 2 };
		change(a, b);
		std::cout << a << "," << b << std::endl;
	}
	{
		std::string a{ "1"s}, b{"2"s};
		change(a, b);
		std::cout << a << "," << b << std::endl;
	}
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 949
저장시간: 2022-03-10 11:00:23 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일(2주 1일)
// 
// 할 일 -
// 템플릿
// 많은 데이터를 다루는 연습 - 파일
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"

//using namespace std;

using namespace std::string_literals;

template<class T>
void change(T& a, T& b) {
	T tmp{};
	tmp = a;
	a = b;
	b = tmp;
}

template<>
void change(int& a, int& b)
{
	std::cout << "int 인자의 경우 불리는 함수\n";
	int tmp;
	tmp = a;
	a = b;
	b = tmp;
}

// [문제] change를 한번만 선언하고 정의하여
// main()이 수정없이 실행되도록 하라(5분)
//----
int main()
//----
{
	{
		int a{ 1 }, b{ 2 };
		change(a, b);
		std::cout << a << "," << b << std::endl;
	}
	{
		std::string a{ "1"s}, b{"2"s};
		change(a, b);
		std::cout << a << "," << b << std::endl;
	}
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 977
저장시간: 2022-03-10 11:11:18 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일(2주 1일)
// 
// 할 일 -
// 템플릿 - 자료형에 관계없는 함수와 클래스를 만드는 핵심 Keyword
//		 - 이런 방식의 코딩을 generic programming이라고 함
// 많은 데이터를 다루는 연습 - 파일
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"

//using namespace std;

using namespace std::string_literals;

template<class T>
void change(T& a, T& b) {
	T tmp{};
	tmp = a;
	a = b;
	b = tmp;
}

template<>
void change(int& a, int& b)
{
	std::cout << "int 인자의 경우 불리는 함수\n";
	int tmp;
	tmp = a;
	a = b;
	b = tmp;
}



//----
int main()
//----
{
	{
		int a{ 1 }, b{ 2 };
		change(a, b);
		std::cout << a << "," << b << std::endl;
	}
	{
		std::string a{ "1"s}, b{"2"s};
		change(a, b);
		std::cout << a << "," << b << std::endl;
	}
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 505
저장시간: 2022-03-10 11:11:42 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일(2주 1일)
// 
// 할 일 -
// 템플릿 - 자료형에 관계없는 함수와 클래스를 만드는 핵심 Keyword
//		 - 이런 방식의 코딩을 generic programming이라고 함
// 많은 데이터를 다루는 연습 - 파일
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"

//using namespace std;

//----
int main()
//----
{
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 669
저장시간: 2022-03-10 11:17:07 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일(2주 1일)
// 
// 할 일 -
// 템플릿 - 자료형에 관계없는 함수와 클래스를 만드는 핵심 Keyword
//		 - 이런 방식의 코딩을 generic programming이라고 함
// 많은 데이터를 다루는 연습 - 파일
//-----------------------------------------------------------------------------
#include <iostream>
#include <random>
#include "save.h"

//using namespace std;

// [문제] 임의의 값을 갖는(random value) int 1000개를 화면에 출력하라.

//----
int main()
//----
{	
	for (int i = 0; i < 1000; ++i)
		std::cout << rand() << std::endl;
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 914
저장시간: 2022-03-10 11:45:02 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일(2주 1일)
// 
// 할 일 -
// 템플릿 - 자료형에 관계없는 함수와 클래스를 만드는 핵심 Keyword
//		 - 이런 방식의 코딩을 generic programming이라고 함
// 많은 데이터를 다루는 연습 - 파일
//		- 랜덤 데이터를 생성하는 방법(엔진/분포) - 시험에서는 노말한 분포를 자주 냄
//-----------------------------------------------------------------------------
#include <iostream>
#include <random>
#include "save.h"

//using namespace std;

// [문제] 엔진과 분포를 사용하여 임의의 값을 갖는(random value) 
// int 1000개를 화면에 출력하라.

std::random_device rd;
std::default_random_engine dre{ rd() };

//----
int main()
//----
{	
	std::uniform_int_distribution uid;
	for (int i = 0; i < 1'000; ++i)
	{
		std::cout << uid(dre) << '\t';
	}
	std::cout << std::endl;
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 906
저장시간: 2022-03-10 11:47:29 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일(2주 1일)
// 
// 할 일 -
// 템플릿 - 자료형에 관계없는 함수와 클래스를 만드는 핵심 Keyword
//		 - 이런 방식의 코딩을 generic programming이라고 함
// 많은 데이터를 다루는 연습 - 파일
//		- 랜덤 데이터를 생성하는 방법(엔진/분포) - 시험에서는 노말한 분포를 자주 냄
//-----------------------------------------------------------------------------
#include <iostream>
#include <random>
#include "save.h"

//using namespace std;

// [문제] int의 최대값을 출력하라

std::random_device rd;
std::default_random_engine dre{ rd() };

//----
int main()
//----
{	
	std::uniform_int_distribution uid;
	for (int i = 0; i < 1'000; ++i)
	{
		std::cout << uid(dre) << '\t';
	}
	std::cout << std::endl;
	std::cout << "UINT 최대값: " << UINT_MAX << std::endl;
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 928
저장시간: 2022-03-10 11:48:47 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일(2주 1일)
// 
// 할 일 -
// 템플릿 - 자료형에 관계없는 함수와 클래스를 만드는 핵심 Keyword
//		 - 이런 방식의 코딩을 generic programming이라고 함
// 많은 데이터를 다루는 연습 - 파일
//		- 랜덤 데이터를 생성하는 방법(엔진/분포) - 시험에서는 노말한 분포를 자주 냄
//-----------------------------------------------------------------------------
#include <iostream>
#include <random>
#include "save.h"

//using namespace std;

// [문제] int의 최대값을 출력하라

std::random_device rd;
std::default_random_engine dre{ rd() };

//----
int main()
//----
{	
	std::uniform_int_distribution uid;
	for (int i = 0; i < 1'000; ++i)
	{
		std::cout << uid(dre) << '\t';
	}
	std::cout << std::endl;
	std::cout << "INT 최대값: " << std::numeric_limits<int>::max() << std::endl;
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 937
저장시간: 2022-03-10 11:48:58 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일(2주 1일)
// 
// 할 일 -
// 템플릿 - 자료형에 관계없는 함수와 클래스를 만드는 핵심 Keyword
//		 - 이런 방식의 코딩을 generic programming이라고 함
// 많은 데이터를 다루는 연습 - 파일
//		- 랜덤 데이터를 생성하는 방법(엔진/분포) - 시험에서는 노말한 분포를 자주 냄
//-----------------------------------------------------------------------------
#include <iostream>
#include <random>
#include "save.h"

//using namespace std;

// [문제] int의 최대값을 출력하라

std::random_device rd;
std::default_random_engine dre{ rd() };

//----
int main()
//----
{	
	std::uniform_int_distribution uid;
	for (int i = 0; i < 1'000; ++i)
	{
		std::cout << uid(dre) << '\t';
	}
	std::cout << std::endl;
	std::cout << "INT 최대값: " << std::numeric_limits<unsigned int>::max() << std::endl;
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 951
저장시간: 2022-03-10 11:50:50 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일(2주 1일)
// 
// 할 일 -
// 템플릿 - 자료형에 관계없는 함수와 클래스를 만드는 핵심 Keyword
//		 - 이런 방식의 코딩을 generic programming이라고 함
// 많은 데이터를 다루는 연습 - 파일
//		- 랜덤 데이터를 생성하는 방법(엔진/분포) - 시험에서는 노말한 분포를 자주 냄
//-----------------------------------------------------------------------------
#include <iostream>
#include <random>
#include "save.h"

//using namespace std;

// [문제] int의 최대값을 출력하라

std::random_device rd;
std::default_random_engine dre{ rd() };

//----
int main()
//----
{	
	std::uniform_int_distribution uid;
	for (int i = 0; i < 1'000; ++i)
	{
		std::cout << uid(dre) << '\t';
	}
	std::cout << std::endl;
	int num = 0B01111111'11111111'11111111'11111111;
	std::cout << "INT 최대값: " << num << std::endl;
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 924
저장시간: 2022-03-10 11:51:49 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일(2주 1일)
// 
// 할 일 -
// 템플릿 - 자료형에 관계없는 함수와 클래스를 만드는 핵심 Keyword
//		 - 이런 방식의 코딩을 generic programming이라고 함
// 많은 데이터를 다루는 연습 - 파일
//		- 랜덤 데이터를 생성하는 방법(엔진/분포) - 시험에서는 노말한 분포를 자주 냄
//-----------------------------------------------------------------------------
#include <iostream>
#include <random>
#include "save.h"

//using namespace std;

// [문제] int의 최대값을 출력하라

std::random_device rd;
std::default_random_engine dre{ rd() };

//----
int main()
//----
{	
	std::uniform_int_distribution uid;
	for (int i = 0; i < 1'000; ++i)
	{
		std::cout << uid(dre) << '\t';
	}
	std::cout << std::endl;
	int num = 0x7FFFFFFF;
	std::cout << "INT 최대값: " << num << std::endl;
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 924
저장시간: 2022-03-10 11:52:25 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일(2주 1일)
// 
// 할 일 -
// 템플릿 - 자료형에 관계없는 함수와 클래스를 만드는 핵심 Keyword
//		 - 이런 방식의 코딩을 generic programming이라고 함
// 많은 데이터를 다루는 연습 - 파일
//		- 랜덤 데이터를 생성하는 방법(엔진/분포) - 시험에서는 노말한 분포를 자주 냄
//-----------------------------------------------------------------------------
#include <iostream>
#include <random>
#include "save.h"

//using namespace std;

// [문제] int의 최대값을 출력하라

std::random_device rd;
std::default_random_engine dre{ rd() };

//----
int main()
//----
{	
	std::uniform_int_distribution uid;
	for (int i = 0; i < 1'000; ++i)
	{
		std::cout << uid(dre) << '\t';
	}
	std::cout << std::endl;
	int num = 0xFFFFFFFF;
	std::cout << "INT 최대값: " << num << std::endl;
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 945
저장시간: 2022-03-10 12:08:16 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일(2주 1일)
// 
// 할 일 -
// 템플릿 - 자료형에 관계없는 함수와 클래스를 만드는 핵심 Keyword
//		 - 이런 방식의 코딩을 generic programming이라고 함
// 많은 데이터를 다루는 연습 - 파일
//		- 랜덤 데이터를 생성하는 방법(엔진/분포) - 시험에서는 노말한 분포를 자주 냄
//-----------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <random>
#include "save.h"

//using namespace std;

// [문제] 랜덤 int 1000개를 "int 1000개.txt"에 저장하라

std::random_device rd;
std::default_random_engine dre{ rd() };

//----
int main()
//----
{	
	std::uniform_int_distribution uid;
	std::ofstream out{ "int 1000개.txt" };	// 이미 있으면 파괴하고 생성

	for (int i = 0; i < 1'000; ++i)
		out << uid(dre) << '\t';
	out << std::endl;

	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 915
저장시간: 2022-03-16 15:40:02 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일(2주 2일)
// 
// 할 일 -
// 다음시간 질문 - int 1000개를 저장하려면 몇 바이트가 필요하니?
//-----------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include "save.h"

//using namespace std;

// [문제] "int 1000개.txt"에 저장된 int 1000개를 화면 출력하라.
// 가장 큰 값을 찾아 화면에 출력하라

//----
int main()
//----
{
	std::ifstream in{ "int 1000개.txt" };
	if (!in)
	{
		std::cout << "파일을 열 수 없다" << std::endl;
		return 0;
	}

	int maxValue = std::numeric_limits<unsigned int>::min();
	int* tmp = new int[1000];
	for (int i = 0; i < 1000; ++i)
	{
		in >> tmp[i];
		if (tmp[i] > maxValue)
			maxValue = tmp[i];
	}

	std::cout << "가장 큰 값: " << maxValue;
	delete[] tmp;
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 794
저장시간: 2022-03-16 15:52:31 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일(2주 2일)
// 
// 할 일 -
// 다음시간 질문 - int 1000개를 저장하려면 몇 바이트가 필요하니?
//-----------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <algorithm>
#include "save.h"

//using namespace std;

// [문제] "int 1000개.txt"에 저장된 int 1000개를 화면 출력하라.
// 가장 큰 값을 찾아 화면에 출력하라

//----
int main()
//----
{
	std::ifstream in{ "int 1000개.txt" };
	if (!in)
	{
		std::cout << "파일을 열 수 없다" << std::endl;
		return 0;
	}

	auto p = std::max_element(std::istream_iterator<int>{in}, {});
	std::cout << "최대값: " << *p << std::endl;
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 802
저장시간: 2022-03-16 16:09:12 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일(2주 2일)
// 
// 할 일 -
//-----------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include "save.h"

//using namespace std;

// [문제] int 1000개를 저장하려면 메모리 몇 바이트가 필요합니까?
//		-> 상황에 따라 다름
//		-> 그렇지만 int 메모리 자체 비트를 그래도 기록하고 일거 온다면
//		-> 어떤 상황에서도 4000바이트면 문제가 없다

// [문제] int 1000개를 "int 1000개.txt" 파일에 메모리 그대로 기록하라.
//----
int main()
//----
{
	std::ofstream out{ "int 1000개.txt" };
	int num;
	for (int i = 0; i < 1000; ++i)
	{
		num = i + 1;
		out.write((const char*)&num, sizeof(num));
	}
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 820
저장시간: 2022-03-16 16:18:12 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일(2주 2일)
// 
// 할 일 -
//-----------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include "save.h"

//using namespace std;

// [문제] int 1000개를 저장하려면 메모리 몇 바이트가 필요합니까?
//		-> 상황에 따라 다름
//		-> 그렇지만 int 메모리 자체 비트를 그래도 기록하고 일거 온다면
//		-> 어떤 상황에서도 4000바이트면 문제가 없다

// [문제] int 1000개를 "int 1000개.txt" 파일에 메모리 그대로 기록하라.
//----
int main()
//----
{
	std::ofstream out{ "int 1000개.txt", std::ios::binary };
	int num;
	for (int i = 0; i < 1000; ++i)
	{
		num = i + 1;
		out.write((const char*)&num, sizeof(num));
	}
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 915
저장시간: 2022-03-16 16:33:47 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일(2주 2일)
// 
// 할 일 -
//-----------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <fstream>
#include "save.h"

//using namespace std;

// [문제] int 1000개를 저장하려면 메모리 몇 바이트가 필요합니까?
//		-> 상황에 따라 다름
//		-> 그렇지만 int 메모리 자체 비트를 그래도 기록하고 일거 온다면
//		-> 어떤 상황에서도 4000바이트면 문제가 없다

// [문제] int 1000개를 "int 1000개.txt" 파일에 메모리 그대로 기록하라.
//----

std::default_random_engine dre;
std::uniform_int_distribution uid;

int main()
//----
{
	std::ofstream out{ "int 1000개.txt", std::ios::binary };
	int num;
	for (int i = 0; i < 1000; ++i)
	{
		num = uid(dre);
		out.write((const char*)&num, sizeof(num));
	}
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 819
저장시간: 2022-03-16 16:40:45 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일(2주 2일)
// 
// 할 일 -
//-----------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include "save.h"

//using namespace std;

// [문제] 랜덤 값을 갖는 int 1000를
// "int 1000개.txt" 파일에 binary 모드와 write 함수를 사용하여 기록하였다.
// 읽어서 가장 큰 값을 찾아 화면에 출력하라
//----

int main()
//----
{
	std::ifstream in{ "int 1000개.txt", std::ios::binary };
	int maxValue = std::numeric_limits<int>::min();
	int num;
	for (int i = 0; i < 1000; ++i)
	{
		in.read((char*)&num, sizeof(num));
		if (maxValue < num)
			maxValue = num;
	}
	std::cout << "최대 값: " << maxValue << std::endl;
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 775
저장시간: 2022-03-16 16:59:19 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(2주 2일)
// 
// 책/구글 꼭 찾아보기
//-----------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <fstream>
#include "save.h"

//using namespace std;

// [문제] 랜덤 값을 갖는 int 1000를
// "int 1000개.txt" 파일에 binary 모드와 write 함수를 사용하여 기록하였다.
// 읽어서 가장 큰 값을 찾아 화면에 출력하라
//----

int main()
//----
{
	std::ifstream in{ "int 1000개.txt", std::ios::binary };
	int num[1000];
	in.read((char*)&num, 1000 * sizeof(int));
	
	std::cout << "최댓값: " << *std::max_element(std::begin(num), std::end(num)) << std::endl;
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 937
저장시간: 2022-03-16 17:05:53 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(2주 2일)
// 
// 책/구글 꼭 찾아보기
//-----------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <fstream>
#include <format>	// c++20 최신이어야 돌아감
#include "save.h"

//using namespace std;

// [문제] 랜덤 값을 갖는 int 1000를
// "int 1000개.txt" 파일에 binary 모드와 write 함수를 사용하여 기록하였다.
// 읽어서 가장 큰 값을 찾아 화면에 출력하라
//----

int main()
//----
{
	std::ifstream in{ "int 1000개.txt", std::ios::binary };
	int num[1000];
	in.read((char*)&num, 1000 * sizeof(int));
	
	// 읽은 값 출력 연습
	for (int num : num)
		std::cout << std::format("{:80}", num);
	std::cout << std::endl;

	std::cout << "최댓값: " << *std::max_element(std::begin(num), std::end(num)) << std::endl;
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 938
저장시간: 2022-03-16 17:05:59 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(2주 2일)
// 
// 책/구글 꼭 찾아보기
//-----------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <fstream>
#include <format>	// c++20 최신이어야 돌아감
#include "save.h"

//using namespace std;

// [문제] 랜덤 값을 갖는 int 1000를
// "int 1000개.txt" 파일에 binary 모드와 write 함수를 사용하여 기록하였다.
// 읽어서 가장 큰 값을 찾아 화면에 출력하라
//----

int main()
//----
{
	std::ifstream in{ "int 1000개.txt", std::ios::binary };
	int num[1000];
	in.read((char*)&num, 1000 * sizeof(int));
	
	// 읽은 값 출력 연습
	for (int num : num)
		std::cout << std::format("{:^80}", num);
	std::cout << std::endl;

	std::cout << "최댓값: " << *std::max_element(std::begin(num), std::end(num)) << std::endl;
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 938
저장시간: 2022-03-16 17:06:17 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(2주 2일)
// 
// 책/구글 꼭 찾아보기
//-----------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <fstream>
#include <format>	// c++20 최신이어야 돌아감
#include "save.h"

//using namespace std;

// [문제] 랜덤 값을 갖는 int 1000를
// "int 1000개.txt" 파일에 binary 모드와 write 함수를 사용하여 기록하였다.
// 읽어서 가장 큰 값을 찾아 화면에 출력하라
//----

int main()
//----
{
	std::ifstream in{ "int 1000개.txt", std::ios::binary };
	int num[1000];
	in.read((char*)&num, 1000 * sizeof(int));
	
	// 읽은 값 출력 연습
	for (int num : num)
		std::cout << std::format("{:<80}", num);
	std::cout << std::endl;

	std::cout << "최댓값: " << *std::max_element(std::begin(num), std::end(num)) << std::endl;
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 937
저장시간: 2022-03-16 17:06:37 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(2주 2일)
// 
// 책/구글 꼭 찾아보기
//-----------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <fstream>
#include <format>	// c++20 최신이어야 돌아감
#include "save.h"

//using namespace std;

// [문제] 랜덤 값을 갖는 int 1000를
// "int 1000개.txt" 파일에 binary 모드와 write 함수를 사용하여 기록하였다.
// 읽어서 가장 큰 값을 찾아 화면에 출력하라
//----

int main()
//----
{
	std::ifstream in{ "int 1000개.txt", std::ios::binary };
	int num[1000];
	in.read((char*)&num, 1000 * sizeof(int));
	
	// 읽은 값 출력 연습
	for (int num : num)
		std::cout << std::format("{:20}", num);
	std::cout << std::endl;

	std::cout << "최댓값: " << *std::max_element(std::begin(num), std::end(num)) << std::endl;
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 815
저장시간: 2022-03-16 17:11:44 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(2주 2일)
// 
// 책/구글 꼭 찾아보기
//-----------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <array>
#include <fstream>
#include "save.h"

//using namespace std;

// [문제] 랜덤 값을 갖는 int 1000를
// "int 1000개.txt" 파일에 binary 모드와 write 함수를 사용하여 기록하였다.
// 읽어서 가장 큰 값을 찾아 화면에 출력하라
//----

int main()
//----
{
	std::ifstream in{ "int 1000개.txt", std::ios::binary };
	std::array<int, 1000> num;
	
	in.read((char*)num.data(), 1'000 * sizeof(int));
	
	std::cout << "최댓값: " << *std::max_element(std::begin(num), std::end(num)) << std::endl;
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 410
저장시간: 2022-03-17 11:34:51 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(3주 1일)
// 
//-----------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <memory>
#include "save.h"

//using namespace std;

//----
int main()
//----
{
	std::unique_ptr<int> p{ new int };
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 561
저장시간: 2022-03-17 11:38:19 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(3주 1일)
// 
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"

//using namespace std;

//----
int main()
//----
{
	int num;
	std::cout << "int 몇개를 원하십니까? ";
	std::cin >> num;

	std::unique_ptr<int[]> p{ new int[num] };
	long long sum{};
	for (int i = 0; i < num; ++i)
		sum += p[i];

	std::cout<< "결과: "<<sum<<std::endl;
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 610
저장시간: 2022-03-17 11:39:28 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(3주 1일)
// 
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"

//using namespace std;

//----
int main()
//----
{
	int num;
	std::cout << "int 몇개를 원하십니까? ";
	std::cin >> num;

	std::unique_ptr<int[]> p{ new int[num] };
	for (int i = 0; i < num; ++i)
		p[i] = i + 1;
	long long sum{};
	for (int i = 0; i < num; ++i)
		sum += p[i];

	std::cout<< "결과: "<<sum<<std::endl;
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 788
저장시간: 2022-03-17 11:46:59 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(3주 1일)
// 
// 지난 시간 배운 것 - 앞으로 int[100] 대신에 -> array<int, 100> 사용하자
// 오늘 알아본 것 - 앞으로 int* 대신에 -> unique_ptr<int> 사용하자
//						int*가 new int[100] 대신에 -> unique_ptr<int[]> 사용하자
//-----------------------------------------------------------------------------
#include <iostream>
#include <memory>
#include "save.h"

//using namespace std;

// 메모리 관찰용 초미니 Dog를 만든다

struct Dog {
	Dog() { std::cout << "Dog 생성자 호출" << std::endl; }
	~Dog() { std::cout << "Dog 소멸자 호출" << std::endl; }
};

//----
int main()
//----
{
	for (int i = 0; i < 3; ++i){
		new Dog;
	}

	save("소스.cpp");

}


파일이름: 소스.cpp
파일크기: 810
저장시간: 2022-03-17 11:47:42 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(3주 1일)
// 
// 지난 시간 배운 것 - 앞으로 int[100] 대신에 -> array<int, 100> 사용하자
// 오늘 알아본 것 - 앞으로 int* 대신에 -> unique_ptr<int> 사용하자
//						int*가 new int[100] 대신에 -> unique_ptr<int[]> 사용하자
//-----------------------------------------------------------------------------
#include <iostream>
#include <memory>
#include "save.h"

//using namespace std;

// 메모리 관찰용 초미니 Dog를 만든다

struct Dog {
	Dog() { std::cout << "Dog 생성자 호출" << std::endl; }
	~Dog() { std::cout << "Dog 소멸자 호출" << std::endl; }
};

//----
int main()
//----
{
	for (int i = 0; i < 3; ++i){
		Dog* p = new Dog;
		delete p;
	}

	save("소스.cpp");

}


파일이름: 소스.cpp
파일크기: 776
저장시간: 2022-03-17 11:48:55 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(3주 1일)
// 
// 지난 시간 배운 것 - 앞으로 int[100] 대신에 -> array<int, 100> 사용하자
// 오늘 알아본 것 - 앞으로 int* 대신에 -> unique_ptr<int> 사용하자
//						int*가 new int[100] 대신에 -> unique_ptr<int[]> 사용하자
//-----------------------------------------------------------------------------
#include <iostream>
#include <memory>
#include "save.h"

//using namespace std;

// 메모리 관찰용 초미니 Dog를 만든다

struct Dog {
	Dog() { std::cout << "Dog 생성자 호출" << std::endl; }
	~Dog() { std::cout << "Dog 소멸자 호출" << std::endl; }
};

//----
int main()
//----
{
	Dog* p = new Dog[3];
	delete[] p;
	save("소스.cpp");

}


파일이름: 소스.cpp
파일크기: 859
저장시간: 2022-03-17 11:52:13 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(3주 1일)
// 
// 지난 시간 배운 것 - 앞으로 int[100] 대신에 -> array<int, 100> 사용하자
// 오늘 알아본 것 - 앞으로 int* 대신에 -> unique_ptr<int> 사용하자
//						int*가 new int[100] 대신에 -> unique_ptr<int[]> 사용하자
//-----------------------------------------------------------------------------
#include <iostream>
#include <memory>
#include "save.h"

//using namespace std;

// 메모리 관찰용 초미니 Dog를 만든다

struct Dog {
	Dog() { std::cout << "Dog 생성자 호출" << std::endl; }
	~Dog() { std::cout << "Dog 소멸자 호출" << std::endl; }
};

void f() 
{
	throw 1;
}

//----
int main()
//----
{
	save("소스.cpp");


	Dog* p = new Dog[3];
	// 여기서 비정상 종료
	f();	// 예외를 던진다.

	delete[] p;
}


파일이름: 소스.cpp
파일크기: 965
저장시간: 2022-03-17 11:54:01 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(3주 1일)
// 
// 지난 시간 배운 것 - 앞으로 int[100] 대신에 -> array<int, 100> 사용하자
// 오늘 알아본 것 - 앞으로 int* 대신에 -> unique_ptr<int> 사용하자
//						int*가 new int[100] 대신에 -> unique_ptr<int[]> 사용하자
//-----------------------------------------------------------------------------
#include <iostream>
#include <memory>
#include "save.h"

//using namespace std;

// 메모리 관찰용 초미니 Dog를 만든다

struct Dog {
	Dog() { std::cout << "Dog 생성자 호출" << std::endl; }
	~Dog() { std::cout << "Dog 소멸자 호출" << std::endl; }
};

void f() 
{
	throw 1;
}

//----
int main()
//----
{
	save("소스.cpp");


	Dog* p = new Dog[3];
	// 여기서 비정상 종료
	try {
		f();	// 예외를 던진다.
	}
	catch (...) {	// ... elipses
		std::cout << "예외를 잡았다." << std::endl;
		return 0;
	}
	delete[] p;
}


파일이름: 소스.cpp
파일크기: 980
저장시간: 2022-03-17 11:55:15 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(3주 1일)
// 
// 지난 시간 배운 것 - 앞으로 int[100] 대신에 -> array<int, 100> 사용하자
// 오늘 알아본 것 - 앞으로 int* 대신에 -> unique_ptr<int> 사용하자
//						int*가 new int[100] 대신에 -> unique_ptr<int[]> 사용하자
//-----------------------------------------------------------------------------
#include <iostream>
#include <memory>
#include "save.h"

//using namespace std;

// 메모리 관찰용 초미니 Dog를 만든다

struct Dog {
	Dog() { std::cout << "Dog 생성자 호출" << std::endl; }
	~Dog() { std::cout << "Dog 소멸자 호출" << std::endl; }
};

void f() 
{
	throw 1;
}

//----
int main()
//----
{
	save("소스.cpp");


	Dog* p = new Dog[3];
	// 여기서 비정상 종료
	try {
		f();	// 예외를 던진다.
	}
	catch (...) {	// ... elipses
		std::cout << "예외를 잡았다." << std::endl;
		delete[] p;
		return 0;
	}
	delete[] p;
}


파일이름: 소스.cpp
파일크기: 970
저장시간: 2022-03-17 11:56:42 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(3주 1일)
// 
// 지난 시간 배운 것 - 앞으로 int[100] 대신에 -> array<int, 100> 사용하자
// 오늘 알아본 것 - 앞으로 int* 대신에 -> unique_ptr<int> 사용하자
//						int*가 new int[100] 대신에 -> unique_ptr<int[]> 사용하자
//-----------------------------------------------------------------------------
#include <iostream>
#include <memory>
#include "save.h"

//using namespace std;

// 메모리 관찰용 초미니 Dog를 만든다

struct Dog {
	Dog() { std::cout << "Dog 생성자 호출" << std::endl; }
	~Dog() { std::cout << "Dog 소멸자 호출" << std::endl; }
};

void f() 
{
	throw 1;
}

//----
int main()
//----
{
	save("소스.cpp");


	std::unique_ptr<Dog[]> p{ new Dog[3] };
	// 여기서 비정상 종료
	try {
		f();	// 예외를 던진다.
	}
	catch (...) {	// ... elipses
		std::cout << "예외를 잡았다." << std::endl;
		return 0;
	}
}


파일이름: 소스.cpp
파일크기: 961
저장시간: 2022-03-17 11:57:56 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(3주 1일)
// 
// 지난 시간 배운 것 - 앞으로 int[100] 대신에 -> array<int, 100> 사용하자
// 오늘 알아본 것 - 앞으로 int* 대신에 -> unique_ptr<int> 사용하자
//						int*가 new int[100] 대신에 -> unique_ptr<int[]> 사용하자
//-----------------------------------------------------------------------------
#include <iostream>
#include <memory>
#include "save.h"

//using namespace std;

// 메모리 관찰용 초미니 Dog를 만든다

struct Dog {
	Dog() { std::cout << "Dog 생성자 호출" << std::endl; }
	~Dog() { std::cout << "Dog 소멸자 호출" << std::endl; }
};

void f() 
{

}

//----
int main()
//----
{
	save("소스.cpp");


	std::unique_ptr<Dog[]> p{ new Dog[3] };
	// 여기서 비정상 종료
	try {
		f();	// 예외를 던진다.
	}
	catch (...) {	// ... elipses
		std::cout << "예외를 잡았다." << std::endl;
		return 0;
	}
}


파일이름: 소스.cpp
파일크기: 985
저장시간: 2022-03-23 15:36:47 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(3주 2일)
// 
// int[100] 대신에 -> array<int, 100> 사용하자
// int* 대신에 -> unique_ptr<int> 사용하자
// int*가 new int[100] 대신에 -> unique_ptr<int[]> 사용하자
// 
// 호출가능(Callable) 타입 - 예제는 sort를 사용
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
// STRING
//-----------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <fstream>
#include "save.h"

//using namespace std;
//[문제] 이 "소스.cpp"파일의 
// 소문자를 전부 대문자로 바꿔
//"소스 대문자.cpp"로 저장하라
 
//----
int main()
//----
{
	save("소스.cpp");
	std::ifstream in("소스.cpp");
	std::ofstream out("소스 대문자.cpp");

	std::vector<char> v{ std::istreambuf_iterator<char>{in}, {} };
	for (auto c: v) {
		out << (char)(c >= 'a' && c <= 'z' ? toupper(c) : c);
	}
}


파일이름: 소스.cpp
파일크기: 844
저장시간: 2022-03-23 15:44:46 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(3주 2일)
// 
// int[100] 대신에 -> array<int, 100> 사용하자
// int* 대신에 -> unique_ptr<int> 사용하자
// int*가 new int[100] 대신에 -> unique_ptr<int[]> 사용하자
// 
// 호출가능(Callable) 타입 - 예제는 sort를 사용
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
// STRING
//-----------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include "save.h"

//using namespace std;
//[문제] 이 "소스.cpp"파일의 
// 소문자를 전부 대문자로 바꿔
//"소스 대문자.cpp"로 저장하라
 
//----
int main()
//----
{
	save("소스.cpp");
	std::ifstream in{ "소스.cpp" };
	
	char ch;
	
	while (in >> ch) {
		std::cout << ch;
	}

}


파일이름: 소스.cpp
파일크기: 959
저장시간: 2022-03-23 15:48:38 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(3주 2일)
// 
// int[100] 대신에 -> array<int, 100> 사용하자
// int* 대신에 -> unique_ptr<int> 사용하자
// int*가 new int[100] 대신에 -> unique_ptr<int[]> 사용하자
// 
// 호출가능(Callable) 타입 - 예제는 sort를 사용
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
// STRING
//-----------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <vector>
#include "save.h"

//using namespace std;
//[문제] 이 "소스.cpp"파일의 
// 소문자를 전부 대문자로 바꿔
//"소스 대문자.cpp"로 저장하라
 
//----
int main()
//----
{
	save("소스.cpp");
	std::ifstream in("소스.cpp");
	std::ofstream out("소스 대문자.cpp");

	std::vector<char> v{ std::istreambuf_iterator<char>{in}, {} };
	for (char c : v) {
		out << (char)toupper(c);
	}

}


파일이름: 소스.cpp
파일크기: 883
저장시간: 2022-03-23 15:51:45 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(3주 2일)
// 
// int[100] 대신에 -> array<int, 100> 사용하자
// int* 대신에 -> unique_ptr<int> 사용하자
// int*가 new int[100] 대신에 -> unique_ptr<int[]> 사용하자
// 
// 호출가능(Callable) 타입 - 예제는 sort를 사용
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
// STRING
//-----------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <vector>
#include "save.h"

//using namespace std;
//[문제] 이 "소스.cpp"파일의 
// 소문자를 전부 대문자로 바꿔
//"소스 대문자.cpp"로 저장하라
 
//----
int main()
//----
{
	save("소스.cpp");
	std::ifstream in{ "소스.cpp" };
	char ch;
	in >> std::noskipws;
	while (in >> ch) {
		std::cout << ch;
	}
	

}


파일이름: 소스.cpp
파일크기: 925
저장시간: 2022-03-23 15:53:24 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(3주 2일)
// 
// int[100] 대신에 -> array<int, 100> 사용하자
// int* 대신에 -> unique_ptr<int> 사용하자
// int*가 new int[100] 대신에 -> unique_ptr<int[]> 사용하자
// 
// 호출가능(Callable) 타입 - 예제는 sort를 사용
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
// STRING
//-----------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <vector>
#include "save.h"

//using namespace std;
//[문제] 이 "소스.cpp"파일의 
// 소문자를 전부 대문자로 바꿔
//"소스 대문자.cpp"로 저장하라
 
//----
int main()
//----
{
	save("소스.cpp");
	std::ifstream in{ "소스.cpp" };
	char ch;
	in >> std::noskipws;
	while (in >> ch) {
		if (islower(ch))
			ch = toupper(ch);
		std::cout << ch;
	}
	

}


파일이름: 소스.cpp
파일크기: 961
저장시간: 2022-03-23 15:54:29 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(3주 2일)
// 
// int[100] 대신에 -> array<int, 100> 사용하자
// int* 대신에 -> unique_ptr<int> 사용하자
// int*가 new int[100] 대신에 -> unique_ptr<int[]> 사용하자
// 
// 호출가능(Callable) 타입 - 예제는 sort를 사용
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
// STRING
//-----------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <vector>
#include "save.h"

//using namespace std;
//[문제] 이 "소스.cpp"파일의 
// 소문자를 전부 대문자로 바꿔
//"소스 대문자.cpp"로 저장하라
 
//----
int main()
//----
{
	save("소스.cpp");
	std::ifstream in{ "소스.cpp" };
	std::ofstream out{ "소스 대문자.cpp" };
	char ch;
	in >> std::noskipws;
	while (in >> ch) {
		if (islower(ch))
			ch = toupper(ch);
		out << ch;
	}
	

}


파일이름: 소스.cpp
파일크기: 1074
저장시간: 2022-03-23 16:10:42 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(3주 2일)
// 
// int[100] 대신에 -> array<int, 100> 사용하자
// int* 대신에 -> unique_ptr<int> 사용하자
// int*가 new int[100] 대신에 -> unique_ptr<int[]> 사용하자
// 
// 호출가능(Callable) 타입 - 예제는 sort를 사용
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
// STRING
//-----------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <fstream>
#include "save.h"

//using namespace std;
//[문제] 이 "소스.cpp"파일의 
// 숫자를 *로 바꿔 저장하라
//"소스 별.cpp"로 저장하라
 
//----
int main()
//----
{
	save("소스.cpp");
	std::ifstream in{ "소스.cpp" };
	std::ofstream out{ "소스 대문자.cpp" };
	char ch;
	// transform(어디부터, 어디까지를, 저기에 저장, 이렇게 바꿔서)
	std::transform(std::istreambuf_iterator<char>{in}, {}, std::ostream_iterator<char>{std::cout}, [](char c) {
		if (isdigit(c))
			c = '*';
		return c;
	});
}


파일이름: 소스.cpp
파일크기: 1091
저장시간: 2022-03-23 16:34:50 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(3주 2일)
// 
// int[100] 대신에 -> array<int, 100> 사용하자
// int* 대신에 -> unique_ptr<int> 사용하자
// int*가 new int[100] 대신에 -> unique_ptr<int[]> 사용하자
// 
// 호출가능(Callable) 타입 - 예제는 sort를 사용
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
// STRING
//-----------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <array>
#include <random>
#include "save.h"

//using namespace std;
//[문제] 랜덤값을 갖는 int 100개를 생성하라.
// 오름차순으로 정렬하라
// 화면에 정렬된 int 100개를 출력하라.
//
 
std::random_device rd;
std::default_random_engine dre{ rd() };
//----
int main()
//----
{
	save("소스.cpp");

	std::uniform_int_distribution uid;
	std::array<int, 100> arr;
	for (int& n : arr)
	{
		n = uid(dre);
	}

	std::sort(arr.begin(), arr.end());

	for (const int n : arr)
	{
		std::cout << n << std::endl;
	}
}


파일이름: 소스.cpp
파일크기: 1302
저장시간: 2022-03-23 16:41:36 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(3주 2일)
// 
// int[100] 대신에 -> array<int, 100> 사용하자
// int* 대신에 -> unique_ptr<int> 사용하자
// int*가 new int[100] 대신에 -> unique_ptr<int[]> 사용하자
// 
// 호출가능(Callable) 타입 - 예제는 sort를 사용
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
// STRING
//-----------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <format>
#include <array>
#include <random>
#include "save.h"

//using namespace std;
//[문제] 랜덤값을 갖는 int 100개를 생성하라.
// 오름차순으로 정렬하라
// 화면에 정렬된 int 100개를 출력하라.
//
 
std::random_device rd;
std::default_random_engine dre{ rd() };
//----
int main()
//----
{
	save("소스.cpp");

	std::uniform_int_distribution uid;
	std::array<int, 100> arr;
	for (int& n : arr)
		n = uid(dre);

	std::cout << "----정렬하기 전----" << std::endl;

	for (const int n : arr)
		std::cout << std::format("{:20}", n);

	std::sort(arr.begin(), arr.end());
	std::cout << std::endl;
	std::cout << "----정렬한 후-----" << std::endl;
	
	for (const int n : arr)
		std::cout << std::format("{:20}", n);
}


파일이름: 소스.cpp
파일크기: 1319
저장시간: 2022-03-23 16:43:53 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(3주 2일)
// 
// int[100] 대신에 -> array<int, 100> 사용하자
// int* 대신에 -> unique_ptr<int> 사용하자
// int*가 new int[100] 대신에 -> unique_ptr<int[]> 사용하자
// 
// 호출가능(Callable) 타입 - 예제는 sort를 사용
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
// STRING
//-----------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <format>
#include <array>
#include <random>
#include "save.h"

//using namespace std;
//[문제] [1, 100] 랜덤값을 갖는 int 100개를 생성하라.
// 오름차순으로 정렬하라
// 화면에 정렬된 int 100개를 출력하라.
//
 
std::random_device rd;
std::default_random_engine dre{ rd() };
//----
int main()
//----
{
	save("소스.cpp");

	std::uniform_int_distribution uid{ 0, 100 };
	std::array<int, 100> arr;
	for (int& n : arr)
		n = uid(dre);

	std::cout << "----정렬하기 전----" << std::endl;

	for (const int n : arr)
		std::cout << std::format("{:4}", n);

	std::sort(arr.begin(), arr.end());
	std::cout << std::endl;
	std::cout << "----정렬한 후-----" << std::endl;
	
	for (const int n : arr)
		std::cout << std::format("{:4}", n);
}


파일이름: 소스.cpp
파일크기: 1360
저장시간: 2022-03-23 16:57:27 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(3주 2일)
// 
// int[100] 대신에 -> array<int, 100> 사용하자
// int* 대신에 -> unique_ptr<int> 사용하자
// int*가 new int[100] 대신에 -> unique_ptr<int[]> 사용하자
// 
// 호출가능(Callable) 타입 - 예제는 sort를 사용
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
// STRING
//-----------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <format>
#include <array>
#include <random>
#include "save.h"

//using namespace std;
//[문제] [1, 100] 랜덤값을 갖는 int 100개를 생성하라.
// 내림차순으로 정렬하라
// 화면에 정렬된 int 100개를 출력하라.
//
 
std::random_device rd;
std::default_random_engine dre{ rd() };
//----
int main()
//----
{
	save("소스.cpp");

	std::uniform_int_distribution uid{ 0, 100 };
	std::array<int, 100> arr;
	for (int& n : arr)
		n = uid(dre);

	std::cout << "----정렬하기 전----" << std::endl;

	for (const int n : arr)
		std::cout << std::format("{:4}", n);

	std::sort(arr.begin(), arr.end(), [](int p, int q) {
		return p > q;
	});
	std::cout << std::endl;
	std::cout << "----정렬한 후-----" << std::endl;
	
	for (const int n : arr)
		std::cout << std::format("{:4}", n);
}


파일이름: 소스.cpp
파일크기: 794
저장시간: 2022-03-23 17:08:03 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(3주 2일)
// 
// int[100] 대신에 -> array<int, 100> 사용하자
// int* 대신에 -> unique_ptr<int> 사용하자
// int*가 new int[100] 대신에 -> unique_ptr<int[]> 사용하자
// 
// 호출가능(Callable) 타입 - 예제는 sort를 사용
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
// STRING
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"


//using namespace std;
//
//


void f() {
	std::cout << "함수가 호출되었다"<<std::endl;
}

//----
int main()
//----
{
	save("소스.cpp");
	
	(*f)();
	// f의 자료형을 출력하라
	std::cout << typeid(f).name() << std::endl;

}


파일이름: 소스.cpp
파일크기: 920
저장시간: 2022-03-23 17:09:31 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(3주 2일)
// 
// int[100] 대신에 -> array<int, 100> 사용하자
// int* 대신에 -> unique_ptr<int> 사용하자
// int*가 new int[100] 대신에 -> unique_ptr<int[]> 사용하자
// 
// 호출가능(Callable) 타입 - 예제는 sort를 사용
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
// STRING
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"


//using namespace std;
//
//


void f() {
	std::cout << "함수가 호출되었다"<<std::endl;
}

//----
int main()
//----
{
	save("소스.cpp");
	
	(*f)();
	// f의 자료형을 출력하라
	std::cout << typeid(f).name() << std::endl;


	// f의 주소를 출력하라
	std::cout << std::addressof(f) << std::endl;
	std::cout << std::addressof(main) << std::endl;

}


파일이름: 소스.cpp
파일크기: 1226
저장시간: 2022-03-23 17:20:33 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(3주 2일)
// 
// int[100] 대신에 -> array<int, 100> 사용하자
// int* 대신에 -> unique_ptr<int> 사용하자
// int*가 new int[100] 대신에 -> unique_ptr<int[]> 사용하자
// 
// 호출가능(Callable) 타입 - 예제는 sort를 사용
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
// STRING
//-----------------------------------------------------------------------------
#include <iostream>
#include <thread>
#include "save.h"


using namespace std::chrono_literals;
// using namespace std;
//
// 실행시킬때 함수 포인터를 계속 바꿔주면 같은 함수를 호출하면서 다른 기능을 사용할 수 있다.
// 키 입력을 바꾸는 방법이 될 수 있다.
//

void jump() {
	std::cout << "점프" << std::endl;
}

void slide() {
	std::cout << "슬라이드" << std::endl;
}

//----
int main()
//----
{
	save("소스.cpp");
	
	void(*f)(void)= jump;

	// 3초에 한번씩 jump/slide toggle
	int cnt{};
	while (true) {
		f();	// 1초마다 호출
		// 3초가 지나면 바꾼다
		std::this_thread::sleep_for(1s);
		if ((++cnt % 3) == 0) {
			if (f == jump)
				f = slide;
			else
				f = jump;
		}
	}
}


파일이름: 소스.cpp
파일크기: 1303
저장시간: 2022-03-24 10:39:38 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(3주 2일)
// 
// int[100] 대신에 -> array<int, 100> 사용하자
// int* 대신에 -> unique_ptr<int> 사용하자
// int*가 new int[100] 대신에 -> unique_ptr<int[]> 사용하자
// 
// 호출가능(Callable) 타입 - 예제는 sort를 사용
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
// STRING
//-----------------------------------------------------------------------------
#include <iostream>
#include <thread>
#include "save.h"

// using namespace std;
//
// 실행시킬때 함수 포인터를 계속 바꿔주면 같은 함수를 호출하면서 다른 기능을 사용할 수 있다.
// 키 입력을 바꾸는 방법이 될 수 있다.
//

void jump() {
	std::cout << "점프" << std::endl;
}

void slide() {
	std::cout << "슬라이드" << std::endl;
}

//----
int main()
//----
{
	save("소스.cpp");

	// 확인 - 함수의 이름은 함수가 기록되어 있는 CODE 세그먼트의 시작번지이다.
	// 함수들은 유사한 메모리에 기록되어 있음을 알 수 있다.

	std::cout << "main = " << std::addressof(main) << std::endl;
	std::cout << "svae = " << std::addressof(save) << std::endl;
	std::cout << "main = " << std::addressof(jump) << std::endl;
	std::cout << "main = " << std::addressof(slide) << std::endl;

}


파일이름: 소스.cpp
파일크기: 1449
저장시간: 2022-03-24 10:41:07 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(3주 2일)
// 
// int[100] 대신에 -> array<int, 100> 사용하자
// int* 대신에 -> unique_ptr<int> 사용하자
// int*가 new int[100] 대신에 -> unique_ptr<int[]> 사용하자
// 
// 호출가능(Callable) 타입 - 예제는 sort를 사용
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
// STRING
//-----------------------------------------------------------------------------
#include <iostream>
#include <thread>
#include "save.h"

// using namespace std;
//
// 실행시킬때 함수 포인터를 계속 바꿔주면 같은 함수를 호출하면서 다른 기능을 사용할 수 있다.
// 키 입력을 바꾸는 방법이 될 수 있다.
//

void jump() {
	std::cout << "점프" << std::endl;
}

void slide() {
	std::cout << "슬라이드" << std::endl;
}

int g;

//----
int main()
//----
{
	save("소스.cpp");

	// 확인 - 함수의 이름은 함수가 기록되어 있는 CODE 세그먼트의 시작번지이다.
	// 함수들은 유사한 메모리에 기록되어 있음을 알 수 있다.

	std::cout << "main = " << std::addressof(main) << std::endl;
	std::cout << "save = " << std::addressof(save) << std::endl;
	std::cout << "jump = " << std::addressof(jump) << std::endl;
	std::cout << "slide = " << std::addressof(slide) << std::endl;

	int n;
	std::cout << "스택 - " << std::addressof(n) << std::endl;

	std::cout << "데이터 - " << std::addressof(g) << std::endl;

}


파일이름: 소스.cpp
파일크기: 601
저장시간: 2022-03-24 10:51:19 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(4주 1일)
// 
// 호출가능(Callable) 타입 - 예제는 sort를 사용
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"

// using namespace std;


// 호츨가능(Callable) 타입


//----
int main()
//----
{
	std::cout << "메인 호출" << std::endl;
	int(*t)(void) = (int(*)(void))main;
	std::cout << sizeof(t);
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 732
저장시간: 2022-03-24 10:59:03 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(4주 1일)
// 
// 호출가능(Callable) 타입 - 예제는 sort를 사용
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"

// using namespace std;


// 호츨가능(Callable) 타입
// 호출가능한 타입은 어떤 것들이 있나
// 1. 함수 - CODE SEGMENT에 기록된 명령어들의 집합의 시작번지
// 2. 람다 - 이름 없는 함수
//

//----
int main()
//----
{
	// lambda
	[]() {
		std::cout << "안녕? 나는 람다라고 해! 불러줘서 반가워!" << std::endl;
	}();

	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 769
저장시간: 2022-03-24 10:59:55 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(4주 1일)
// 
// 호출가능(Callable) 타입 - 예제는 sort를 사용
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"

// using namespace std;


// 호츨가능(Callable) 타입
// 호출가능한 타입은 어떤 것들이 있나
// 1. 함수 - CODE SEGMENT에 기록된 명령어들의 집합의 시작번지
// 2. 람다 - 이름 없는 함수
//

//----
int main()
//----
{
	// lambda
	std::cout << typeid([]() {
		std::cout << "안녕? 나는 람다라고 해! 불러줘서 반가워!" << std::endl;
	}).name() << std::endl;
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 785
저장시간: 2022-03-24 11:01:41 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(4주 1일)
// 
// 호출가능(Callable) 타입 - 예제는 sort를 사용
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"

// using namespace std;


// 호츨가능(Callable) 타입
// 호출가능한 타입은 어떤 것들이 있나
// 1. 함수 - CODE SEGMENT에 기록된 명령어들의 집합의 시작번지
// 2. 람다 - 이름 없는 함수
//

//----
int main()
//----
{
	// lambda
	auto x = []() {
		std::cout << "안녕? 나는 람다라고 해! 불러줘서 반가워!" << std::endl;
	};

	std::cout << typeid(x).name() << std::endl;
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 855
저장시간: 2022-03-24 11:05:09 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(4주 1일)
// 
// 호출가능(Callable) 타입 - 예제는 sort를 사용
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"

// using namespace std;


// 호츨가능(Callable) 타입
// 호출가능한 타입은 어떤 것들이 있나
// 1. 함수 - CODE SEGMENT에 기록된 명령어들의 집합의 시작번지
// 2. 람다 - 이름 없는 함수
//



//----
int main()
//----
{
	class Dog{};
	std::cout << typeid(Dog).name() << std::endl;

	// lambda
	auto x = []() {
		std::cout << "안녕? 나는 람다라고 해! 불러줘서 반가워!" << std::endl;
	};
	
	std::cout << typeid(x).name() << std::endl;
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 1007
저장시간: 2022-03-24 11:05:40 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(4주 1일)
// 
// 호출가능(Callable) 타입 - 예제는 sort를 사용
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"

// using namespace std;


// 호츨가능(Callable) 타입
// 호출가능한 타입은 어떤 것들이 있나
// 1. 함수 - CODE SEGMENT에 기록된 명령어들의 집합의 시작번지
// 2. 람다 - 이름 없는 함수
//



//----
int main()
//----
{
	class Dog{};
	std::cout << typeid(Dog).name() << std::endl;

	// lambda
	auto x = []() {
		std::cout << "안녕? 나는 람다라고 해! 불러줘서 반가워!" << std::endl;
	};
	
	std::cout << typeid(x).name() << std::endl;
	
	auto x1 = []() {
		std::cout << "안녕? 나는 람다라고 해! 불러줘서 반가워!" << std::endl;
	};

	std::cout << typeid(x1).name() << std::endl;
	
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 1067
저장시간: 2022-03-24 11:06:12 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(4주 1일)
// 
// 호출가능(Callable) 타입 - 예제는 sort를 사용
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"

// using namespace std;


// 호츨가능(Callable) 타입
// 호출가능한 타입은 어떤 것들이 있나
// 1. 함수 - CODE SEGMENT에 기록된 명령어들의 집합의 시작번지
// 2. 람다 - 이름 없는 함수
//

class Cat{};

//----
int main()
//----
{
	std::cout << typeid(Cat).name() << std::endl;
	class Dog{};
	std::cout << typeid(Dog).name() << std::endl;

	// lambda
	auto x = []() {
		std::cout << "안녕? 나는 람다라고 해! 불러줘서 반가워!" << std::endl;
	};
	
	std::cout << typeid(x).name() << std::endl;
	
	auto x1 = []() {
		std::cout << "안녕? 나는 람다라고 해! 불러줘서 반가워!" << std::endl;
	};

	std::cout << typeid(x1).name() << std::endl;
	
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 922
저장시간: 2022-03-24 11:06:54 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(4주 1일)
// 
// 호출가능(Callable) 타입 - 예제는 sort를 사용
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"

// using namespace std;


// 호츨가능(Callable) 타입
// 호출가능한 타입은 어떤 것들이 있나
// 1. 함수 - CODE SEGMENT에 기록된 명령어들의 집합의 시작번지
// 2. 람다 - 이름 없는 함수
//

class Cat{};


auto x = []() {
	std::cout << "안녕? 나는 람다라고 해! 불러줘서 반가워!" << std::endl;
};

//----
int main()
//----
{
	std::cout << typeid(Cat).name() << std::endl;
	class Dog{};
	std::cout << typeid(Dog).name() << std::endl;

	// lambda
	
	
	std::cout << typeid(x).name() << std::endl;
	
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 874
저장시간: 2022-03-24 11:13:31 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(4주 1일)
// 
// 호출가능(Callable) 타입 - 예제는 sort를 사용
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"

// using namespace std;


// 호츨가능(Callable) 타입
// 호출가능한 타입은 어떤 것들이 있나
// 1. 함수 - CODE SEGMENT에 기록된 명령어들의 집합의 시작번지
// 2. 람다 - 이름 없는 함수, 실제는 클래스로 구현한다.
// 3. 클래스 객체 -  
//

// 어떤 클래스가 () 연산자를 오버로딩하였다면 그 객체는 호출 가능하다.
class Dog {
public:
	void operator()() {
		std::cout << "Dog 호출" << std::endl;
	}
};



//----
int main()
//----
{
	Dog dog;

	dog();

	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 1048
저장시간: 2022-03-24 11:16:26 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(4주 1일)
// 
// 호출가능(Callable) 타입 - 예제는 sort를 사용
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
//-----------------------------------------------------------------------------
#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"

// using namespace std;


// 호츨가능(Callable) 타입
// 호출가능한 타입은 어떤 것들이 있나
// 1. 함수 - CODE SEGMENT에 기록된 명령어들의 집합의 시작번지
// 2. 람다 - 이름 없는 함수, 실제는 클래스로 구현한다.
// 3. 클래스 객체 -  
//

// 어떤 클래스가 () 연산자를 오버로딩하였다면 그 객체는 호출 가능하다.
class Dog {
public:
	bool operator()(int a, int b) {
		std::cout << "Dog 호출" << std::endl;
		return a > b;
	}
};



//----
int main()
//----
{
	std::array<int, 5> a{ 1,3,5,2,4 };
	std::sort(a.begin(), a.end(), Dog());

	for (int n : a)
		std::cout << n << std::endl;
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 1090
저장시간: 2022-03-24 11:17:36 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(4주 1일)
// 
// 호출가능(Callable) 타입 - 예제는 sort를 사용
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
//-----------------------------------------------------------------------------
#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"

// using namespace std;


// 호츨가능(Callable) 타입
// 호출가능한 타입은 어떤 것들이 있나
// 1. 함수 - CODE SEGMENT에 기록된 명령어들의 집합의 시작번지
// 2. 람다 - 이름 없는 함수, 실제는 클래스로 구현한다.
// 3. 클래스 객체 -  
//

// 어떤 클래스가 () 연산자를 오버로딩하였다면 그 객체는 호출 가능하다.
class Dog {
public:
	bool operator()(int a, int b) {
		std::cout << "Dog 호출 - " << a << " - " << b << std::endl;
		return a > b;
	}
};



//----
int main()
//----
{
	std::array<int, 5> a{ 1,3,5,2,4 };
	std::sort(a.begin(), a.end(), Dog());

	for (int n : a)
		std::cout << n << ' ';
	std::cout << std::endl;
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 1146
저장시간: 2022-03-24 11:20:04 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(4주 1일)
// 
// 호출가능(Callable) 타입 - 예제는 sort를 사용
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
//-----------------------------------------------------------------------------
#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"

// using namespace std;


// 호츨가능(Callable) 타입
// 호출가능한 타입은 어떤 것들이 있나
// 1. 함수 - CODE SEGMENT에 기록된 명령어들의 집합의 시작번지
// 2. 람다 - 이름 없는 함수, 실제는 클래스로 구현한다.
// 3. 클래스 객체 - function call operator()을 오버로딩한 클래스
// 어떤 클래스가 () 연산자를 오버로딩하였다면 그 객체는 호출 가능하다.
//


class Dog {
public:
	bool operator()(int a, int b) {
		std::cout << "Dog 호출 - " << a << " - " << b << std::endl;
		return a < b;
	}
};



//----
int main()
//----
{
	std::array<int, 5> a{ 1,3,5,2,4 };
	Dog dog;

	std::sort(a.begin(), a.end(), dog);

	for (int n : a)
		std::cout << n << ' ';
	std::cout << std::endl;
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 880
저장시간: 2022-03-24 11:35:22 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(4주 1일)
// 
// 호출가능(Callable) 타입 - 예제는 sort를 사용
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
//-----------------------------------------------------------------------------
#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"

// using namespace std;


// 호츨가능(Callable) 타입 - 무한대
// 호출가능한 타입은 어떤 것들이 있나
// 1. 함수포인터 - CODE SEGMENT에 기록된 명령어들의 집합의 시작번지
// 2. 람다 - 이름 없는 함수, 실제는 클래스로 구현한다.
// 3. operator()을 오버로딩한 클래스
// 4. 멤버함수포인터
//

// - 호출가능 카입의 종류가 무한하기 때문에
// 모든 호출가능타입을 대표하는 클래스를 만들었다 fuction

//----
int main()
//----
{
	
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 618
저장시간: 2022-03-24 11:37:28 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(4주 1일)
// 
// 호출가능(Callable) 타입 - 예제는 sort를 사용
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
//-----------------------------------------------------------------------------
#include <iostream>
#include <functional>
#include "save.h"

// using namespace std;

int add(int a, int b) 
{
	return a + b;
}

//----
int main()
//----
{
	std::function<int(int, int)> f;
	f = add;
	
	std::cout << f(3, 3) << std::endl;
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 1232
저장시간: 2022-03-24 12:03:16 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(4주 1일)
// 
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
//	STRING 
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"

// using namespace std;

// [문제] main()이 문제없이 실행되도록 class STRING을 코딩하라.
// speacial 함수는 동작을 관찰하도록 cout으로 메모리와 동작을 코딩한다.
// 객체 생성시 고유번호를 갖도록 한다.

class STRING {
	size_t num;
	int id;				// 생성 시 부여
	char* data;
	static int cid;		// 객체가 생성될 때 1 증가
public:
	STRING(const char* str) : num{ strlen(str) }, data { new char[num] } {
		memcpy(data, str, num);

		id = ++cid;
		// 관찰메시지를 켜면 출력한다.
		std::cout << "ctor [" << id << "] " << this << std::endl;
	}


	~STRING() {
		// 관찰메시지를 켜면 출력한다.
		std::cout << "dtor [" << id << "] " << this << std::endl;
		delete[] data;
	}
};

int STRING::cid{};

//----
int main()
//----
{
	STRING a{ "2022 1학기" };
	STRING b{ "STL" };
	
	/*std::cout << a << std::endl;
	std::cout << b << std::endl;*/

	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 1433
저장시간: 2022-03-24 12:07:58 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(4주 1일)
// 
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
//	STRING 
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"

// using namespace std;

// [문제] main()이 문제없이 실행되도록 class STRING을 코딩하라.
// speacial 함수는 동작을 관찰하도록 cout으로 메모리와 동작을 코딩한다.
// 객체 생성시 고유번호를 갖도록 한다.

class STRING {
	size_t num;
	int id;				// 생성 시 부여
	char* data;
	static int cid;		// 객체가 생성될 때 1 증가
public:
	STRING(const char* str) : num{ strlen(str) }, data { new char[num] } {
		memcpy(data, str, num);

		id = ++cid;
		// 관찰메시지를 켜면 출력한다.
		std::cout << "ctor [" << id << "] " << this << std::endl;
	}


	~STRING() {
		// 관찰메시지를 켜면 출력한다.
		std::cout << "dtor [" << id << "] " << this << std::endl;
		delete[] data;
	}

	friend std::ostream& operator<<(std::ostream&, const STRING&);
};


int STRING::cid{};
std::ostream& operator<<(std::ostream& os, const STRING& s)
{
	for (int i = 0; i < s.num; ++i)
		os << s.data[i];

	return os;
}

//----
int main()
//----
{
	STRING a{ "2022 1학기" };
	STRING b{ "STL" };
	
	std::cout << a << std::endl;
	std::cout << b << std::endl;

	save("소스.cpp");
}
