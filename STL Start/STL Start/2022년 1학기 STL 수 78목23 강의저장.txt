파일이름: 소스.cpp
파일크기: 1660
저장시간: 2022-03-02 17:09:31 GMT+9
파일이름: 소스.cpp
파일크기: 1729
저장시간: 2022-03-02 17:11:55 GMT+9
파일이름: 소스.cpp
파일크기: 1952
저장시간: 2022-03-02 17:15:16 GMT+9
//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 2일 수요일(1주 1일)
// 
// - 강의소개, 출석점수없음
// - 교과서, cppreference.com
// - google coding convention을 참고
// - 프로젝트 환경설정 Release/x64
//		메뉴 - 프로젝트 - 설정 - C++언어: 최신언어초안
// - 공부란 무엇인가?
// 할 일 - 한학기 코딩한 내용을 저장할 수 있게 save 기능 완성
//-----------------------------------------------------------------------------
#include <iostream>
#include <string_view>
#include <filesystem>
#include <chrono>	// 시간 관련 함수
#include <fstream>
#include <vector>
#include <algorithm>

//using namespace std;
//void save(const string&);
void save(std::string_view);

int main()
{
	// string과 string_view 크기 확인
	
	std::cout << "string 크기:"<< sizeof(std::string) << std::endl;
	std::cout << "string_view 크기:"<< sizeof(std::string_view) << std::endl;
	save("소스.cpp");
}

void save(std::string_view fname)
{
	// 읽을 파일을 연다
	std::ifstream in{ fname.data() };


	// 쓸 파일도 연다
	std::ofstream out{ "2022년 1학기 STL 수 78목23 강의저장.txt", std::ios::app };


	// 저장할 파일이름과 크기(C++17)를 출력한다.
	out << "파일이름: " << fname << std::endl;
	out << "파일크기: " << std::filesystem::file_size(fname) << std::endl;
	

	// 현재 날짜와 시간(C++20)을 출력한다.
	auto time = floor<std::chrono::seconds>(std::chrono::system_clock::now());
	out << "저장시간: " << std::chrono::zoned_time("Asia/Seoul", time) << std::endl;
	

	// 읽은 파일을 강의저장 파일에 덧붙인다.
	// 1. 벡터에 파일을 읽어온다.
	// std::vector<char> v{ std::istream_iterator<char>{in}, {} };
	std::vector<char> v{ std::istreambuf_iterator<char>{in}, {} };		// 띄어쓰기도 포함해서 저장
	
	/*for (char c : v)
		out << c;*/

	// 2. copy 알고리즘으로 벡터에 있는 글자를 강의저장파일로 복사한다
	std::copy(v.begin(), v.end(), std::ostream_iterator<char>{out});

}

파일이름: 소스.cpp
파일크기: 2053


저장시간: 2022-03-02 17:16:11 GMT+9


//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 2일 수요일(1주 1일)
// 
// - 강의소개, 출석점수없음
// - 교과서, cppreference.com
// - google coding convention을 참고
// - 프로젝트 환경설정 Release/x64
//		메뉴 - 프로젝트 - 설정 - C++언어: 최신언어초안
// - 공부란 무엇인가?
// 할 일 - 한학기 코딩한 내용을 저장할 수 있게 save 기능 완성
//-----------------------------------------------------------------------------
#include <iostream>
#include <string_view>
#include <filesystem>
#include <chrono>	// 시간 관련 함수
#include <fstream>
#include <vector>
#include <algorithm>

//using namespace std;
//void save(const string&);
void save(std::string_view);

int main()
{
	// string과 string_view 크기 확인
	
	std::cout << "string 크기:"<< sizeof(std::string) << std::endl;
	std::cout << "string_view 크기:"<< sizeof(std::string_view) << std::endl;
	save("소스.cpp");
}

void save(std::string_view fname)
{
	// 읽을 파일을 연다
	std::ifstream in{ fname.data() };


	// 쓸 파일도 연다
	std::ofstream out{ "2022년 1학기 STL 수 78목23 강의저장.txt", std::ios::app };


	// 저장할 파일이름과 크기(C++17)를 출력한다.
	out << std::endl << std::endl;
	out << "파일이름: " << fname << std::endl;
	out << "파일크기: " << std::filesystem::file_size(fname) << std::endl;
	

	// 현재 날짜와 시간(C++20)을 출력한다.
	out << std::endl << std::endl;
	auto time = floor<std::chrono::seconds>(std::chrono::system_clock::now());
	out << "저장시간: " << std::chrono::zoned_time("Asia/Seoul", time) << std::endl;
	

	// 읽은 파일을 강의저장 파일에 덧붙인다.
	// 1. 벡터에 파일을 읽어온다.
	out << std::endl << std::endl;

	// std::vector<char> v{ std::istream_iterator<char>{in}, {} };
	std::vector<char> v{ std::istreambuf_iterator<char>{in}, {} };		// 띄어쓰기도 포함해서 저장
	
	/*for (char c : v)
		out << c;*/

	// 2. copy 알고리즘으로 벡터에 있는 글자를 강의저장파일로 복사한다
	std::copy(v.begin(), v.end(), std::ostream_iterator<char>{out});

}

파일이름: 소스.cpp
파일크기: 2245


저장시간: 2022-03-03 10:38:15 GMT+9


//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 2일 수요일(1주 1일)
// 
// - 강의소개, 출석점수없음
// - 교과서, cppreference.com
// - google coding convention을 참고
// - 프로젝트 환경설정 Release/x64
//		메뉴 - 프로젝트 - 설정 - C++언어: 최신언어초안
// - 공부란 무엇인가?
// 할 일 - 한학기 코딩한 내용을 저장할 수 있게 save 기능 완성
// 
// 읽은 파일의 정보를 읽어 쓸 파일에 덧붙여 쓴다
// Youtube - Back to Basics Classic STL 강의를 볼 수 있다면 도움이 될 것임
//-----------------------------------------------------------------------------
#include <iostream>
#include <string_view>
#include <filesystem>
#include <chrono>	// 시간 관련 함수
#include <fstream>
#include <vector>
#include <algorithm>

//using namespace std;
//void save(const string&);
void save(std::string_view);

int main()
{
	// string과 string_view 크기 확인
	
	std::cout << "string 크기:"<< sizeof(std::string) << std::endl;
	std::cout << "string_view 크기:"<< sizeof(std::string_view) << std::endl;
	save("소스.cpp");
}

void save(std::string_view fname)
{
	// 읽을 파일을 연다 - RALL
	std::ifstream in{ fname.data() };


	// 쓸 파일도 연다
	std::ofstream out{ "2022년 1학기 STL 수 78목23 강의저장.txt", std::ios::app };


	// 저장할 파일이름과 크기(C++17)를 출력한다.
	out << std::endl << std::endl;
	out << "파일이름: " << fname << std::endl;
	out << "파일크기: " << std::filesystem::file_size(fname) << std::endl;
	

	// 현재 날짜와 시간(C++20)을 출력한다.
	out << std::endl << std::endl;
	auto time = floor<std::chrono::seconds>(std::chrono::system_clock::now());
	out << "저장시간: " << std::chrono::zoned_time("Asia/Seoul", time) << std::endl;
	

	// 읽은 파일을 강의저장 파일에 덧붙인다.
	// 1. 벡터에 파일을 읽어온다.
	out << std::endl << std::endl;

	// std::vector<char> v{ std::istream_iterator<char>{in}, {} };

	// 1. 벡터에 파일을 읽어온다 - 컨테이너(자료구조)
	std::vector<char> v{ std::istreambuf_iterator<char>{in}, {} };		// 띄어쓰기도 포함해서 저장
	
	/*for (char c : v)
		out << c;*/

	// 2. copy 알고리즘으로 벡터에 있는 글자를 강의저장파일로 복사한다
	std::copy(v.begin(), v.end(), std::ostream_iterator<char>{out});

}

파일이름: 소스.cpp
파일크기: 692


저장시간: 2022-03-03 10:41:59 GMT+9


//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일(1주 2일)
// 
// 할 일 - 어제 코딩한 save 함수를 save.cpp로 분리한 후 실행되도록 수정
// 
// Youtube - Back to Basics Classic STL 강의를 볼 수 있다면 도움이 될 것임
//-----------------------------------------------------------------------------
#include <iostream>


//using namespace std;
//void save(const string&);
void save(std::string_view);

int main()
{
	// string과 string_view 크기 확인
	
	std::cout << "string 크기:"<< sizeof(std::string) << std::endl;
	std::cout << "string_view 크기:"<< sizeof(std::string_view) << std::endl;
	save("소스.cpp");
}

파일이름: 소스.cpp
파일크기: 650


저장시간: 2022-03-03 10:46:55 GMT+9


//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일(1주 2일)
// 
// 할 일 - 어제 코딩한 save 함수를 save.cpp로 분리한 후 실행되도록 수정
// 
// Youtube - Back to Basics Classic STL 강의를 볼 수 있다면 도움이 될 것임
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"

//using namespace std;

int main()
{
	// string과 string_view 크기 확인
	
	std::cout << "string 크기:"<< sizeof(std::string) << std::endl;
	std::cout << "string_view 크기:"<< sizeof(std::string_view) << std::endl;
	save("소스.cpp");
}

파일이름: save.h
파일크기: 97


저장시간: 2022-03-03 11:03:24 GMT+9


#pragma once
#include <string_view>

//void save(const string&);
void save(std::string_view);

파일이름: save.cpp
파일크기: 1646


저장시간: 2022-03-03 11:03:24 GMT+9


//-----------------------------------------------------------------------------
// Save.cpp
// 
// 이 함수를 호출하면 "2022년 1학기 STL 수78목23 강의저장.txt"에
// 전달된 이름의 파일을 읽어 덧붙인다.
// 
// 2022.3.3	Programmed by HS
//-----------------------------------------------------------------------------

#include <filesystem>
#include <fstream>
#include <vector>
#include <chrono>	// 시간 관련 함수
#include <algorithm>
#include <cmath>	// floor
#include "save.h"

void save(std::string_view fname)
{
	// 읽을 파일을 연다 - RALL
	std::ifstream in{ fname.data() };


	// 쓸 파일도 연다
	std::ofstream out{ "2022년 1학기 STL 수 78목23 강의저장.txt", std::ios::app };


	// 저장할 파일이름과 크기(C++17)를 출력한다.
	out << std::endl << std::endl;
	out << "파일이름: " << fname << std::endl;
	out << "파일크기: " << std::filesystem::file_size(fname) << std::endl;


	// 현재 날짜와 시간(C++20)을 출력한다.
	out << std::endl << std::endl;
	auto time = floor<std::chrono::seconds>(std::chrono::system_clock::now());
	out << "저장시간: " << std::chrono::zoned_time("Asia/Seoul", time) << std::endl;


	// 읽은 파일을 강의저장 파일에 덧붙인다.
	// 1. 벡터에 파일을 읽어온다.
	out << std::endl << std::endl;

	// std::vector<char> v{ std::istream_iterator<char>{in}, {} };

	// 1. 벡터에 파일을 읽어온다 - 컨테이너(자료구조)
	std::vector<char> v{ std::istreambuf_iterator<char>{in}, {} };		// 띄어쓰기도 포함해서 저장

	/*for (char c : v)
		out << c;*/

	// 2. copy 알고리즘으로 벡터에 있는 글자를 강의저장파일로 복사한다
	std::copy(v.begin(), v.end(), std::ostream_iterator<char>{out});

}

파일이름: 소스.cpp
파일크기: 507


저장시간: 2022-03-03 11:03:24 GMT+9


//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일(1주 2일)
// 
// 할 일 - 어제 코딩한 save 함수를 save.cpp로 분리한 후 실행되도록 수정
// 
// Youtube - Back to Basics Classic STL 강의를 볼 수 있다면 도움이 될 것임
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"

//using namespace std;

int main()
{
	save("save.h");
	save("save.cpp");
	save("소스.cpp");
}

파일이름: save.h
파일크기: 97
저장시간: 2022-03-03 11:05:46 GMT+9

#pragma once
#include <string_view>

//void save(const string&);
void save(std::string_view);

파일이름: save.cpp
파일크기: 1600
저장시간: 2022-03-03 11:05:46 GMT+9

//-----------------------------------------------------------------------------
// Save.cpp
// 
// 이 함수를 호출하면 "2022년 1학기 STL 수78목23 강의저장.txt"에
// 전달된 이름의 파일을 읽어 덧붙인다.
// 
// 2022.3.3	Programmed by HS
//-----------------------------------------------------------------------------

#include <filesystem>
#include <fstream>
#include <vector>
#include <chrono>	// 시간 관련 함수
#include <algorithm>
#include <cmath>	// floor
#include "save.h"

void save(std::string_view fname)
{
	// 읽을 파일을 연다 - RALL
	std::ifstream in{ fname.data() };


	// 쓸 파일도 연다
	std::ofstream out{ "2022년 1학기 STL 수 78목23 강의저장.txt", std::ios::app };


	// 저장할 파일이름과 크기(C++17)를 출력한다.
	out << std::endl << std::endl;
	out << "파일이름: " << fname << std::endl;
	out << "파일크기: " << std::filesystem::file_size(fname) << std::endl;


	// 현재 날짜와 시간(C++20)을 출력한다.
	auto time = floor<std::chrono::seconds>(std::chrono::system_clock::now());
	out << "저장시간: " << std::chrono::zoned_time("Asia/Seoul", time) << std::endl;


	// 읽은 파일을 강의저장 파일에 덧붙인다.
	// 1. 벡터에 파일을 읽어온다.
	out << std::endl;

	// std::vector<char> v{ std::istream_iterator<char>{in}, {} };

	// 1. 벡터에 파일을 읽어온다 - 컨테이너(자료구조)
	std::vector<char> v{ std::istreambuf_iterator<char>{in}, {} };		// 띄어쓰기도 포함해서 저장

	/*for (char c : v)
		out << c;*/

	// 2. copy 알고리즘으로 벡터에 있는 글자를 강의저장파일로 복사한다
	std::copy(v.begin(), v.end(), std::ostream_iterator<char>{out});

}

파일이름: 소스.cpp
파일크기: 507
저장시간: 2022-03-03 11:05:46 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일(1주 2일)
// 
// 할 일 - 어제 코딩한 save 함수를 save.cpp로 분리한 후 실행되도록 수정
// 
// Youtube - Back to Basics Classic STL 강의를 볼 수 있다면 도움이 될 것임
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"

//using namespace std;

int main()
{
	save("save.h");
	save("save.cpp");
	save("소스.cpp");
}

파일이름: 소스.cpp
파일크기: 756
저장시간: 2022-03-03 11:16:28 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일(1주 2일)
// 
// 할 일 - 어제 코딩한 save 함수를 save.cpp로 분리한 후 실행되도록 수정
// 
// Youtube - Back to Basics Classic STL 강의를 볼 수 있다면 도움이 될 것임
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"

//using namespace std;

// [문제] main()을 변경하면 안된다.
// 실행하면 a와 b의 값ㅇ이 서로 바뀌어야한다.

void change(int&, int&);

int main()
{
	int a{ 1 };
	int b{ 2 };

	change(a, b);

	std::cout << a << ", " << b << std::endl;
	save("소스.cpp");
}

void change(int& a, int& b)
{
	int tmp;
	tmp = a;
	a = b;
	b = tmp;

}

파일이름: 소스.cpp
파일크기: 778
저장시간: 2022-03-03 11:36:47 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일(1주 2일)
// 
// 할 일 - 어제 코딩한 save 함수를 save.cpp로 분리한 후 실행되도록 수정
// 
// Youtube - Back to Basics Classic STL 강의를 볼 수 있다면 도움이 될 것임
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"

//using namespace std;

// [문제] main()을 변경하면 안된다.
// 실행하면 a와 b의 값ㅇ이 서로 바뀌어야한다.

void change(int&, int&);

int main()
{
	int a{ 1 };
	int b{ 2 };

	change(a, b);

	std::cout << a << ", " << b << std::endl;
	save("소스.cpp");
}

void change(int& a, int& b)
{
	int tmp{};	// default 초기화

	tmp = a;
	a = b;
	b = tmp;

}

파일이름: 소스.cpp
파일크기: 1154
저장시간: 2022-03-03 11:47:05 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일(1주 2일)
// 
// 할 일 - 어제 코딩한 save 함수를 save.cpp로 분리한 후 실행되도록 수정
// 
// Youtube - Back to Basics Classic STL 강의를 볼 수 있다면 도움이 될 것임
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"

//using namespace std;

// [문제] main()을 변경하면 안된다.
// 실행하면 a와 b의 값이 서로 바뀌어야한다.

class Dog {
	int age;
public:
	Dog() {
		age = 0;
	}

	Dog(int i) :age(i) {

	}

	int getAge()
	{
		return age;
	}

	void changeAge(int i)
	{
		age = i;
	}
};

void change(Dog&, Dog&);
std::ostream& operator <<(std::ostream&, Dog&);

int main()
{
	Dog a{ 1 };
	Dog b{ 2 };

	change(a, b);

	std::cout << a << ", " << b << std::endl;
	save("소스.cpp");
}

void change(Dog& a, Dog& b)
{
	Dog tmp{};	// default 초기화

	tmp.changeAge(a.getAge());
	a.changeAge(b.getAge());
	b.changeAge(tmp.getAge());
}

std::ostream& operator <<(std::ostream& c, Dog& dog)
{
	c << dog.getAge();
	return c;
}

파일이름: 소스.cpp
파일크기: 1169
저장시간: 2022-03-03 12:13:23 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일(1주 2일)
// 
// 할 일 - 어제 코딩한 save 함수를 save.cpp로 분리한 후 실행되도록 수정
// 
// Youtube - Back to Basics Classic STL 강의를 볼 수 있다면 도움이 될 것임
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"

//using namespace std;

// [문제] main()을 변경하면 안된다.
// 실행하면 a와 b의 값이 서로 바뀌어야한다.

class Dog {
	int age;
public:
	Dog() = default;

	Dog(int i) :age{ i } {};

	int getAge() const
	{
		return age;
	}

	void changeAge(const int i)
	{
		age = i;
	}
};

void change(Dog&, Dog&);
std::ostream& operator <<(std::ostream&, const Dog&);

int main()
{
	Dog a{ 1 };
	Dog b{ 2 };

	change(a, b);

	std::cout << a << ", " << b << std::endl;
	save("소스.cpp");
}

void change(Dog& a, Dog& b)
{
	Dog tmp{};	// default 초기화

	tmp.changeAge(a.getAge());
	a.changeAge(b.getAge());
	b.changeAge(tmp.getAge());
}

std::ostream& operator <<(std::ostream& c, const Dog& dog)
{
	c << dog.getAge();
	return c;
}

파일이름: 소스.cpp
파일크기: 813
저장시간: 2022-03-10 10:58:24 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일(2주 1일)
// 
// 할 일 -
// 템플릿
// 많은 데이터를 다루는 연습 - 파일
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"

//using namespace std;

using namespace std::string_literals;

template<typename T>
void change(T& a, T& b) {
	T tmp{};
	tmp = a;
	a = b;
	b = tmp;
}

// [문제] change를 한번만 선언하고 정의하여
// main()이 수정없이 실행되도록 하라(5분)
//----
int main()
//----
{
	{
		int a{ 1 }, b{ 2 };
		change(a, b);
		std::cout << a << "," << b << std::endl;
	}
	{
		std::string a{ "1"s}, b{"2"s};
		change(a, b);
		std::cout << a << "," << b << std::endl;
	}
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 952
저장시간: 2022-03-10 10:59:34 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일(2주 1일)
// 
// 할 일 -
// 템플릿
// 많은 데이터를 다루는 연습 - 파일
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"

//using namespace std;

using namespace std::string_literals;

template<typename T>
void change(T& a, T& b) {
	T tmp{};
	tmp = a;
	a = b;
	b = tmp;
}

template<>
void change(int& a, int& b)
{
	std::cout << "int 인자의 경우 불리는 함수\n";
	int tmp;
	tmp = a;
	a = b;
	b = tmp;
}

// [문제] change를 한번만 선언하고 정의하여
// main()이 수정없이 실행되도록 하라(5분)
//----
int main()
//----
{
	{
		int a{ 1 }, b{ 2 };
		change(a, b);
		std::cout << a << "," << b << std::endl;
	}
	{
		std::string a{ "1"s}, b{"2"s};
		change(a, b);
		std::cout << a << "," << b << std::endl;
	}
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 949
저장시간: 2022-03-10 11:00:23 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일(2주 1일)
// 
// 할 일 -
// 템플릿
// 많은 데이터를 다루는 연습 - 파일
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"

//using namespace std;

using namespace std::string_literals;

template<class T>
void change(T& a, T& b) {
	T tmp{};
	tmp = a;
	a = b;
	b = tmp;
}

template<>
void change(int& a, int& b)
{
	std::cout << "int 인자의 경우 불리는 함수\n";
	int tmp;
	tmp = a;
	a = b;
	b = tmp;
}

// [문제] change를 한번만 선언하고 정의하여
// main()이 수정없이 실행되도록 하라(5분)
//----
int main()
//----
{
	{
		int a{ 1 }, b{ 2 };
		change(a, b);
		std::cout << a << "," << b << std::endl;
	}
	{
		std::string a{ "1"s}, b{"2"s};
		change(a, b);
		std::cout << a << "," << b << std::endl;
	}
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 977
저장시간: 2022-03-10 11:11:18 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일(2주 1일)
// 
// 할 일 -
// 템플릿 - 자료형에 관계없는 함수와 클래스를 만드는 핵심 Keyword
//		 - 이런 방식의 코딩을 generic programming이라고 함
// 많은 데이터를 다루는 연습 - 파일
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"

//using namespace std;

using namespace std::string_literals;

template<class T>
void change(T& a, T& b) {
	T tmp{};
	tmp = a;
	a = b;
	b = tmp;
}

template<>
void change(int& a, int& b)
{
	std::cout << "int 인자의 경우 불리는 함수\n";
	int tmp;
	tmp = a;
	a = b;
	b = tmp;
}



//----
int main()
//----
{
	{
		int a{ 1 }, b{ 2 };
		change(a, b);
		std::cout << a << "," << b << std::endl;
	}
	{
		std::string a{ "1"s}, b{"2"s};
		change(a, b);
		std::cout << a << "," << b << std::endl;
	}
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 505
저장시간: 2022-03-10 11:11:42 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일(2주 1일)
// 
// 할 일 -
// 템플릿 - 자료형에 관계없는 함수와 클래스를 만드는 핵심 Keyword
//		 - 이런 방식의 코딩을 generic programming이라고 함
// 많은 데이터를 다루는 연습 - 파일
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"

//using namespace std;

//----
int main()
//----
{
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 669
저장시간: 2022-03-10 11:17:07 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일(2주 1일)
// 
// 할 일 -
// 템플릿 - 자료형에 관계없는 함수와 클래스를 만드는 핵심 Keyword
//		 - 이런 방식의 코딩을 generic programming이라고 함
// 많은 데이터를 다루는 연습 - 파일
//-----------------------------------------------------------------------------
#include <iostream>
#include <random>
#include "save.h"

//using namespace std;

// [문제] 임의의 값을 갖는(random value) int 1000개를 화면에 출력하라.

//----
int main()
//----
{	
	for (int i = 0; i < 1000; ++i)
		std::cout << rand() << std::endl;
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 914
저장시간: 2022-03-10 11:45:02 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일(2주 1일)
// 
// 할 일 -
// 템플릿 - 자료형에 관계없는 함수와 클래스를 만드는 핵심 Keyword
//		 - 이런 방식의 코딩을 generic programming이라고 함
// 많은 데이터를 다루는 연습 - 파일
//		- 랜덤 데이터를 생성하는 방법(엔진/분포) - 시험에서는 노말한 분포를 자주 냄
//-----------------------------------------------------------------------------
#include <iostream>
#include <random>
#include "save.h"

//using namespace std;

// [문제] 엔진과 분포를 사용하여 임의의 값을 갖는(random value) 
// int 1000개를 화면에 출력하라.

std::random_device rd;
std::default_random_engine dre{ rd() };

//----
int main()
//----
{	
	std::uniform_int_distribution uid;
	for (int i = 0; i < 1'000; ++i)
	{
		std::cout << uid(dre) << '\t';
	}
	std::cout << std::endl;
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 906
저장시간: 2022-03-10 11:47:29 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일(2주 1일)
// 
// 할 일 -
// 템플릿 - 자료형에 관계없는 함수와 클래스를 만드는 핵심 Keyword
//		 - 이런 방식의 코딩을 generic programming이라고 함
// 많은 데이터를 다루는 연습 - 파일
//		- 랜덤 데이터를 생성하는 방법(엔진/분포) - 시험에서는 노말한 분포를 자주 냄
//-----------------------------------------------------------------------------
#include <iostream>
#include <random>
#include "save.h"

//using namespace std;

// [문제] int의 최대값을 출력하라

std::random_device rd;
std::default_random_engine dre{ rd() };

//----
int main()
//----
{	
	std::uniform_int_distribution uid;
	for (int i = 0; i < 1'000; ++i)
	{
		std::cout << uid(dre) << '\t';
	}
	std::cout << std::endl;
	std::cout << "UINT 최대값: " << UINT_MAX << std::endl;
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 928
저장시간: 2022-03-10 11:48:47 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일(2주 1일)
// 
// 할 일 -
// 템플릿 - 자료형에 관계없는 함수와 클래스를 만드는 핵심 Keyword
//		 - 이런 방식의 코딩을 generic programming이라고 함
// 많은 데이터를 다루는 연습 - 파일
//		- 랜덤 데이터를 생성하는 방법(엔진/분포) - 시험에서는 노말한 분포를 자주 냄
//-----------------------------------------------------------------------------
#include <iostream>
#include <random>
#include "save.h"

//using namespace std;

// [문제] int의 최대값을 출력하라

std::random_device rd;
std::default_random_engine dre{ rd() };

//----
int main()
//----
{	
	std::uniform_int_distribution uid;
	for (int i = 0; i < 1'000; ++i)
	{
		std::cout << uid(dre) << '\t';
	}
	std::cout << std::endl;
	std::cout << "INT 최대값: " << std::numeric_limits<int>::max() << std::endl;
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 937
저장시간: 2022-03-10 11:48:58 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일(2주 1일)
// 
// 할 일 -
// 템플릿 - 자료형에 관계없는 함수와 클래스를 만드는 핵심 Keyword
//		 - 이런 방식의 코딩을 generic programming이라고 함
// 많은 데이터를 다루는 연습 - 파일
//		- 랜덤 데이터를 생성하는 방법(엔진/분포) - 시험에서는 노말한 분포를 자주 냄
//-----------------------------------------------------------------------------
#include <iostream>
#include <random>
#include "save.h"

//using namespace std;

// [문제] int의 최대값을 출력하라

std::random_device rd;
std::default_random_engine dre{ rd() };

//----
int main()
//----
{	
	std::uniform_int_distribution uid;
	for (int i = 0; i < 1'000; ++i)
	{
		std::cout << uid(dre) << '\t';
	}
	std::cout << std::endl;
	std::cout << "INT 최대값: " << std::numeric_limits<unsigned int>::max() << std::endl;
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 951
저장시간: 2022-03-10 11:50:50 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일(2주 1일)
// 
// 할 일 -
// 템플릿 - 자료형에 관계없는 함수와 클래스를 만드는 핵심 Keyword
//		 - 이런 방식의 코딩을 generic programming이라고 함
// 많은 데이터를 다루는 연습 - 파일
//		- 랜덤 데이터를 생성하는 방법(엔진/분포) - 시험에서는 노말한 분포를 자주 냄
//-----------------------------------------------------------------------------
#include <iostream>
#include <random>
#include "save.h"

//using namespace std;

// [문제] int의 최대값을 출력하라

std::random_device rd;
std::default_random_engine dre{ rd() };

//----
int main()
//----
{	
	std::uniform_int_distribution uid;
	for (int i = 0; i < 1'000; ++i)
	{
		std::cout << uid(dre) << '\t';
	}
	std::cout << std::endl;
	int num = 0B01111111'11111111'11111111'11111111;
	std::cout << "INT 최대값: " << num << std::endl;
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 924
저장시간: 2022-03-10 11:51:49 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일(2주 1일)
// 
// 할 일 -
// 템플릿 - 자료형에 관계없는 함수와 클래스를 만드는 핵심 Keyword
//		 - 이런 방식의 코딩을 generic programming이라고 함
// 많은 데이터를 다루는 연습 - 파일
//		- 랜덤 데이터를 생성하는 방법(엔진/분포) - 시험에서는 노말한 분포를 자주 냄
//-----------------------------------------------------------------------------
#include <iostream>
#include <random>
#include "save.h"

//using namespace std;

// [문제] int의 최대값을 출력하라

std::random_device rd;
std::default_random_engine dre{ rd() };

//----
int main()
//----
{	
	std::uniform_int_distribution uid;
	for (int i = 0; i < 1'000; ++i)
	{
		std::cout << uid(dre) << '\t';
	}
	std::cout << std::endl;
	int num = 0x7FFFFFFF;
	std::cout << "INT 최대값: " << num << std::endl;
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 924
저장시간: 2022-03-10 11:52:25 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일(2주 1일)
// 
// 할 일 -
// 템플릿 - 자료형에 관계없는 함수와 클래스를 만드는 핵심 Keyword
//		 - 이런 방식의 코딩을 generic programming이라고 함
// 많은 데이터를 다루는 연습 - 파일
//		- 랜덤 데이터를 생성하는 방법(엔진/분포) - 시험에서는 노말한 분포를 자주 냄
//-----------------------------------------------------------------------------
#include <iostream>
#include <random>
#include "save.h"

//using namespace std;

// [문제] int의 최대값을 출력하라

std::random_device rd;
std::default_random_engine dre{ rd() };

//----
int main()
//----
{	
	std::uniform_int_distribution uid;
	for (int i = 0; i < 1'000; ++i)
	{
		std::cout << uid(dre) << '\t';
	}
	std::cout << std::endl;
	int num = 0xFFFFFFFF;
	std::cout << "INT 최대값: " << num << std::endl;
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 945
저장시간: 2022-03-10 12:08:16 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일(2주 1일)
// 
// 할 일 -
// 템플릿 - 자료형에 관계없는 함수와 클래스를 만드는 핵심 Keyword
//		 - 이런 방식의 코딩을 generic programming이라고 함
// 많은 데이터를 다루는 연습 - 파일
//		- 랜덤 데이터를 생성하는 방법(엔진/분포) - 시험에서는 노말한 분포를 자주 냄
//-----------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <random>
#include "save.h"

//using namespace std;

// [문제] 랜덤 int 1000개를 "int 1000개.txt"에 저장하라

std::random_device rd;
std::default_random_engine dre{ rd() };

//----
int main()
//----
{	
	std::uniform_int_distribution uid;
	std::ofstream out{ "int 1000개.txt" };	// 이미 있으면 파괴하고 생성

	for (int i = 0; i < 1'000; ++i)
		out << uid(dre) << '\t';
	out << std::endl;

	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 915
저장시간: 2022-03-16 15:40:02 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일(2주 2일)
// 
// 할 일 -
// 다음시간 질문 - int 1000개를 저장하려면 몇 바이트가 필요하니?
//-----------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include "save.h"

//using namespace std;

// [문제] "int 1000개.txt"에 저장된 int 1000개를 화면 출력하라.
// 가장 큰 값을 찾아 화면에 출력하라

//----
int main()
//----
{
	std::ifstream in{ "int 1000개.txt" };
	if (!in)
	{
		std::cout << "파일을 열 수 없다" << std::endl;
		return 0;
	}

	int maxValue = std::numeric_limits<unsigned int>::min();
	int* tmp = new int[1000];
	for (int i = 0; i < 1000; ++i)
	{
		in >> tmp[i];
		if (tmp[i] > maxValue)
			maxValue = tmp[i];
	}

	std::cout << "가장 큰 값: " << maxValue;
	delete[] tmp;
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 794
저장시간: 2022-03-16 15:52:31 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일(2주 2일)
// 
// 할 일 -
// 다음시간 질문 - int 1000개를 저장하려면 몇 바이트가 필요하니?
//-----------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <algorithm>
#include "save.h"

//using namespace std;

// [문제] "int 1000개.txt"에 저장된 int 1000개를 화면 출력하라.
// 가장 큰 값을 찾아 화면에 출력하라

//----
int main()
//----
{
	std::ifstream in{ "int 1000개.txt" };
	if (!in)
	{
		std::cout << "파일을 열 수 없다" << std::endl;
		return 0;
	}

	auto p = std::max_element(std::istream_iterator<int>{in}, {});
	std::cout << "최대값: " << *p << std::endl;
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 802
저장시간: 2022-03-16 16:09:12 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일(2주 2일)
// 
// 할 일 -
//-----------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include "save.h"

//using namespace std;

// [문제] int 1000개를 저장하려면 메모리 몇 바이트가 필요합니까?
//		-> 상황에 따라 다름
//		-> 그렇지만 int 메모리 자체 비트를 그래도 기록하고 일거 온다면
//		-> 어떤 상황에서도 4000바이트면 문제가 없다

// [문제] int 1000개를 "int 1000개.txt" 파일에 메모리 그대로 기록하라.
//----
int main()
//----
{
	std::ofstream out{ "int 1000개.txt" };
	int num;
	for (int i = 0; i < 1000; ++i)
	{
		num = i + 1;
		out.write((const char*)&num, sizeof(num));
	}
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 820
저장시간: 2022-03-16 16:18:12 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일(2주 2일)
// 
// 할 일 -
//-----------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include "save.h"

//using namespace std;

// [문제] int 1000개를 저장하려면 메모리 몇 바이트가 필요합니까?
//		-> 상황에 따라 다름
//		-> 그렇지만 int 메모리 자체 비트를 그래도 기록하고 일거 온다면
//		-> 어떤 상황에서도 4000바이트면 문제가 없다

// [문제] int 1000개를 "int 1000개.txt" 파일에 메모리 그대로 기록하라.
//----
int main()
//----
{
	std::ofstream out{ "int 1000개.txt", std::ios::binary };
	int num;
	for (int i = 0; i < 1000; ++i)
	{
		num = i + 1;
		out.write((const char*)&num, sizeof(num));
	}
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 915
저장시간: 2022-03-16 16:33:47 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일(2주 2일)
// 
// 할 일 -
//-----------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <fstream>
#include "save.h"

//using namespace std;

// [문제] int 1000개를 저장하려면 메모리 몇 바이트가 필요합니까?
//		-> 상황에 따라 다름
//		-> 그렇지만 int 메모리 자체 비트를 그래도 기록하고 일거 온다면
//		-> 어떤 상황에서도 4000바이트면 문제가 없다

// [문제] int 1000개를 "int 1000개.txt" 파일에 메모리 그대로 기록하라.
//----

std::default_random_engine dre;
std::uniform_int_distribution uid;

int main()
//----
{
	std::ofstream out{ "int 1000개.txt", std::ios::binary };
	int num;
	for (int i = 0; i < 1000; ++i)
	{
		num = uid(dre);
		out.write((const char*)&num, sizeof(num));
	}
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 819
저장시간: 2022-03-16 16:40:45 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 3일 목요일(2주 2일)
// 
// 할 일 -
//-----------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include "save.h"

//using namespace std;

// [문제] 랜덤 값을 갖는 int 1000를
// "int 1000개.txt" 파일에 binary 모드와 write 함수를 사용하여 기록하였다.
// 읽어서 가장 큰 값을 찾아 화면에 출력하라
//----

int main()
//----
{
	std::ifstream in{ "int 1000개.txt", std::ios::binary };
	int maxValue = std::numeric_limits<int>::min();
	int num;
	for (int i = 0; i < 1000; ++i)
	{
		in.read((char*)&num, sizeof(num));
		if (maxValue < num)
			maxValue = num;
	}
	std::cout << "최대 값: " << maxValue << std::endl;
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 775
저장시간: 2022-03-16 16:59:19 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(2주 2일)
// 
// 책/구글 꼭 찾아보기
//-----------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <fstream>
#include "save.h"

//using namespace std;

// [문제] 랜덤 값을 갖는 int 1000를
// "int 1000개.txt" 파일에 binary 모드와 write 함수를 사용하여 기록하였다.
// 읽어서 가장 큰 값을 찾아 화면에 출력하라
//----

int main()
//----
{
	std::ifstream in{ "int 1000개.txt", std::ios::binary };
	int num[1000];
	in.read((char*)&num, 1000 * sizeof(int));
	
	std::cout << "최댓값: " << *std::max_element(std::begin(num), std::end(num)) << std::endl;
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 937
저장시간: 2022-03-16 17:05:53 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(2주 2일)
// 
// 책/구글 꼭 찾아보기
//-----------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <fstream>
#include <format>	// c++20 최신이어야 돌아감
#include "save.h"

//using namespace std;

// [문제] 랜덤 값을 갖는 int 1000를
// "int 1000개.txt" 파일에 binary 모드와 write 함수를 사용하여 기록하였다.
// 읽어서 가장 큰 값을 찾아 화면에 출력하라
//----

int main()
//----
{
	std::ifstream in{ "int 1000개.txt", std::ios::binary };
	int num[1000];
	in.read((char*)&num, 1000 * sizeof(int));
	
	// 읽은 값 출력 연습
	for (int num : num)
		std::cout << std::format("{:80}", num);
	std::cout << std::endl;

	std::cout << "최댓값: " << *std::max_element(std::begin(num), std::end(num)) << std::endl;
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 938
저장시간: 2022-03-16 17:05:59 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(2주 2일)
// 
// 책/구글 꼭 찾아보기
//-----------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <fstream>
#include <format>	// c++20 최신이어야 돌아감
#include "save.h"

//using namespace std;

// [문제] 랜덤 값을 갖는 int 1000를
// "int 1000개.txt" 파일에 binary 모드와 write 함수를 사용하여 기록하였다.
// 읽어서 가장 큰 값을 찾아 화면에 출력하라
//----

int main()
//----
{
	std::ifstream in{ "int 1000개.txt", std::ios::binary };
	int num[1000];
	in.read((char*)&num, 1000 * sizeof(int));
	
	// 읽은 값 출력 연습
	for (int num : num)
		std::cout << std::format("{:^80}", num);
	std::cout << std::endl;

	std::cout << "최댓값: " << *std::max_element(std::begin(num), std::end(num)) << std::endl;
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 938
저장시간: 2022-03-16 17:06:17 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(2주 2일)
// 
// 책/구글 꼭 찾아보기
//-----------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <fstream>
#include <format>	// c++20 최신이어야 돌아감
#include "save.h"

//using namespace std;

// [문제] 랜덤 값을 갖는 int 1000를
// "int 1000개.txt" 파일에 binary 모드와 write 함수를 사용하여 기록하였다.
// 읽어서 가장 큰 값을 찾아 화면에 출력하라
//----

int main()
//----
{
	std::ifstream in{ "int 1000개.txt", std::ios::binary };
	int num[1000];
	in.read((char*)&num, 1000 * sizeof(int));
	
	// 읽은 값 출력 연습
	for (int num : num)
		std::cout << std::format("{:<80}", num);
	std::cout << std::endl;

	std::cout << "최댓값: " << *std::max_element(std::begin(num), std::end(num)) << std::endl;
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 937
저장시간: 2022-03-16 17:06:37 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(2주 2일)
// 
// 책/구글 꼭 찾아보기
//-----------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <fstream>
#include <format>	// c++20 최신이어야 돌아감
#include "save.h"

//using namespace std;

// [문제] 랜덤 값을 갖는 int 1000를
// "int 1000개.txt" 파일에 binary 모드와 write 함수를 사용하여 기록하였다.
// 읽어서 가장 큰 값을 찾아 화면에 출력하라
//----

int main()
//----
{
	std::ifstream in{ "int 1000개.txt", std::ios::binary };
	int num[1000];
	in.read((char*)&num, 1000 * sizeof(int));
	
	// 읽은 값 출력 연습
	for (int num : num)
		std::cout << std::format("{:20}", num);
	std::cout << std::endl;

	std::cout << "최댓값: " << *std::max_element(std::begin(num), std::end(num)) << std::endl;
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 815
저장시간: 2022-03-16 17:11:44 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(2주 2일)
// 
// 책/구글 꼭 찾아보기
//-----------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <array>
#include <fstream>
#include "save.h"

//using namespace std;

// [문제] 랜덤 값을 갖는 int 1000를
// "int 1000개.txt" 파일에 binary 모드와 write 함수를 사용하여 기록하였다.
// 읽어서 가장 큰 값을 찾아 화면에 출력하라
//----

int main()
//----
{
	std::ifstream in{ "int 1000개.txt", std::ios::binary };
	std::array<int, 1000> num;
	
	in.read((char*)num.data(), 1'000 * sizeof(int));
	
	std::cout << "최댓값: " << *std::max_element(std::begin(num), std::end(num)) << std::endl;
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 410
저장시간: 2022-03-17 11:34:51 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(3주 1일)
// 
//-----------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <memory>
#include "save.h"

//using namespace std;

//----
int main()
//----
{
	std::unique_ptr<int> p{ new int };
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 561
저장시간: 2022-03-17 11:38:19 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(3주 1일)
// 
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"

//using namespace std;

//----
int main()
//----
{
	int num;
	std::cout << "int 몇개를 원하십니까? ";
	std::cin >> num;

	std::unique_ptr<int[]> p{ new int[num] };
	long long sum{};
	for (int i = 0; i < num; ++i)
		sum += p[i];

	std::cout<< "결과: "<<sum<<std::endl;
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 610
저장시간: 2022-03-17 11:39:28 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(3주 1일)
// 
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"

//using namespace std;

//----
int main()
//----
{
	int num;
	std::cout << "int 몇개를 원하십니까? ";
	std::cin >> num;

	std::unique_ptr<int[]> p{ new int[num] };
	for (int i = 0; i < num; ++i)
		p[i] = i + 1;
	long long sum{};
	for (int i = 0; i < num; ++i)
		sum += p[i];

	std::cout<< "결과: "<<sum<<std::endl;
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 788
저장시간: 2022-03-17 11:46:59 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(3주 1일)
// 
// 지난 시간 배운 것 - 앞으로 int[100] 대신에 -> array<int, 100> 사용하자
// 오늘 알아본 것 - 앞으로 int* 대신에 -> unique_ptr<int> 사용하자
//						int*가 new int[100] 대신에 -> unique_ptr<int[]> 사용하자
//-----------------------------------------------------------------------------
#include <iostream>
#include <memory>
#include "save.h"

//using namespace std;

// 메모리 관찰용 초미니 Dog를 만든다

struct Dog {
	Dog() { std::cout << "Dog 생성자 호출" << std::endl; }
	~Dog() { std::cout << "Dog 소멸자 호출" << std::endl; }
};

//----
int main()
//----
{
	for (int i = 0; i < 3; ++i){
		new Dog;
	}

	save("소스.cpp");

}


파일이름: 소스.cpp
파일크기: 810
저장시간: 2022-03-17 11:47:42 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(3주 1일)
// 
// 지난 시간 배운 것 - 앞으로 int[100] 대신에 -> array<int, 100> 사용하자
// 오늘 알아본 것 - 앞으로 int* 대신에 -> unique_ptr<int> 사용하자
//						int*가 new int[100] 대신에 -> unique_ptr<int[]> 사용하자
//-----------------------------------------------------------------------------
#include <iostream>
#include <memory>
#include "save.h"

//using namespace std;

// 메모리 관찰용 초미니 Dog를 만든다

struct Dog {
	Dog() { std::cout << "Dog 생성자 호출" << std::endl; }
	~Dog() { std::cout << "Dog 소멸자 호출" << std::endl; }
};

//----
int main()
//----
{
	for (int i = 0; i < 3; ++i){
		Dog* p = new Dog;
		delete p;
	}

	save("소스.cpp");

}


파일이름: 소스.cpp
파일크기: 776
저장시간: 2022-03-17 11:48:55 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(3주 1일)
// 
// 지난 시간 배운 것 - 앞으로 int[100] 대신에 -> array<int, 100> 사용하자
// 오늘 알아본 것 - 앞으로 int* 대신에 -> unique_ptr<int> 사용하자
//						int*가 new int[100] 대신에 -> unique_ptr<int[]> 사용하자
//-----------------------------------------------------------------------------
#include <iostream>
#include <memory>
#include "save.h"

//using namespace std;

// 메모리 관찰용 초미니 Dog를 만든다

struct Dog {
	Dog() { std::cout << "Dog 생성자 호출" << std::endl; }
	~Dog() { std::cout << "Dog 소멸자 호출" << std::endl; }
};

//----
int main()
//----
{
	Dog* p = new Dog[3];
	delete[] p;
	save("소스.cpp");

}


파일이름: 소스.cpp
파일크기: 859
저장시간: 2022-03-17 11:52:13 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(3주 1일)
// 
// 지난 시간 배운 것 - 앞으로 int[100] 대신에 -> array<int, 100> 사용하자
// 오늘 알아본 것 - 앞으로 int* 대신에 -> unique_ptr<int> 사용하자
//						int*가 new int[100] 대신에 -> unique_ptr<int[]> 사용하자
//-----------------------------------------------------------------------------
#include <iostream>
#include <memory>
#include "save.h"

//using namespace std;

// 메모리 관찰용 초미니 Dog를 만든다

struct Dog {
	Dog() { std::cout << "Dog 생성자 호출" << std::endl; }
	~Dog() { std::cout << "Dog 소멸자 호출" << std::endl; }
};

void f() 
{
	throw 1;
}

//----
int main()
//----
{
	save("소스.cpp");


	Dog* p = new Dog[3];
	// 여기서 비정상 종료
	f();	// 예외를 던진다.

	delete[] p;
}


파일이름: 소스.cpp
파일크기: 965
저장시간: 2022-03-17 11:54:01 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(3주 1일)
// 
// 지난 시간 배운 것 - 앞으로 int[100] 대신에 -> array<int, 100> 사용하자
// 오늘 알아본 것 - 앞으로 int* 대신에 -> unique_ptr<int> 사용하자
//						int*가 new int[100] 대신에 -> unique_ptr<int[]> 사용하자
//-----------------------------------------------------------------------------
#include <iostream>
#include <memory>
#include "save.h"

//using namespace std;

// 메모리 관찰용 초미니 Dog를 만든다

struct Dog {
	Dog() { std::cout << "Dog 생성자 호출" << std::endl; }
	~Dog() { std::cout << "Dog 소멸자 호출" << std::endl; }
};

void f() 
{
	throw 1;
}

//----
int main()
//----
{
	save("소스.cpp");


	Dog* p = new Dog[3];
	// 여기서 비정상 종료
	try {
		f();	// 예외를 던진다.
	}
	catch (...) {	// ... elipses
		std::cout << "예외를 잡았다." << std::endl;
		return 0;
	}
	delete[] p;
}


파일이름: 소스.cpp
파일크기: 980
저장시간: 2022-03-17 11:55:15 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(3주 1일)
// 
// 지난 시간 배운 것 - 앞으로 int[100] 대신에 -> array<int, 100> 사용하자
// 오늘 알아본 것 - 앞으로 int* 대신에 -> unique_ptr<int> 사용하자
//						int*가 new int[100] 대신에 -> unique_ptr<int[]> 사용하자
//-----------------------------------------------------------------------------
#include <iostream>
#include <memory>
#include "save.h"

//using namespace std;

// 메모리 관찰용 초미니 Dog를 만든다

struct Dog {
	Dog() { std::cout << "Dog 생성자 호출" << std::endl; }
	~Dog() { std::cout << "Dog 소멸자 호출" << std::endl; }
};

void f() 
{
	throw 1;
}

//----
int main()
//----
{
	save("소스.cpp");


	Dog* p = new Dog[3];
	// 여기서 비정상 종료
	try {
		f();	// 예외를 던진다.
	}
	catch (...) {	// ... elipses
		std::cout << "예외를 잡았다." << std::endl;
		delete[] p;
		return 0;
	}
	delete[] p;
}


파일이름: 소스.cpp
파일크기: 970
저장시간: 2022-03-17 11:56:42 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(3주 1일)
// 
// 지난 시간 배운 것 - 앞으로 int[100] 대신에 -> array<int, 100> 사용하자
// 오늘 알아본 것 - 앞으로 int* 대신에 -> unique_ptr<int> 사용하자
//						int*가 new int[100] 대신에 -> unique_ptr<int[]> 사용하자
//-----------------------------------------------------------------------------
#include <iostream>
#include <memory>
#include "save.h"

//using namespace std;

// 메모리 관찰용 초미니 Dog를 만든다

struct Dog {
	Dog() { std::cout << "Dog 생성자 호출" << std::endl; }
	~Dog() { std::cout << "Dog 소멸자 호출" << std::endl; }
};

void f() 
{
	throw 1;
}

//----
int main()
//----
{
	save("소스.cpp");


	std::unique_ptr<Dog[]> p{ new Dog[3] };
	// 여기서 비정상 종료
	try {
		f();	// 예외를 던진다.
	}
	catch (...) {	// ... elipses
		std::cout << "예외를 잡았다." << std::endl;
		return 0;
	}
}


파일이름: 소스.cpp
파일크기: 961
저장시간: 2022-03-17 11:57:56 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(3주 1일)
// 
// 지난 시간 배운 것 - 앞으로 int[100] 대신에 -> array<int, 100> 사용하자
// 오늘 알아본 것 - 앞으로 int* 대신에 -> unique_ptr<int> 사용하자
//						int*가 new int[100] 대신에 -> unique_ptr<int[]> 사용하자
//-----------------------------------------------------------------------------
#include <iostream>
#include <memory>
#include "save.h"

//using namespace std;

// 메모리 관찰용 초미니 Dog를 만든다

struct Dog {
	Dog() { std::cout << "Dog 생성자 호출" << std::endl; }
	~Dog() { std::cout << "Dog 소멸자 호출" << std::endl; }
};

void f() 
{

}

//----
int main()
//----
{
	save("소스.cpp");


	std::unique_ptr<Dog[]> p{ new Dog[3] };
	// 여기서 비정상 종료
	try {
		f();	// 예외를 던진다.
	}
	catch (...) {	// ... elipses
		std::cout << "예외를 잡았다." << std::endl;
		return 0;
	}
}


파일이름: 소스.cpp
파일크기: 985
저장시간: 2022-03-23 15:36:47 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(3주 2일)
// 
// int[100] 대신에 -> array<int, 100> 사용하자
// int* 대신에 -> unique_ptr<int> 사용하자
// int*가 new int[100] 대신에 -> unique_ptr<int[]> 사용하자
// 
// 호출가능(Callable) 타입 - 예제는 sort를 사용
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
// STRING
//-----------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <fstream>
#include "save.h"

//using namespace std;
//[문제] 이 "소스.cpp"파일의 
// 소문자를 전부 대문자로 바꿔
//"소스 대문자.cpp"로 저장하라
 
//----
int main()
//----
{
	save("소스.cpp");
	std::ifstream in("소스.cpp");
	std::ofstream out("소스 대문자.cpp");

	std::vector<char> v{ std::istreambuf_iterator<char>{in}, {} };
	for (auto c: v) {
		out << (char)(c >= 'a' && c <= 'z' ? toupper(c) : c);
	}
}


파일이름: 소스.cpp
파일크기: 844
저장시간: 2022-03-23 15:44:46 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(3주 2일)
// 
// int[100] 대신에 -> array<int, 100> 사용하자
// int* 대신에 -> unique_ptr<int> 사용하자
// int*가 new int[100] 대신에 -> unique_ptr<int[]> 사용하자
// 
// 호출가능(Callable) 타입 - 예제는 sort를 사용
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
// STRING
//-----------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include "save.h"

//using namespace std;
//[문제] 이 "소스.cpp"파일의 
// 소문자를 전부 대문자로 바꿔
//"소스 대문자.cpp"로 저장하라
 
//----
int main()
//----
{
	save("소스.cpp");
	std::ifstream in{ "소스.cpp" };
	
	char ch;
	
	while (in >> ch) {
		std::cout << ch;
	}

}


파일이름: 소스.cpp
파일크기: 959
저장시간: 2022-03-23 15:48:38 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(3주 2일)
// 
// int[100] 대신에 -> array<int, 100> 사용하자
// int* 대신에 -> unique_ptr<int> 사용하자
// int*가 new int[100] 대신에 -> unique_ptr<int[]> 사용하자
// 
// 호출가능(Callable) 타입 - 예제는 sort를 사용
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
// STRING
//-----------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <vector>
#include "save.h"

//using namespace std;
//[문제] 이 "소스.cpp"파일의 
// 소문자를 전부 대문자로 바꿔
//"소스 대문자.cpp"로 저장하라
 
//----
int main()
//----
{
	save("소스.cpp");
	std::ifstream in("소스.cpp");
	std::ofstream out("소스 대문자.cpp");

	std::vector<char> v{ std::istreambuf_iterator<char>{in}, {} };
	for (char c : v) {
		out << (char)toupper(c);
	}

}


파일이름: 소스.cpp
파일크기: 883
저장시간: 2022-03-23 15:51:45 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(3주 2일)
// 
// int[100] 대신에 -> array<int, 100> 사용하자
// int* 대신에 -> unique_ptr<int> 사용하자
// int*가 new int[100] 대신에 -> unique_ptr<int[]> 사용하자
// 
// 호출가능(Callable) 타입 - 예제는 sort를 사용
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
// STRING
//-----------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <vector>
#include "save.h"

//using namespace std;
//[문제] 이 "소스.cpp"파일의 
// 소문자를 전부 대문자로 바꿔
//"소스 대문자.cpp"로 저장하라
 
//----
int main()
//----
{
	save("소스.cpp");
	std::ifstream in{ "소스.cpp" };
	char ch;
	in >> std::noskipws;
	while (in >> ch) {
		std::cout << ch;
	}
	

}


파일이름: 소스.cpp
파일크기: 925
저장시간: 2022-03-23 15:53:24 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(3주 2일)
// 
// int[100] 대신에 -> array<int, 100> 사용하자
// int* 대신에 -> unique_ptr<int> 사용하자
// int*가 new int[100] 대신에 -> unique_ptr<int[]> 사용하자
// 
// 호출가능(Callable) 타입 - 예제는 sort를 사용
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
// STRING
//-----------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <vector>
#include "save.h"

//using namespace std;
//[문제] 이 "소스.cpp"파일의 
// 소문자를 전부 대문자로 바꿔
//"소스 대문자.cpp"로 저장하라
 
//----
int main()
//----
{
	save("소스.cpp");
	std::ifstream in{ "소스.cpp" };
	char ch;
	in >> std::noskipws;
	while (in >> ch) {
		if (islower(ch))
			ch = toupper(ch);
		std::cout << ch;
	}
	

}


파일이름: 소스.cpp
파일크기: 961
저장시간: 2022-03-23 15:54:29 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(3주 2일)
// 
// int[100] 대신에 -> array<int, 100> 사용하자
// int* 대신에 -> unique_ptr<int> 사용하자
// int*가 new int[100] 대신에 -> unique_ptr<int[]> 사용하자
// 
// 호출가능(Callable) 타입 - 예제는 sort를 사용
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
// STRING
//-----------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <vector>
#include "save.h"

//using namespace std;
//[문제] 이 "소스.cpp"파일의 
// 소문자를 전부 대문자로 바꿔
//"소스 대문자.cpp"로 저장하라
 
//----
int main()
//----
{
	save("소스.cpp");
	std::ifstream in{ "소스.cpp" };
	std::ofstream out{ "소스 대문자.cpp" };
	char ch;
	in >> std::noskipws;
	while (in >> ch) {
		if (islower(ch))
			ch = toupper(ch);
		out << ch;
	}
	

}


파일이름: 소스.cpp
파일크기: 1074
저장시간: 2022-03-23 16:10:42 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(3주 2일)
// 
// int[100] 대신에 -> array<int, 100> 사용하자
// int* 대신에 -> unique_ptr<int> 사용하자
// int*가 new int[100] 대신에 -> unique_ptr<int[]> 사용하자
// 
// 호출가능(Callable) 타입 - 예제는 sort를 사용
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
// STRING
//-----------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <fstream>
#include "save.h"

//using namespace std;
//[문제] 이 "소스.cpp"파일의 
// 숫자를 *로 바꿔 저장하라
//"소스 별.cpp"로 저장하라
 
//----
int main()
//----
{
	save("소스.cpp");
	std::ifstream in{ "소스.cpp" };
	std::ofstream out{ "소스 대문자.cpp" };
	char ch;
	// transform(어디부터, 어디까지를, 저기에 저장, 이렇게 바꿔서)
	std::transform(std::istreambuf_iterator<char>{in}, {}, std::ostream_iterator<char>{std::cout}, [](char c) {
		if (isdigit(c))
			c = '*';
		return c;
	});
}


파일이름: 소스.cpp
파일크기: 1091
저장시간: 2022-03-23 16:34:50 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(3주 2일)
// 
// int[100] 대신에 -> array<int, 100> 사용하자
// int* 대신에 -> unique_ptr<int> 사용하자
// int*가 new int[100] 대신에 -> unique_ptr<int[]> 사용하자
// 
// 호출가능(Callable) 타입 - 예제는 sort를 사용
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
// STRING
//-----------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <array>
#include <random>
#include "save.h"

//using namespace std;
//[문제] 랜덤값을 갖는 int 100개를 생성하라.
// 오름차순으로 정렬하라
// 화면에 정렬된 int 100개를 출력하라.
//
 
std::random_device rd;
std::default_random_engine dre{ rd() };
//----
int main()
//----
{
	save("소스.cpp");

	std::uniform_int_distribution uid;
	std::array<int, 100> arr;
	for (int& n : arr)
	{
		n = uid(dre);
	}

	std::sort(arr.begin(), arr.end());

	for (const int n : arr)
	{
		std::cout << n << std::endl;
	}
}


파일이름: 소스.cpp
파일크기: 1302
저장시간: 2022-03-23 16:41:36 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(3주 2일)
// 
// int[100] 대신에 -> array<int, 100> 사용하자
// int* 대신에 -> unique_ptr<int> 사용하자
// int*가 new int[100] 대신에 -> unique_ptr<int[]> 사용하자
// 
// 호출가능(Callable) 타입 - 예제는 sort를 사용
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
// STRING
//-----------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <format>
#include <array>
#include <random>
#include "save.h"

//using namespace std;
//[문제] 랜덤값을 갖는 int 100개를 생성하라.
// 오름차순으로 정렬하라
// 화면에 정렬된 int 100개를 출력하라.
//
 
std::random_device rd;
std::default_random_engine dre{ rd() };
//----
int main()
//----
{
	save("소스.cpp");

	std::uniform_int_distribution uid;
	std::array<int, 100> arr;
	for (int& n : arr)
		n = uid(dre);

	std::cout << "----정렬하기 전----" << std::endl;

	for (const int n : arr)
		std::cout << std::format("{:20}", n);

	std::sort(arr.begin(), arr.end());
	std::cout << std::endl;
	std::cout << "----정렬한 후-----" << std::endl;
	
	for (const int n : arr)
		std::cout << std::format("{:20}", n);
}


파일이름: 소스.cpp
파일크기: 1319
저장시간: 2022-03-23 16:43:53 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(3주 2일)
// 
// int[100] 대신에 -> array<int, 100> 사용하자
// int* 대신에 -> unique_ptr<int> 사용하자
// int*가 new int[100] 대신에 -> unique_ptr<int[]> 사용하자
// 
// 호출가능(Callable) 타입 - 예제는 sort를 사용
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
// STRING
//-----------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <format>
#include <array>
#include <random>
#include "save.h"

//using namespace std;
//[문제] [1, 100] 랜덤값을 갖는 int 100개를 생성하라.
// 오름차순으로 정렬하라
// 화면에 정렬된 int 100개를 출력하라.
//
 
std::random_device rd;
std::default_random_engine dre{ rd() };
//----
int main()
//----
{
	save("소스.cpp");

	std::uniform_int_distribution uid{ 0, 100 };
	std::array<int, 100> arr;
	for (int& n : arr)
		n = uid(dre);

	std::cout << "----정렬하기 전----" << std::endl;

	for (const int n : arr)
		std::cout << std::format("{:4}", n);

	std::sort(arr.begin(), arr.end());
	std::cout << std::endl;
	std::cout << "----정렬한 후-----" << std::endl;
	
	for (const int n : arr)
		std::cout << std::format("{:4}", n);
}


파일이름: 소스.cpp
파일크기: 1360
저장시간: 2022-03-23 16:57:27 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(3주 2일)
// 
// int[100] 대신에 -> array<int, 100> 사용하자
// int* 대신에 -> unique_ptr<int> 사용하자
// int*가 new int[100] 대신에 -> unique_ptr<int[]> 사용하자
// 
// 호출가능(Callable) 타입 - 예제는 sort를 사용
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
// STRING
//-----------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <format>
#include <array>
#include <random>
#include "save.h"

//using namespace std;
//[문제] [1, 100] 랜덤값을 갖는 int 100개를 생성하라.
// 내림차순으로 정렬하라
// 화면에 정렬된 int 100개를 출력하라.
//
 
std::random_device rd;
std::default_random_engine dre{ rd() };
//----
int main()
//----
{
	save("소스.cpp");

	std::uniform_int_distribution uid{ 0, 100 };
	std::array<int, 100> arr;
	for (int& n : arr)
		n = uid(dre);

	std::cout << "----정렬하기 전----" << std::endl;

	for (const int n : arr)
		std::cout << std::format("{:4}", n);

	std::sort(arr.begin(), arr.end(), [](int p, int q) {
		return p > q;
	});
	std::cout << std::endl;
	std::cout << "----정렬한 후-----" << std::endl;
	
	for (const int n : arr)
		std::cout << std::format("{:4}", n);
}


파일이름: 소스.cpp
파일크기: 794
저장시간: 2022-03-23 17:08:03 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(3주 2일)
// 
// int[100] 대신에 -> array<int, 100> 사용하자
// int* 대신에 -> unique_ptr<int> 사용하자
// int*가 new int[100] 대신에 -> unique_ptr<int[]> 사용하자
// 
// 호출가능(Callable) 타입 - 예제는 sort를 사용
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
// STRING
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"


//using namespace std;
//
//


void f() {
	std::cout << "함수가 호출되었다"<<std::endl;
}

//----
int main()
//----
{
	save("소스.cpp");
	
	(*f)();
	// f의 자료형을 출력하라
	std::cout << typeid(f).name() << std::endl;

}


파일이름: 소스.cpp
파일크기: 920
저장시간: 2022-03-23 17:09:31 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(3주 2일)
// 
// int[100] 대신에 -> array<int, 100> 사용하자
// int* 대신에 -> unique_ptr<int> 사용하자
// int*가 new int[100] 대신에 -> unique_ptr<int[]> 사용하자
// 
// 호출가능(Callable) 타입 - 예제는 sort를 사용
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
// STRING
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"


//using namespace std;
//
//


void f() {
	std::cout << "함수가 호출되었다"<<std::endl;
}

//----
int main()
//----
{
	save("소스.cpp");
	
	(*f)();
	// f의 자료형을 출력하라
	std::cout << typeid(f).name() << std::endl;


	// f의 주소를 출력하라
	std::cout << std::addressof(f) << std::endl;
	std::cout << std::addressof(main) << std::endl;

}


파일이름: 소스.cpp
파일크기: 1226
저장시간: 2022-03-23 17:20:33 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(3주 2일)
// 
// int[100] 대신에 -> array<int, 100> 사용하자
// int* 대신에 -> unique_ptr<int> 사용하자
// int*가 new int[100] 대신에 -> unique_ptr<int[]> 사용하자
// 
// 호출가능(Callable) 타입 - 예제는 sort를 사용
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
// STRING
//-----------------------------------------------------------------------------
#include <iostream>
#include <thread>
#include "save.h"


using namespace std::chrono_literals;
// using namespace std;
//
// 실행시킬때 함수 포인터를 계속 바꿔주면 같은 함수를 호출하면서 다른 기능을 사용할 수 있다.
// 키 입력을 바꾸는 방법이 될 수 있다.
//

void jump() {
	std::cout << "점프" << std::endl;
}

void slide() {
	std::cout << "슬라이드" << std::endl;
}

//----
int main()
//----
{
	save("소스.cpp");
	
	void(*f)(void)= jump;

	// 3초에 한번씩 jump/slide toggle
	int cnt{};
	while (true) {
		f();	// 1초마다 호출
		// 3초가 지나면 바꾼다
		std::this_thread::sleep_for(1s);
		if ((++cnt % 3) == 0) {
			if (f == jump)
				f = slide;
			else
				f = jump;
		}
	}
}


파일이름: 소스.cpp
파일크기: 1303
저장시간: 2022-03-24 10:39:38 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(3주 2일)
// 
// int[100] 대신에 -> array<int, 100> 사용하자
// int* 대신에 -> unique_ptr<int> 사용하자
// int*가 new int[100] 대신에 -> unique_ptr<int[]> 사용하자
// 
// 호출가능(Callable) 타입 - 예제는 sort를 사용
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
// STRING
//-----------------------------------------------------------------------------
#include <iostream>
#include <thread>
#include "save.h"

// using namespace std;
//
// 실행시킬때 함수 포인터를 계속 바꿔주면 같은 함수를 호출하면서 다른 기능을 사용할 수 있다.
// 키 입력을 바꾸는 방법이 될 수 있다.
//

void jump() {
	std::cout << "점프" << std::endl;
}

void slide() {
	std::cout << "슬라이드" << std::endl;
}

//----
int main()
//----
{
	save("소스.cpp");

	// 확인 - 함수의 이름은 함수가 기록되어 있는 CODE 세그먼트의 시작번지이다.
	// 함수들은 유사한 메모리에 기록되어 있음을 알 수 있다.

	std::cout << "main = " << std::addressof(main) << std::endl;
	std::cout << "svae = " << std::addressof(save) << std::endl;
	std::cout << "main = " << std::addressof(jump) << std::endl;
	std::cout << "main = " << std::addressof(slide) << std::endl;

}


파일이름: 소스.cpp
파일크기: 1449
저장시간: 2022-03-24 10:41:07 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(3주 2일)
// 
// int[100] 대신에 -> array<int, 100> 사용하자
// int* 대신에 -> unique_ptr<int> 사용하자
// int*가 new int[100] 대신에 -> unique_ptr<int[]> 사용하자
// 
// 호출가능(Callable) 타입 - 예제는 sort를 사용
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
// STRING
//-----------------------------------------------------------------------------
#include <iostream>
#include <thread>
#include "save.h"

// using namespace std;
//
// 실행시킬때 함수 포인터를 계속 바꿔주면 같은 함수를 호출하면서 다른 기능을 사용할 수 있다.
// 키 입력을 바꾸는 방법이 될 수 있다.
//

void jump() {
	std::cout << "점프" << std::endl;
}

void slide() {
	std::cout << "슬라이드" << std::endl;
}

int g;

//----
int main()
//----
{
	save("소스.cpp");

	// 확인 - 함수의 이름은 함수가 기록되어 있는 CODE 세그먼트의 시작번지이다.
	// 함수들은 유사한 메모리에 기록되어 있음을 알 수 있다.

	std::cout << "main = " << std::addressof(main) << std::endl;
	std::cout << "save = " << std::addressof(save) << std::endl;
	std::cout << "jump = " << std::addressof(jump) << std::endl;
	std::cout << "slide = " << std::addressof(slide) << std::endl;

	int n;
	std::cout << "스택 - " << std::addressof(n) << std::endl;

	std::cout << "데이터 - " << std::addressof(g) << std::endl;

}


파일이름: 소스.cpp
파일크기: 601
저장시간: 2022-03-24 10:51:19 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(4주 1일)
// 
// 호출가능(Callable) 타입 - 예제는 sort를 사용
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"

// using namespace std;


// 호츨가능(Callable) 타입


//----
int main()
//----
{
	std::cout << "메인 호출" << std::endl;
	int(*t)(void) = (int(*)(void))main;
	std::cout << sizeof(t);
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 732
저장시간: 2022-03-24 10:59:03 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(4주 1일)
// 
// 호출가능(Callable) 타입 - 예제는 sort를 사용
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"

// using namespace std;


// 호츨가능(Callable) 타입
// 호출가능한 타입은 어떤 것들이 있나
// 1. 함수 - CODE SEGMENT에 기록된 명령어들의 집합의 시작번지
// 2. 람다 - 이름 없는 함수
//

//----
int main()
//----
{
	// lambda
	[]() {
		std::cout << "안녕? 나는 람다라고 해! 불러줘서 반가워!" << std::endl;
	}();

	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 769
저장시간: 2022-03-24 10:59:55 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(4주 1일)
// 
// 호출가능(Callable) 타입 - 예제는 sort를 사용
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"

// using namespace std;


// 호츨가능(Callable) 타입
// 호출가능한 타입은 어떤 것들이 있나
// 1. 함수 - CODE SEGMENT에 기록된 명령어들의 집합의 시작번지
// 2. 람다 - 이름 없는 함수
//

//----
int main()
//----
{
	// lambda
	std::cout << typeid([]() {
		std::cout << "안녕? 나는 람다라고 해! 불러줘서 반가워!" << std::endl;
	}).name() << std::endl;
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 785
저장시간: 2022-03-24 11:01:41 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(4주 1일)
// 
// 호출가능(Callable) 타입 - 예제는 sort를 사용
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"

// using namespace std;


// 호츨가능(Callable) 타입
// 호출가능한 타입은 어떤 것들이 있나
// 1. 함수 - CODE SEGMENT에 기록된 명령어들의 집합의 시작번지
// 2. 람다 - 이름 없는 함수
//

//----
int main()
//----
{
	// lambda
	auto x = []() {
		std::cout << "안녕? 나는 람다라고 해! 불러줘서 반가워!" << std::endl;
	};

	std::cout << typeid(x).name() << std::endl;
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 855
저장시간: 2022-03-24 11:05:09 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(4주 1일)
// 
// 호출가능(Callable) 타입 - 예제는 sort를 사용
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"

// using namespace std;


// 호츨가능(Callable) 타입
// 호출가능한 타입은 어떤 것들이 있나
// 1. 함수 - CODE SEGMENT에 기록된 명령어들의 집합의 시작번지
// 2. 람다 - 이름 없는 함수
//



//----
int main()
//----
{
	class Dog{};
	std::cout << typeid(Dog).name() << std::endl;

	// lambda
	auto x = []() {
		std::cout << "안녕? 나는 람다라고 해! 불러줘서 반가워!" << std::endl;
	};
	
	std::cout << typeid(x).name() << std::endl;
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 1007
저장시간: 2022-03-24 11:05:40 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(4주 1일)
// 
// 호출가능(Callable) 타입 - 예제는 sort를 사용
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"

// using namespace std;


// 호츨가능(Callable) 타입
// 호출가능한 타입은 어떤 것들이 있나
// 1. 함수 - CODE SEGMENT에 기록된 명령어들의 집합의 시작번지
// 2. 람다 - 이름 없는 함수
//



//----
int main()
//----
{
	class Dog{};
	std::cout << typeid(Dog).name() << std::endl;

	// lambda
	auto x = []() {
		std::cout << "안녕? 나는 람다라고 해! 불러줘서 반가워!" << std::endl;
	};
	
	std::cout << typeid(x).name() << std::endl;
	
	auto x1 = []() {
		std::cout << "안녕? 나는 람다라고 해! 불러줘서 반가워!" << std::endl;
	};

	std::cout << typeid(x1).name() << std::endl;
	
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 1067
저장시간: 2022-03-24 11:06:12 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(4주 1일)
// 
// 호출가능(Callable) 타입 - 예제는 sort를 사용
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"

// using namespace std;


// 호츨가능(Callable) 타입
// 호출가능한 타입은 어떤 것들이 있나
// 1. 함수 - CODE SEGMENT에 기록된 명령어들의 집합의 시작번지
// 2. 람다 - 이름 없는 함수
//

class Cat{};

//----
int main()
//----
{
	std::cout << typeid(Cat).name() << std::endl;
	class Dog{};
	std::cout << typeid(Dog).name() << std::endl;

	// lambda
	auto x = []() {
		std::cout << "안녕? 나는 람다라고 해! 불러줘서 반가워!" << std::endl;
	};
	
	std::cout << typeid(x).name() << std::endl;
	
	auto x1 = []() {
		std::cout << "안녕? 나는 람다라고 해! 불러줘서 반가워!" << std::endl;
	};

	std::cout << typeid(x1).name() << std::endl;
	
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 922
저장시간: 2022-03-24 11:06:54 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(4주 1일)
// 
// 호출가능(Callable) 타입 - 예제는 sort를 사용
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"

// using namespace std;


// 호츨가능(Callable) 타입
// 호출가능한 타입은 어떤 것들이 있나
// 1. 함수 - CODE SEGMENT에 기록된 명령어들의 집합의 시작번지
// 2. 람다 - 이름 없는 함수
//

class Cat{};


auto x = []() {
	std::cout << "안녕? 나는 람다라고 해! 불러줘서 반가워!" << std::endl;
};

//----
int main()
//----
{
	std::cout << typeid(Cat).name() << std::endl;
	class Dog{};
	std::cout << typeid(Dog).name() << std::endl;

	// lambda
	
	
	std::cout << typeid(x).name() << std::endl;
	
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 874
저장시간: 2022-03-24 11:13:31 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(4주 1일)
// 
// 호출가능(Callable) 타입 - 예제는 sort를 사용
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"

// using namespace std;


// 호츨가능(Callable) 타입
// 호출가능한 타입은 어떤 것들이 있나
// 1. 함수 - CODE SEGMENT에 기록된 명령어들의 집합의 시작번지
// 2. 람다 - 이름 없는 함수, 실제는 클래스로 구현한다.
// 3. 클래스 객체 -  
//

// 어떤 클래스가 () 연산자를 오버로딩하였다면 그 객체는 호출 가능하다.
class Dog {
public:
	void operator()() {
		std::cout << "Dog 호출" << std::endl;
	}
};



//----
int main()
//----
{
	Dog dog;

	dog();

	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 1048
저장시간: 2022-03-24 11:16:26 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(4주 1일)
// 
// 호출가능(Callable) 타입 - 예제는 sort를 사용
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
//-----------------------------------------------------------------------------
#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"

// using namespace std;


// 호츨가능(Callable) 타입
// 호출가능한 타입은 어떤 것들이 있나
// 1. 함수 - CODE SEGMENT에 기록된 명령어들의 집합의 시작번지
// 2. 람다 - 이름 없는 함수, 실제는 클래스로 구현한다.
// 3. 클래스 객체 -  
//

// 어떤 클래스가 () 연산자를 오버로딩하였다면 그 객체는 호출 가능하다.
class Dog {
public:
	bool operator()(int a, int b) {
		std::cout << "Dog 호출" << std::endl;
		return a > b;
	}
};



//----
int main()
//----
{
	std::array<int, 5> a{ 1,3,5,2,4 };
	std::sort(a.begin(), a.end(), Dog());

	for (int n : a)
		std::cout << n << std::endl;
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 1090
저장시간: 2022-03-24 11:17:36 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(4주 1일)
// 
// 호출가능(Callable) 타입 - 예제는 sort를 사용
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
//-----------------------------------------------------------------------------
#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"

// using namespace std;


// 호츨가능(Callable) 타입
// 호출가능한 타입은 어떤 것들이 있나
// 1. 함수 - CODE SEGMENT에 기록된 명령어들의 집합의 시작번지
// 2. 람다 - 이름 없는 함수, 실제는 클래스로 구현한다.
// 3. 클래스 객체 -  
//

// 어떤 클래스가 () 연산자를 오버로딩하였다면 그 객체는 호출 가능하다.
class Dog {
public:
	bool operator()(int a, int b) {
		std::cout << "Dog 호출 - " << a << " - " << b << std::endl;
		return a > b;
	}
};



//----
int main()
//----
{
	std::array<int, 5> a{ 1,3,5,2,4 };
	std::sort(a.begin(), a.end(), Dog());

	for (int n : a)
		std::cout << n << ' ';
	std::cout << std::endl;
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 1146
저장시간: 2022-03-24 11:20:04 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(4주 1일)
// 
// 호출가능(Callable) 타입 - 예제는 sort를 사용
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
//-----------------------------------------------------------------------------
#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"

// using namespace std;


// 호츨가능(Callable) 타입
// 호출가능한 타입은 어떤 것들이 있나
// 1. 함수 - CODE SEGMENT에 기록된 명령어들의 집합의 시작번지
// 2. 람다 - 이름 없는 함수, 실제는 클래스로 구현한다.
// 3. 클래스 객체 - function call operator()을 오버로딩한 클래스
// 어떤 클래스가 () 연산자를 오버로딩하였다면 그 객체는 호출 가능하다.
//


class Dog {
public:
	bool operator()(int a, int b) {
		std::cout << "Dog 호출 - " << a << " - " << b << std::endl;
		return a < b;
	}
};



//----
int main()
//----
{
	std::array<int, 5> a{ 1,3,5,2,4 };
	Dog dog;

	std::sort(a.begin(), a.end(), dog);

	for (int n : a)
		std::cout << n << ' ';
	std::cout << std::endl;
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 880
저장시간: 2022-03-24 11:35:22 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(4주 1일)
// 
// 호출가능(Callable) 타입 - 예제는 sort를 사용
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
//-----------------------------------------------------------------------------
#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"

// using namespace std;


// 호츨가능(Callable) 타입 - 무한대
// 호출가능한 타입은 어떤 것들이 있나
// 1. 함수포인터 - CODE SEGMENT에 기록된 명령어들의 집합의 시작번지
// 2. 람다 - 이름 없는 함수, 실제는 클래스로 구현한다.
// 3. operator()을 오버로딩한 클래스
// 4. 멤버함수포인터
//

// - 호출가능 카입의 종류가 무한하기 때문에
// 모든 호출가능타입을 대표하는 클래스를 만들었다 fuction

//----
int main()
//----
{
	
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 618
저장시간: 2022-03-24 11:37:28 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(4주 1일)
// 
// 호출가능(Callable) 타입 - 예제는 sort를 사용
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
//-----------------------------------------------------------------------------
#include <iostream>
#include <functional>
#include "save.h"

// using namespace std;

int add(int a, int b) 
{
	return a + b;
}

//----
int main()
//----
{
	std::function<int(int, int)> f;
	f = add;
	
	std::cout << f(3, 3) << std::endl;
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 1232
저장시간: 2022-03-24 12:03:16 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(4주 1일)
// 
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
//	STRING 
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"

// using namespace std;

// [문제] main()이 문제없이 실행되도록 class STRING을 코딩하라.
// speacial 함수는 동작을 관찰하도록 cout으로 메모리와 동작을 코딩한다.
// 객체 생성시 고유번호를 갖도록 한다.

class STRING {
	size_t num;
	int id;				// 생성 시 부여
	char* data;
	static int cid;		// 객체가 생성될 때 1 증가
public:
	STRING(const char* str) : num{ strlen(str) }, data { new char[num] } {
		memcpy(data, str, num);

		id = ++cid;
		// 관찰메시지를 켜면 출력한다.
		std::cout << "ctor [" << id << "] " << this << std::endl;
	}


	~STRING() {
		// 관찰메시지를 켜면 출력한다.
		std::cout << "dtor [" << id << "] " << this << std::endl;
		delete[] data;
	}
};

int STRING::cid{};

//----
int main()
//----
{
	STRING a{ "2022 1학기" };
	STRING b{ "STL" };
	
	/*std::cout << a << std::endl;
	std::cout << b << std::endl;*/

	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 1433
저장시간: 2022-03-24 12:07:58 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(4주 1일)
// 
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
//	STRING 
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"

// using namespace std;

// [문제] main()이 문제없이 실행되도록 class STRING을 코딩하라.
// speacial 함수는 동작을 관찰하도록 cout으로 메모리와 동작을 코딩한다.
// 객체 생성시 고유번호를 갖도록 한다.

class STRING {
	size_t num;
	int id;				// 생성 시 부여
	char* data;
	static int cid;		// 객체가 생성될 때 1 증가
public:
	STRING(const char* str) : num{ strlen(str) }, data { new char[num] } {
		memcpy(data, str, num);

		id = ++cid;
		// 관찰메시지를 켜면 출력한다.
		std::cout << "ctor [" << id << "] " << this << std::endl;
	}


	~STRING() {
		// 관찰메시지를 켜면 출력한다.
		std::cout << "dtor [" << id << "] " << this << std::endl;
		delete[] data;
	}

	friend std::ostream& operator<<(std::ostream&, const STRING&);
};


int STRING::cid{};
std::ostream& operator<<(std::ostream& os, const STRING& s)
{
	for (int i = 0; i < s.num; ++i)
		os << s.data[i];

	return os;
}

//----
int main()
//----
{
	STRING a{ "2022 1학기" };
	STRING b{ "STL" };
	
	std::cout << a << std::endl;
	std::cout << b << std::endl;

	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 1990
저장시간: 2022-03-30 15:48:41 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(4주 2일)
// 
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
//	STRING 
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"

// using namespace std;

// [문제] main()이 문제없이 실행되도록 class STRING을 코딩하라.
// speacial 함수는 동작을 관찰하도록 cout으로 메모리와 동작을 코딩한다.
// 객체 생성시 고유번호를 갖도록 한다.

bool 관찰{ false };

class STRING {
	int id;				// 생성 시 부여
	size_t num;			// 자원 갯수
	char* p;
	static int cid;		// 객체가 생성될 때 1 증가
public:
	STRING(const char* str) : num{ strlen(str) }, id{ ++cid }{
		p = new char[num];
		memcpy(p, str, num);

		// 관찰메시지를 켜면 출력한다.
		if (관찰)
			print("생성자(*)");
	}


	~STRING() {
		// 관찰메시지를 켜면 출력한다.
		if (관찰)
			print("소멸자");
		delete[] p;
	}

	void print(const char* s){
		std::cout << s << ", [" << id << "] 객체:" << this;
		if (num) {
			std::cout << " 자원수: " << num << " 주소: " << (void*)p;
		}
		else
			std::cout << " 자원 없음";
		std::cout << std::endl;
	}

	friend std::ostream& operator<<(std::ostream&, const STRING&);
	friend STRING operator+(STRING, STRING);
};


int STRING::cid{};
std::ostream& operator<<(std::ostream& os, const STRING& s)
{
	for (int i = 0; i < s.num; ++i)
		os << s.p[i];

	return os;
}

STRING operator+(STRING a, STRING b)
{
	int size = a.num + b.num;
	char* tmp = new char[size];
	memcpy(tmp, a.p, a.num);
	memcpy(&tmp[a.num], b.p, b.num);
	return STRING(tmp);
}


//----
int main()
//----
{
	관찰 = true;

	std::cout << sizeof(STRING) << std::endl;
	STRING a{ "2022 1학기" };
	STRING b{ "STL" };
	// STRING c = a + b;

	std::cout << a << std::endl;
	std::cout << b << std::endl;
	// std::cout << c << std::endl;

	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 2413
저장시간: 2022-03-30 16:25:34 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(4주 2일)
// 
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
//	STRING 
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"

// using namespace std;

// [문제] main()이 문제없이 실행되도록 class STRING을 코딩하라.
// speacial 함수는 동작을 관찰하도록 cout으로 메모리와 동작을 코딩한다.
// 객체 생성시 고유번호를 갖도록 한다.

bool 관찰{ false };

class STRING {
	int id;				// 생성 시 부여
	size_t num;			// 자원 갯수
	char* p;
	static int cid;		// 객체가 생성될 때 1 증가
public:
	STRING() : num{}, p{}, id{ ++cid } {
		if (관찰)
			print("디폴트");
	}

	STRING(const char* str) : num{ strlen(str) }, id{ ++cid }{
		p = new char[num];
		memcpy(p, str, num);

		// 관찰메시지를 켜면 출력한다.
		if (관찰)
			print("생성자(*)");
	}

	STRING(const STRING& other) :num{ other.num }, id{ ++cid } {
		p = new char[num];
		memcpy(p, other.p, num);

		if (관찰)
			print("복사생성");
	}

	~STRING() {
		// 관찰메시지를 켜면 출력한다.
		if (관찰)
			print("소멸자");
		delete[] p;
	}

	STRING operator=(const STRING& other) {
		if (this == &other)
			return *this;
		if (num)
			delete[] p;

		num = other.num;
		p = new char[num];
		memcpy(p, other.p, num);
		if (관찰)
			print("복사할당");
		return *this;
	}

	STRING operator+(const STRING& rhs) const {
		STRING temp;

		temp.num = num + rhs.num;
		temp.p = new char[temp.num];
		memcpy(temp.p, p, num);
		memcpy(temp.p + num, rhs.p, rhs.num);

		return temp;
	}

	void print(const char* s){
		std::cout << s << ", [" << id << "] 객체:" << this;
		if (num) {
			std::cout << " 자원수: " << num << " 주소: " << (void*)p;
		}
		else
			std::cout << " 자원 없음";
		std::cout << std::endl;
	}

	friend std::ostream& operator<<(std::ostream&, const STRING&);
};


int STRING::cid{};

std::ostream& operator<<(std::ostream& os, const STRING& s)
{
	for (int i = 0; i < s.num; ++i)
		os << s.p[i];

	return os;
}

//----
int main()
//----
{
	save("소스.cpp");

	관찰 = true;

	STRING a{ "2022 1학기" };
	STRING b{ " - STL 강의" };
	STRING c{ a + b };

	std::cout << a << std::endl;
	std::cout << b << std::endl;
	std::cout << c << std::endl;

}


파일이름: 소스.cpp
파일크기: 2463
저장시간: 2022-03-30 16:40:53 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(4주 2일)
// 
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
//	STRING 
// RVO(Return value optimization), Copy Ellision
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"

// using namespace std;

// [문제] main()이 문제없이 실행되도록 class STRING을 코딩하라.
// speacial 함수는 동작을 관찰하도록 cout으로 메모리와 동작을 코딩한다.
// 객체 생성시 고유번호를 갖도록 한다.

bool 관찰{ false };

class STRING {
	int id;				// 생성 시 부여
	size_t num;			// 자원 갯수
	char* p;
	static int cid;		// 객체가 생성될 때 1 증가
public:
	STRING() : num{}, p{}, id{ ++cid } {
		if (관찰)
			print("디폴트");
	}

	STRING(const char* str) : num{ strlen(str) }, id{ ++cid }{
		p = new char[num];
		memcpy(p, str, num);

		// 관찰메시지를 켜면 출력한다.
		if (관찰)
			print("생성자(*)");
	}

	STRING(const STRING& other) :num{ other.num }, id{ ++cid } {
		p = new char[num];
		memcpy(p, other.p, num);

		if (관찰)
			print("복사생성");
	}

	~STRING() {
		// 관찰메시지를 켜면 출력한다.
		if (관찰)
			print("소멸자");
		delete[] p;
	}

	STRING operator=(const STRING& other) {
		if (this == &other)
			return *this;
		if (num)
			delete[] p;

		num = other.num;
		p = new char[num];
		memcpy(p, other.p, num);
		if (관찰)
			print("복사할당");
		return *this;
	}

	STRING operator+(const STRING& rhs) const {
		STRING temp;

		temp.num = num + rhs.num;
		temp.p = new char[temp.num];
		memcpy(temp.p, p, num);
		memcpy(temp.p + num, rhs.p, rhs.num);

		return temp;
	}

	void print(const char* s){
		std::cout << s << ", [" << id << "] 객체:" << this;
		if (num) {
			std::cout << " 자원수: " << num << " 주소: " << (void*)p;
		}
		else
			std::cout << " 자원 없음";
		std::cout << std::endl;
	}

	friend std::ostream& operator<<(std::ostream&, const STRING&);
};


int STRING::cid{};

std::ostream& operator<<(std::ostream& os, const STRING& s)
{
	for (int i = 0; i < s.num; ++i)
		os << s.p[i];

	return os;
}

//----
int main()
//----
{
	save("소스.cpp");

	관찰 = true;

	STRING a{ "2022 1학기" };
	STRING b{ " - STL 강의" };
	STRING c{ a + b };

	std::cout << a << std::endl;
	std::cout << b << std::endl;
	std::cout << c << std::endl;

}


파일이름: 소스.cpp
파일크기: 909
저장시간: 2022-03-30 16:56:19 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(4주 2일)
// 
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
//	STRING.h, STRING.cpp로 작성
// RVO(Return value optimization), Copy Ellision
//-----------------------------------------------------------------------------
#include <iostream>
#include "save.h"
#include "STRING.h"

// using namespace std;
extern bool 관찰;

// [문제] main()이 문제없이 실행되도록 class STRING을 코딩하라.
// speacial 함수는 동작을 관찰하도록 cout으로 메모리와 동작을 코딩한다.
// 객체 생성시 고유번호를 갖도록 한다.


//----
int main()
//----
{
	save("소스.cpp");
	관찰 = true;

	STRING a{ "2022 1학기" };
	STRING b{ " - STL 강의" };
	STRING c{ a + b };

	std::cout << a << std::endl;
	std::cout << b << std::endl;
	std::cout << c << std::endl;

}


파일이름: STRING.h
파일크기: 724
저장시간: 2022-03-30 16:56:50 GMT+9

//-----------------------------------------------------------------------------
// STRING.h - 자원을 관리하는 STL 관찰용 클래스
// 
// 2022.3.30							Programmed by HS
//-----------------------------------------------------------------------------

#pragma once
#include <iostream>
class STRING {
	int id;				// 생성 시 부여
	size_t num;			// 자원 갯수
	char* p;			// 자원이 있는 곳
	static int cid;		// 객체가 생성될 때 1 증가
public:
	STRING();
	STRING(const char* str);
	~STRING();

	STRING(const STRING& other);
	STRING& operator=(const STRING& other);

	STRING operator+(const STRING& rhs) const;

	void print(const char* s);

	friend std::ostream& operator<<(std::ostream&, const STRING&);
};

파일이름: STRING.cpp
파일크기: 1739
저장시간: 2022-03-30 16:56:50 GMT+9

//-----------------------------------------------------------------------------
// STRING.cpp - 자원을 관리하는 STL 관찰용 클래스
// 
// 2022.3.30							Programmed by HS
//-----------------------------------------------------------------------------


#pragma once
#include "STRING.h"

bool 관찰{ false };		// 메시지를 보려면 true로 바꿔라


STRING::STRING() : num{}, p{}, id{ ++cid } 
{
	if (관찰)
		print("디폴트");
}

STRING::STRING(const char* str) : num{ strlen(str) }, id{ ++cid }
{
	p = new char[num];
	memcpy(p, str, num);

	// 관찰메시지를 켜면 출력한다.
	if (관찰)
		print("생성자(*)");
}

STRING::STRING(const STRING& other) :num{ other.num }, id{ ++cid } {
	p = new char[num];
	memcpy(p, other.p, num);

	if (관찰)
		print("복사생성");
}

STRING::~STRING() {
	// 관찰메시지를 켜면 출력한다.
	if (관찰)
		print("소멸자");
	delete[] p;
}

STRING& STRING::operator=(const STRING& other) {
	if (this == &other)
		return *this;
	if (num)
		delete[] p;

	num = other.num;
	p = new char[num];
	memcpy(p, other.p, num);
	if (관찰)
		print("복사할당");
	return *this;
}

STRING STRING::operator+(const STRING& rhs) const {
	STRING temp;

	temp.num = num + rhs.num;
	temp.p = new char[temp.num];
	memcpy(temp.p, p, num);
	memcpy(temp.p + num, rhs.p, rhs.num);

	return temp;
}

void STRING::print(const char* s) {
	std::cout << s << ", [" << id << "] 객체:" << this;
	if (num) {
		std::cout << " 자원수: " << num << " 주소: " << (void*)p;
	}
	else
		std::cout << " 자원 없음";
	std::cout << std::endl;
}

int STRING::cid{};

std::ostream& operator<<(std::ostream& os, const STRING& s)
{
	for (int i = 0; i < s.num; ++i)
		os << s.p[i];

	return os;
}

파일이름: 소스.cpp
파일크기: 735
저장시간: 2022-03-30 17:07:27 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(4주 2일)
// 
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
//	STRING.h, STRING.cpp로 작성
// RVO(Return value optimization), Copy Ellision
//-----------------------------------------------------------------------------
#include <iostream>
#include <array>
#include "save.h"
#include "STRING.h"

using namespace std;
extern bool 관찰;

// 컨체이너 => Containers are objects that store other objects


//----
int main()
//----
{
	관찰 = true;
	save("소스.cpp");
	array<STRING, 3> a{ "2022년", "3월", "30일" };
	for (auto& x : a)
		std::cout << x << std::endl;
}	


파일이름: 소스.cpp
파일크기: 734
저장시간: 2022-03-30 17:07:33 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(4주 2일)
// 
// 자원을 관리하는 클래스를 만들어 관찰하면서 - 컨테이너 / 반복자 / 알고리즘
//	STRING.h, STRING.cpp로 작성
// RVO(Return value optimization), Copy Ellision
//-----------------------------------------------------------------------------
#include <iostream>
#include <array>
#include "save.h"
#include "STRING.h"

using namespace std;
extern bool 관찰;

// 컨체이너 => Containers are objects that store other objects


//----
int main()
//----
{
	관찰 = true;
	save("소스.cpp");
	array<STRING, 3> a{ "2022년", "3월", "30일" };
	for (auto x : a)
		std::cout << x << std::endl;
}	


파일이름: 소스.cpp
파일크기: 708
저장시간: 2022-03-31 11:04:31 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(5주 1일)
// 
//	컨테이너
//		Sequence
//			array		-	유일하게 원소갯수 고정
//			vector
//			deque
//			foward_list
//			list
//-----------------------------------------------------------------------------

#include <iostream>
#include <array>
#include "save.h"
#include "STRING.h"

// using namespace std;
//	extern bool 관찰;

//----
int main()
//----
{
	save("소스.cpp");
	std::array<int, 10> a{ 1, 3, 5, 7, 9, 2, 4, 6, 8, 10 };
	
	std::array<int, 10>::iterator p = a.begin();

	std::cout << sizeof(a) << std::endl;		// int[10]과 사용하는 메모리와 같다


}	


파일이름: 소스.cpp
파일크기: 744
저장시간: 2022-03-31 11:08:34 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(5주 1일)
// 
//	컨테이너
//		Sequence
//			array		-	유일하게 원소갯수 고정
//			vector
//			deque
//			foward_list
//			list
//-----------------------------------------------------------------------------

#include <iostream>
#include <array>
#include "save.h"
#include "STRING.h"

// using namespace std;
//	extern bool 관찰;

//----
int main()
//----
{
	save("소스.cpp");
	
	std::array<int, 10> a{ 1, 3, 5, 7, 9, 2, 4, 6, 8, 10 };
	
	// 원소를 반복자를 이용하여 access
	for (std::array<int, 10>::iterator i = a.begin(); i != a.end(); ++i)
		std::cout << *i << " "; 
	std::cout << std::endl;
}	


파일이름: 소스.cpp
파일크기: 719
저장시간: 2022-03-31 11:09:07 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(5주 1일)
// 
//	컨테이너
//		Sequence
//			array		-	유일하게 원소갯수 고정
//			vector
//			deque
//			foward_list
//			list
//-----------------------------------------------------------------------------

#include <iostream>
#include <array>
#include "save.h"
#include "STRING.h"

// using namespace std;
//	extern bool 관찰;

//----
int main()
//----
{
	save("소스.cpp");
	
	std::array<int, 10> a{ 1, 3, 5, 7, 9, 2, 4, 6, 8, 10 };
	
	// 원소를 반복자를 이용하여 access
	for (auto i = a.begin(); i != a.end(); ++i)
		std::cout << *i << " "; 
	std::cout << std::endl;
}	


파일이름: 소스.cpp
파일크기: 755
저장시간: 2022-03-31 11:10:06 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(5주 1일)
// 
//	컨테이너
//		Sequence
//			array		-	유일하게 원소갯수 고정
//			vector
//			deque
//			foward_list
//			list
//-----------------------------------------------------------------------------

#include <iostream>
#include <array>
#include "save.h"
#include "STRING.h"

// using namespace std;
//	extern bool 관찰;

//----
int main()
//----
{
	save("소스.cpp");
	
	std::array<int, 10> a{ 1, 3, 5, 7, 9, 2, 4, 6, 8, 10 };
	
	// 원소를 반복자를 이용하여 access
	// constant begin, constant end
	for (auto i = a.cbegin(); i != a.cend(); ++i)
		std::cout << *i << " "; 
	std::cout << std::endl;
}	


파일이름: 소스.cpp
파일크기: 721
저장시간: 2022-03-31 11:11:07 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(5주 1일)
// 
//	컨테이너
//		Sequence
//			array		-	유일하게 원소갯수 고정
//			vector
//			deque
//			foward_list
//			list
//-----------------------------------------------------------------------------

#include <iostream>
#include <array>
#include "save.h"
#include "STRING.h"

// using namespace std;
//	extern bool 관찰;

//----
int main()
//----
{
	save("소스.cpp");
	
	std::array<int, 10> a{ 1, 3, 5, 7, 9, 2, 4, 6, 8, 10 };
	
	// 원소를 반복자를 이용하여 access
	auto i = a.cbegin();
	while (i != a.cend())
		std::cout << *i++ << " ";
	std::cout << std::endl;
}	


파일이름: 소스.cpp
파일크기: 690
저장시간: 2022-03-31 11:11:56 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(5주 1일)
// 
//	컨테이너
//		Sequence
//			array		-	유일하게 원소갯수 고정
//			vector
//			deque
//			foward_list
//			list
//-----------------------------------------------------------------------------

#include <iostream>
#include <array>
#include "save.h"
#include "STRING.h"

// using namespace std;
//	extern bool 관찰;

//----
int main()
//----
{
	save("소스.cpp");
	
	std::array<int, 10> a{ 1, 3, 5, 7, 9, 2, 4, 6, 8, 10 };
	
	// 원소를 반복자를 이용하여 access
	for (auto x : a)
		std::cout << x << " ";
	std::cout << std::endl;
}	


파일이름: 소스.cpp
파일크기: 725
저장시간: 2022-03-31 11:15:30 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(5주 1일)
// 
//	컨테이너
//		Sequence
//			array		-	유일하게 원소갯수 고정
//			vector
//			deque
//			foward_list
//			list
//-----------------------------------------------------------------------------

#include <iostream>
#include <array>
#include "save.h"
#include "STRING.h"

// using namespace std;
//	extern bool 관찰;

//----
int main()
//----
{
	save("소스.cpp");
	
	std::array<int, 10> a{ 1, 3, 5, 7, 9, 2, 4, 6, 8, 10 };
	
	// [문제] a의 원소를 거꾸로 출력하라.
	for (auto i = a.crbegin(); i != a.crend(); ++i)
		std::cout << *i << " ";
	std::cout << std::endl;
}	


파일이름: 소스.cpp
파일크기: 722
저장시간: 2022-03-31 11:40:12 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(5주 1일)
// 
//	컨테이너
//		Sequence
//			array		-	유일하게 원소갯수 고정
//			vector
//			deque
//			foward_list
//			list
//-----------------------------------------------------------------------------

#include <iostream>
#include <array>
#include "save.h"
#include "STRING.h"

// using namespace std;
//	extern bool 관찰;

//----
int main()
//----
{
	save("소스.cpp");
	std::array<int, 10> a{ 1,2,3,4,5,6,7,8,9,10 };

	while (true)
	{
		std::cout << "몇 번째를 원하시나요? ";
		int num;
		std::cin >> num;
		std::cout << num << " - " << a[num] << std::endl;
	}
	
}	


파일이름: 소스.cpp
파일크기: 725
저장시간: 2022-03-31 11:41:08 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(5주 1일)
// 
//	컨테이너
//		Sequence
//			array		-	유일하게 원소갯수 고정
//			vector
//			deque
//			foward_list
//			list
//-----------------------------------------------------------------------------

#include <iostream>
#include <array>
#include "save.h"
#include "STRING.h"

// using namespace std;
//	extern bool 관찰;

//----
int main()
//----
{
	save("소스.cpp");
	std::array<int, 10> a{ 1,2,3,4,5,6,7,8,9,10 };

	while (true)
	{
		std::cout << "몇 번째를 원하시나요? ";
		int num;
		std::cin >> num;
		std::cout << num << " - " << a.at(num) << std::endl;
	}
	
}	


파일이름: 소스.cpp
파일크기: 818
저장시간: 2022-03-31 11:44:35 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(5주 1일)
// 
//	컨테이너
//		Sequence
//			array		-	유일하게 원소갯수 고정
//			vector
//			deque
//			foward_list
//			list
//-----------------------------------------------------------------------------

#include <iostream>
#include <array>
#include "save.h"
#include "STRING.h"

// using namespace std;
//	extern bool 관찰;

//----
int main()
//----
{
	save("소스.cpp");
	std::array<int, 10> a{ 1,2,3,4,5,6,7,8,9,10 };

	while (true)
	{
		std::cout << "몇 번째를 원하시나요? ";
		int num;
		std::cin >> num;
		try {
			std::cout << num << " - " << a.at(num) << std::endl;
		}
		catch (std::exception& e) {
			std::cout << e.what() << std::endl;

		}
	}
	
}	


파일이름: 소스.cpp
파일크기: 707
저장시간: 2022-03-31 11:47:26 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(5주 1일)
// 
//	컨테이너
//		Sequence
//			array		-	유일하게 원소갯수 고정
//			vector		-	깊게 알아볼 가치가 있는 컨테이너
//			deque
//			foward_list
//			list
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"

// using namespace std;
//	extern bool 관찰;

//----
int main()
//----
{
	save("소스.cpp");

	std::vector<char> v;
	v.push_back('S');
	v.push_back('T');
	v.push_back('L');
	for (char c : v)
		std::cout << c;
	std::cout << std::endl;
	
}	


파일이름: 소스.cpp
파일크기: 870
저장시간: 2022-03-31 11:53:41 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(5주 1일)
// 
//	컨테이너
//		Sequence
//			array		-	유일하게 원소갯수 고정
//			vector		-	깊게 알아볼 가치가 있는 컨테이너
//			deque
//			foward_list
//			list
//-----------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <vector>
#include "save.h"
#include "STRING.h"

// using namespace std;
//	extern bool 관찰;

// [문제] vector<char>에 "소스.cpp"를 공백까지 읽어들인다.
// vector<char>를 화면에 출력하라.

//----
int main()
//----
{
	save("소스.cpp");

	std::ifstream in{ "소스.cpp"};
	char c;
	std::vector<char> v;
	in >> std::noskipws;
	while (in >> c)
		v.push_back(c);

	for (char c : v)
		std::cout << c;
	std::cout << std::endl;
	
}	


파일이름: 소스.cpp
파일크기: 842
저장시간: 2022-03-31 11:56:35 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(5주 1일)
// 
//	컨테이너
//		Sequence
//			array		-	유일하게 원소갯수 고정
//			vector		-	깊게 알아볼 가치가 있는 컨테이너
//			deque
//			foward_list
//			list
//-----------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <vector>
#include "save.h"
#include "STRING.h"

// using namespace std;
//	extern bool 관찰;

// [문제] vector<char>에 "소스.cpp"를 공백까지 읽어들인다.
// vector<char>를 화면에 출력하라.

//----
int main()
//----
{
	save("소스.cpp");

	std::ifstream in{ "소스.cpp"};
	std::vector<char> v{ std::istreambuf_iterator<char>{in}, {} };

	for (char c : v)
		std::cout << c;
	std::cout << std::endl;
	
}	


파일이름: 소스.cpp
파일크기: 964
저장시간: 2022-03-31 12:02:59 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(5주 1일)
// 
//	컨테이너
//		Sequence
//			array		-	유일하게 원소갯수 고정
//			vector		-	깊게 알아볼 가치가 있는 컨테이너
//			deque
//			foward_list
//			list
//-----------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <vector>
#include "save.h"
#include "STRING.h"

// using namespace std;
//	extern bool 관찰;

// [문제] vector<char>에 "소스.cpp"를 공백까지 읽어들인다.
// vector<char>를 화면에 출력하라.

//----
int main()
//----
{
	save("소스.cpp");

	std::ifstream in{ "소스.cpp"};
	std::vector<char> v{ std::istreambuf_iterator{in}, {} };

	// [문제] 뒤에서 부터 출력하라
	for(auto i : v)
		std::cout << i;
	std::cout << std::endl;

	for (auto i = v.rbegin(); i != v.rend(); ++i)
		std::cout << *i;
	std::cout << std::endl;
	
}	


파일이름: 소스.cpp
파일크기: 846
저장시간: 2022-03-31 12:09:35 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(5주 1일)
// 
//	컨테이너
//		Sequence
//			array		-	유일하게 원소갯수 고정
//			vector		-	깊게 알아볼 가치가 있는 컨테이너
//			deque
//			foward_list
//			list
//-----------------------------------------------------------------------------

#include <iostream>
#include <string>
#include <vector>
#include "save.h"
#include "STRING.h"

// using namespace std;
//	extern bool 관찰;

// [문제] 키보드에서 입력하는 단어를 모두 읽어라.
// 입력이 끝나면 오름차순 정렬한 후 화면에 출력하라;

//----
int main()
//----
{
	save("소스.cpp");
	std::vector<std::string> v;
	
	std::string s;
	while (std::cin >> s) {
		v.push_back(s);
	}

	for (auto x : v)
		std::cout << x;
	std::cout << std::endl;
}	



파일이름: 소스.cpp
파일크기: 971
저장시간: 2022-03-31 12:14:01 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(5주 1일)
// 
//	컨테이너
//		Sequence
//			array		-	유일하게 원소갯수 고정
//			vector		-	깊게 알아볼 가치가 있는 컨테이너
//			deque
//			foward_list
//			list
//-----------------------------------------------------------------------------

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include "save.h"
#include "STRING.h"

// using namespace std;
//	extern bool 관찰;

// [문제] 키보드에서 입력하는 단어를 모두 읽어라.
// 입력이 끝나면 오름차순 정렬한 후 화면에 출력하라;

//----
int main()
//----
{
	save("소스.cpp");
	std::vector<std::string> v;
	
	std::string s;
	while (std::cin >> s) {
		v.push_back(s);
	}

	std::sort(v.begin(), v.end(), [](const std::string a, const std::string b) {return a < b; });
	for (auto x : v)
		std::cout << x << ' ';
	std::cout << std::endl;
}	


파일이름: 소스.cpp
파일크기: 973
저장시간: 2022-03-31 12:16:24 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(5주 1일)
// 
//	컨테이너
//		Sequence
//			array		-	유일하게 원소갯수 고정
//			vector		-	깊게 알아볼 가치가 있는 컨테이너
//			deque
//			foward_list
//			list
//-----------------------------------------------------------------------------

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include "save.h"
#include "STRING.h"

// using namespace std;
//	extern bool 관찰;

// [문제] 키보드에서 입력하는 단어를 모두 읽어라.
// 입력이 끝나면 내림차순 정렬한 후 화면에 출력하라;

//----
int main()
//----
{
	save("소스.cpp");
	std::vector<std::string> v;
	
	std::string s;
	while (std::cin >> s) {
		v.push_back(s);
	}

	std::sort(v.begin(), v.end(), [](const std::string& a, const std::string& b) {return a > b; });
	for (auto x : v)
		std::cout << x << ' ';
	std::cout << std::endl;
}	


파일이름: 소스.cpp
파일크기: 607
저장시간: 2022-03-31 12:21:32 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 3월 16일 수요일(5주 1일)
// 
//	컨테이너
//		Sequence
//			array		-	유일하게 원소갯수 고정
//			vector		-	깊게 알아볼 가치가 있는 컨테이너
//			deque
//			foward_list
//			list
// lexicographical comparison
//-----------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <vector>
#include "save.h"
#include "STRING.h"

// using namespace std;
//	extern bool 관찰;
\
//----
int main()
//----
{
	save("소스.cpp");
}	


파일이름: 소스.cpp
파일크기: 748
저장시간: 2022-04-06 16:05:25 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 4월 6일 수요일(5주 2일)
// 
//	컨테이너
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
//			array		-	유일하게 원소갯수 고정
//			vector		-	깊게 알아볼 가치가 있는 컨테이너
//			deque		-
//			foward_list	-
//			list		-
// lexicographical comparison
// 예정: 주간시험 4.27(수) (8주 2일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"

// using namespace std;
extern bool 관찰;

//----
int main()
//----
{
	관찰 = true;

	std::vector<STRING> v;
	
	STRING s{ "12345" };

	save("소스.cpp");
}	


파일이름: 소스.cpp
파일크기: 750
저장시간: 2022-04-06 16:06:23 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 4월 6일 수요일(5주 2일)
// 
//	컨테이너
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
//			array		-	유일하게 원소갯수 고정
//			vector		-	깊게 알아볼 가치가 있는 컨테이너
//			deque		-
//			foward_list	-
//			list		-
// lexicographical comparison
// 예정: 주간시험 4.27(수) (8주 2일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"

// using namespace std;
extern bool 관찰;


//----
int main()
//----
{
	관찰 = true;

	std::vector<STRING> v;
	
	new STRING("12345");

	save("소스.cpp");
}	


파일이름: 소스.cpp
파일크기: 779
저장시간: 2022-04-06 16:07:14 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 4월 6일 수요일(5주 2일)
// 
//	컨테이너
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
//			array		-	유일하게 원소갯수 고정
//			vector		-	깊게 알아볼 가치가 있는 컨테이너
//			deque		-
//			foward_list	-
//			list		-
// lexicographical comparison
// 예정: 주간시험 4.27(수) (8주 2일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"

// using namespace std;
extern bool 관찰;


//----
int main()
//----
{
	관찰 = true;

	std::vector<STRING> v;
	
	std::unique_ptr<STRING> p{ new STRING("12345") };

	save("소스.cpp");
}	


파일이름: 소스.cpp
파일크기: 1172
저장시간: 2022-04-06 16:23:03 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 4월 6일 수요일(5주 2일)
// 
//	컨테이너
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
//			array		-	유일하게 원소갯수 고정
//			vector		-	깊게 알아볼 가치가 있는 컨테이너
//			deque		-
//			foward_list	-
//			list		-
// lexicographical comparison
// 예정: 주간시험 4.27(수) (8주 2일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"

// using namespace std;
extern bool 관찰;


//----
int main()
//----
{
	// [문제] 키보드에서 int를 입력받아라.
	// 합계와 평균을 화면에 출력하라.

	std::vector<int> v;
	int num;
	while (std::cin >> num)
		v.push_back(num);

	long long sum = 0;\

	// &는 값을 변경하고 싶을때 혹은 복사생성을 하고 싶지 않을 때
	// 복사생성이 자료의 크기가 클때 부담이 될 수 있기 때문에
	// int 4바이트에 쓰는건 과한 일

	for (int num : v)
		sum += num;
	
	std::cout << "합계: " << sum << std::endl;
	std::cout << "평균: " << (double)sum / v.size() << std::endl;
	save("소스.cpp");
}	


파일이름: 소스.cpp
파일크기: 765
저장시간: 2022-04-06 16:24:22 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 4월 6일 수요일(5주 2일)
// 
//	컨테이너
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
//			array		-	유일하게 원소갯수 고정
//			vector		-	깊게 알아볼 가치가 있는 컨테이너
//			deque		-
//			foward_list	-
//			list		-
// lexicographical comparison
// 예정: 주간시험 4.27(수) (8주 2일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"

// using namespace std;
extern bool 관찰;


//----
int main()
//----
{
	save("소스.cpp");
	
	std::vector v0{ 1,2,3 };			// 권장하지 않는 방법
	std::vector<int> v{ 1,2,3 };
}	


파일이름: 소스.cpp
파일크기: 1196
저장시간: 2022-04-06 16:50:36 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 4월 6일 수요일(5주 2일)
// 
//	컨테이너
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
//			array		-	유일하게 원소갯수 고정
//			vector		-	깊게 알아볼 가치가 있는 컨테이너
//			deque		-
//			foward_list	-
//			list		-
// lexicographical comparison
// 예정: 주간시험 4.27(수) (8주 2일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"

// using namespace std;
extern bool 관찰;


//----
int main()
//----
{
	save("소스.cpp");
	
	std::vector<int> v;
	v.reserve(10);
	v.push_back(1);
	v.push_back(2);
	v.push_back(3);


	std::cout << "벡터의 원소 수 - " << v.size() << std::endl;
	std::cout << "원소의 주소 - " << v.data() << std::endl;
	std::cout << "벡터의 용량 - " << v.capacity() << std::endl;

	v.push_back(4);


	std::cout << std::endl;

	std::cout << "벡터의 원소 수 - " << v.size() << std::endl;
	std::cout << "원소의 주소 - " << v.data() << std::endl;
	std::cout << "벡터의 용량 - " << v.capacity() << std::endl;

}	


파일이름: 소스.cpp
파일크기: 1026
저장시간: 2022-04-06 16:53:36 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 4월 6일 수요일(5주 2일)
// 
//	컨테이너
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
//			array		-	유일하게 원소갯수 고정
//			vector		-	깊게 알아볼 가치가 있는 컨테이너
//			deque		-
//			foward_list	-
//			list		-
// lexicographical comparison
// 예정: 주간시험 4.27(수) (8주 2일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"

// using namespace std;
extern bool 관찰;


//----
int main()
//----
{
	// 자동으로 늘려나갈때는 1.5배
	// reserve()를 통해 미리 메모리를 잡아 둘 수 있음
	
	save("소스.cpp");
	
	std::vector<int> v;
	
	while (true)
	{
		v.push_back(3);

		std::cout << "벡터의 원소 수 - " << v.size() << std::endl;
		std::cout << "원소의 주소 - " << v.data() << std::endl;
		std::cout << "벡터의 용량 - " << v.capacity() << std::endl;

	}
}	


파일이름: 소스.cpp
파일크기: 1070
저장시간: 2022-04-06 16:54:29 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 4월 6일 수요일(5주 2일)
// 
//	컨테이너
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
//			array		-	유일하게 원소갯수 고정
//			vector		-	깊게 알아볼 가치가 있는 컨테이너
//			deque		-
//			foward_list	-
//			list		-
// lexicographical comparison
// 예정: 주간시험 4.27(수) (8주 2일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"

// using namespace std;
extern bool 관찰;


//----
int main()
//----
{
	// 자동으로 늘려나갈때는 1.5배
	// reserve()를 통해 미리 메모리를 잡아 둘 수 있음
	
	save("소스.cpp");
	
	std::vector<int> v;
	
	while (true)
	{
		v.push_back(3);

		if (v.size() == v.capacity())
		{
			std::cout << "벡터의 원소 수 - " << v.size() << std::endl;
			std::cout << "원소의 주소 - " << v.data() << std::endl;
			std::cout << "벡터의 용량 - " << v.capacity() << std::endl;
		}
	}
}	


파일이름: 소스.cpp
파일크기: 1175
저장시간: 2022-04-06 16:57:41 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 4월 6일 수요일(5주 2일)
// 
//	컨테이너
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
//			array		-	유일하게 원소갯수 고정
//			vector		-	깊게 알아볼 가치가 있는 컨테이너
//			deque		-
//			foward_list	-
//			list		-
// lexicographical comparison
// 예정: 주간시험 4.27(수) (8주 2일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"

// using namespace std;
extern bool 관찰;


//----
int main()
//----
{
	// 자동으로 늘려나갈때는 1.5배
	// reserve()를 통해 미리 메모리를 잡아 둘 수 있음
	
	save("소스.cpp");
	
	std::vector<int> v;
	
	size_t old_capacity = v.capacity();

	while (true)
	{
		v.push_back(3);

		if (v.size() - 1 == old_capacity)
		{
			std::cout << "벡터의 원소 수 - " << v.size() << std::endl;
			std::cout << "원소의 주소 - " << v.data() << std::endl;
			std::cout << "벡터의 용량 - " << v.capacity() << std::endl;
			old_capacity = v.capacity();
			std::cout << std::endl;
		}
	}
}	


파일이름: 소스.cpp
파일크기: 931
저장시간: 2022-04-06 17:11:25 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 4월 6일 수요일(5주 2일)
// 
//	컨테이너
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
//			array		-	유일하게 원소갯수 고정
//			vector		-	깊게 알아볼 가치가 있는 컨테이너
//			deque		-
//			foward_list	-
//			list		-
// lexicographical comparison
// 예정: 주간시험 4.27(수) (8주 2일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"

// using namespace std;
extern bool 관찰;


//----
int main()
//----
{
	// 스택에 생성되었다가 삭제되고 복사생성으로 힙에 생성?
	// 임시객체를 만들었다가 깊은 복사로 힙에 생성한 뒤 포인터로 가르킴
	// RAII를통해 스택 객체가 삭제됨
	
	save("소스.cpp");
	관찰 = true;
	std::vector<STRING> v{ "1234567"};
	v.push_back("1234567890");


}	


파일이름: 소스.cpp
파일크기: 993
저장시간: 2022-04-07 10:45:35 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 4월 6일 수요일(5주 2일)
// 
//	컨테이너
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
//			array		-	유일하게 원소갯수 고정
//			vector		-	깊게 알아볼 가치가 있는 컨테이너
//			deque		-
//			foward_list	-
//			list		-
// lexicographical comparison
// 예정: 주간시험 4.27(수) (8주 2일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"

// using namespace std;
extern bool 관찰;


//----
int main()
//----
{
	// 스택에 생성되었다가 삭제되고 복사생성으로 힙에 생성?
	// 임시객체를 만들었다가 깊은 복사로 힙에 생성한 뒤 포인터로 가르킴
	// RAII를통해 스택 객체가 삭제됨
	
	save("소스.cpp");
	관찰 = true;
	std::vector<STRING> v;
	v.reserve(10);
	v.emplace_back("1234567");
	v.emplace_back("1234567890");
	std::cout << std::endl;
	
}	


파일이름: 소스.cpp
파일크기: 926
저장시간: 2022-04-07 11:10:50 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 4월 6일 수요일(5주 2일)
// 
//	컨테이너
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
//			array		-	유일하게 원소갯수 고정
//			vector		-	깊게 알아볼 가치가 있는 컨테이너
//			deque		-
//			foward_list	-
//			list		-
// lexicographical comparison
// 예정: 주간시험 4.27(수) (8주 2일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"

// using namespace std;
extern bool 관찰;


//----
int main()
//----
{
	save("소스.cpp");
	관찰 = true;
	std::vector<STRING> v;
	v.reserve(5);
	v.push_back("1");
	//	v.push_back(STRING{ "1" });
	v.push_back("12");
	//	v.push_back(STRING{ "2" });
	v.push_back("123");
	//	v.push_back(STRING{ "3" });
	std::cout << std::endl;

}	


파일이름: 소스.cpp
파일크기: 933
저장시간: 2022-04-07 11:11:45 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 4월 6일 수요일(5주 2일)
// 
//	컨테이너
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
//			array		-	유일하게 원소갯수 고정
//			vector		-	깊게 알아볼 가치가 있는 컨테이너
//			deque		-
//			foward_list	-
//			list		-
// lexicographical comparison
// 예정: 주간시험 4.27(수) (8주 2일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"

// using namespace std;
extern bool 관찰;


//----
int main()
//----
{
	save("소스.cpp");
	관찰 = true;
	std::vector<STRING> v;
	v.reserve(5);
	//	v.push_back("1");
	//	v.push_back("12");
	//	v.push_back("123");

	v.push_back(STRING{ "1" });
	v.push_back(STRING{ "12" });
	v.push_back(STRING{ "123" });

	std::cout << std::endl;

}	


파일이름: 소스.cpp
파일크기: 966
저장시간: 2022-04-07 11:12:18 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 4월 6일 수요일(5주 2일)
// 
//	컨테이너
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
//			array		-	유일하게 원소갯수 고정
//			vector		-	깊게 알아볼 가치가 있는 컨테이너
//			deque		-
//			foward_list	-
//			list		-
// lexicographical comparison
// 예정: 주간시험 4.27(수) (8주 2일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"

// using namespace std;
extern bool 관찰;


//----
int main()
//----
{
	save("소스.cpp");
	관찰 = true;
	std::vector<STRING> v;
	v.reserve(5);
	//	v.push_back("1");
	//	v.push_back("12");
	//	v.push_back("123");

	v.push_back(std::move(STRING{ "1" }));
	v.push_back(std::move(STRING{ "12" }));
	v.push_back(std::move(STRING{ "123" }));

	std::cout << std::endl;

}	


파일이름: 소스.cpp
파일크기: 805
저장시간: 2022-04-07 11:13:18 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 4월 6일 수요일(5주 2일)
// 
//	컨테이너
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
//			array		-	유일하게 원소갯수 고정
//			vector		-	깊게 알아볼 가치가 있는 컨테이너
//			deque		-
//			foward_list	-
//			list		-
// lexicographical comparison
// 예정: 주간시험 4.27(수) (8주 2일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"

// using namespace std;
extern bool 관찰;


//----
int main()
//----
{
	save("소스.cpp");
	관찰 = true;
	std::vector<STRING> v;
	v.reserve(5);
	v.push_back("1");
	v.push_back("12");
	std::cout << std::endl;

}	


파일이름: 소스.cpp
파일크기: 789
저장시간: 2022-04-07 11:14:08 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 4월 6일 수요일(5주 2일)
// 
//	컨테이너
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
//			array		-	유일하게 원소갯수 고정
//			vector		-	깊게 알아볼 가치가 있는 컨테이너
//			deque		-
//			foward_list	-
//			list		-
// lexicographical comparison
// 예정: 주간시험 4.27(수) (8주 2일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"

// using namespace std;
extern bool 관찰;


//----
int main()
//----
{
	save("소스.cpp");
	관찰 = true;
	std::vector<STRING> v;
	v.push_back("1");
	v.push_back("12");
	std::cout << std::endl;

}	


파일이름: 소스.cpp
파일크기: 960
저장시간: 2022-04-07 12:04:52 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 4월 7일 목요일(6주 1일)
// 
//	컨테이너
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
//			array		-	유일하게 원소갯수 고정
//			vector		-	깊게 알아볼 가치가 있는 컨테이너
//			deque		-
//			foward_list	-
//			list		-
// lexicographical comparison
// 예정: 주간시험 4.27(수) (8주 2일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <vector>
#include "save.h"
#include "STRING.h"

// using namespace std;
// extern bool 관찰;


//----
int main()
//----
{
	save("소스.cpp");
	std::vector<int> v{ 1,2,3,4,5,6,7,8,9,10 };

	// [문제] v에서 짝수를 제거하라.
	// 결과를 출력하라

	v.erase(std::remove_if(v.begin(), v.end(),
		[](int i) {
		return !(i & 1);
	}), v.end());

	for (auto i : v)
		std::cout << i << std::endl;
}	


파일이름: 소스.cpp
파일크기: 916
저장시간: 2022-04-07 12:09:37 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 4월 7일 목요일(6주 1일)
// 
//	컨테이너
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
//			array		-	유일하게 원소갯수 고정
//			vector		-	깊게 알아볼 가치가 있는 컨테이너
//			deque		-
//			foward_list	-
//			list		-
// lexicographical comparison
// 예정: 주간시험 4.27(수) (8주 2일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <vector>
#include "save.h"
#include "STRING.h"

// using namespace std;
// extern bool 관찰;


//----
int main()
//----
{
	save("소스.cpp");
	std::vector<int> v{ 1,2,3,4,5,6,7,8,9,10 };

	// [문제] v에서 짝수를 제거하라.
	// 결과를 출력하라

	std::erase_if(v, [](auto i) {return !(i & 1); });

	for (auto i : v)
		std::cout << i << std::endl;
}	


파일이름: 소스.cpp
파일크기: 1074
저장시간: 2022-04-13 15:42:32 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 4월 7일 목요일(6주 2일)
// 
//	컨테이너
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
//			array		-	유일하게 원소갯수 고정
//			vector		-	깊게 알아볼 가치가 있는 컨테이너
//			deque		-
//			foward_list	-
//			list		-
// 중간시험 4.20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <array>
#include "save.h"
#include "STRING.h"

// using namespace std;
// extern bool 관찰;


//----
int main()
//----
{
	save("소스.cpp");

	// [문제] "소스.cpp"을 읽어 영문자갯수를 세서 다음 형식과 같이 출력
	// 대소문자는 구분하지 않는다.

	// [a] - 10
	// [b] - 3
	// [z] - 1

	std::ifstream in{ "소스.cpp" };
	char c;
	std::array<int, 26> arr{};
	while (in >> c)
		if(isalpha(c))
			arr[tolower(c) - 'a']++;
	for (int i = 0; i < arr.size(); ++i)
		std::cout << "[" << static_cast<char>(i + 'a') << "] - " << arr[i] << std::endl;
}


파일이름: 소스.cpp
파일크기: 898
저장시간: 2022-04-13 16:09:03 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 4월 7일 목요일(6주 2일)
// 
//	컨테이너
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
//			array		-	유일하게 원소갯수 고정
//			vector		-	깊게 알아볼 가치가 있는 컨테이너
//			deque		-
//			foward_list	-
//			list		-
// 중간시험 4.20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"

// using namespace std;
// extern bool 관찰;

// [문제] vector의 중간에 원소를 추가한다.

//----
int main()
//----
{
	save("소스.cpp");

	std::vector<STRING> v{ "1", "22", "4444", "55555" };
	// "4444" 앞에 "333"을 끼워넣어라
	
	v.insert(v.cbegin() += 2, "333");

	for (int i = 0; i < v.size(); ++i)
		std::cout << v[i] << std::endl;
	
}


파일이름: 소스.cpp
파일크기: 961
저장시간: 2022-04-13 16:17:52 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 4월 7일 목요일(6주 2일)
// 
//	컨테이너
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
//			array		-	유일하게 원소갯수 고정
//			vector		-	깊게 알아볼 가치가 있는 컨테이너
//						-	원소를 마지막 위치에 추가하는데 특화되어있다.(o(1))
//			deque		-
//			foward_list	-
//			list		-
// 중간시험 4.20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"

// using namespace std;
extern bool 관찰;

// [문제] vector의 중간에 원소를 추가한다.

//----
int main()
//----
{
	save("소스.cpp");

	std::vector<STRING> v{ "1", "22", "4444", "55555" };
	// "4444" 앞에 "333"을 끼워넣어라

	v.insert(v.cbegin() + 2, 1, "333");


	for (int i = 0; i < v.size(); ++i)
		std::cout << v[i] << std::endl;
	
}


파일이름: 소스.cpp
파일크기: 1142
저장시간: 2022-04-13 16:50:10 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 4월 7일 목요일(6주 2일)
// 
//	컨테이너
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
//			array		-	유일하게 원소갯수 고정
//			vector		-	깊게 알아볼 가치가 있는 컨테이너
//						-	원소를 마지막 위치에 추가하는데 특화되어있다.
//			deque		-
//			foward_list	-
//			list		-
// 중간시험 4.20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <deque>
#include "save.h"
#include "STRING.h"

// using namespace std;
// extern bool 관찰;
class Test {
	char c[1024];
public:
	void show() const {
		std::cout << this << std::endl;
	}
};


//----
int main()
//----
{
	save("소스.cpp");
	
	// [확인] vector는 연속인데 deque는 연속이 아니라고?
	// 주소를 적어 확인해보자
	std::vector<Test> v(10);
	std::deque<Test> d(10);
	for (auto i : v)
		i.show();

	for (auto i : d)
		i.show();

	std::cout << "/---------------------------------------" << std::endl;
	std::cout << sizeof(d) << std::endl;
}


파일이름: 소스.cpp
파일크기: 1003
저장시간: 2022-04-13 16:52:10 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 4월 7일 목요일(6주 2일)
// 
//	컨테이너
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
//			array		-	유일하게 원소갯수 고정
//			vector		-	깊게 알아볼 가치가 있는 컨테이너
//						-	원소를 마지막 위치에 추가하는데 특화되어있다.
//			deque		-
//			foward_list	-
//			list		-
// 중간시험 4.20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <deque>
#include "save.h"
#include "STRING.h"

// using namespace std;
// extern bool 관찰;
class Test {
	char c[1000];
public:
	void show() const {
		std::cout << (long long)this << std::endl;
	}
};


//----
int main()
//----
{
	save("소스.cpp");
	
	// [확인] vector는 연속인데 deque는 연속이 아니라고?
	// 주소를 적어 확인해보자
	std::vector<Test> v(10);

	for (int i = 0; i < v.size(); ++i)
		v[i].show();
}


파일이름: 소스.cpp
파일크기: 1002
저장시간: 2022-04-13 16:52:41 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 4월 7일 목요일(6주 2일)
// 
//	컨테이너
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
//			array		-	유일하게 원소갯수 고정
//			vector		-	깊게 알아볼 가치가 있는 컨테이너
//						-	원소를 마지막 위치에 추가하는데 특화되어있다.
//			deque		-
//			foward_list	-
//			list		-
// 중간시험 4.20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <deque>
#include "save.h"
#include "STRING.h"

// using namespace std;
// extern bool 관찰;
class Test {
	char c[1000];
public:
	void show() const {
		std::cout << (long long)this << std::endl;
	}
};


//----
int main()
//----
{
	save("소스.cpp");
	
	// [확인] vector는 연속인데 deque는 연속이 아니라고?
	// 주소를 적어 확인해보자
	std::deque<Test> v(10);

	for (int i = 0; i < v.size(); ++i)
		v[i].show();
}


파일이름: 소스.cpp
파일크기: 1024
저장시간: 2022-04-13 16:54:47 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 4월 7일 목요일(6주 2일)
// 
//	컨테이너
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
//			array		-	유일하게 원소갯수 고정
//			vector		-	깊게 알아볼 가치가 있는 컨테이너
//						-	원소를 마지막 위치에 추가하는데 특화되어있다.
//			deque		-
//			foward_list	-
//			list		-
// 중간시험 4.20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <deque>
#include "save.h"
#include "STRING.h"

// using namespace std;
// extern bool 관찰;
class Test {
	char c[1000];
public:
	void show() const {
		std::cout << (long long)this << std::endl;
	}
};


//----
int main()
//----
{
	save("소스.cpp");
	
	// [확인] vector는 연속인데 deque는 연속이 아니라고?
	// 주소를 적어 확인해보자
	std::deque<Test> v(10);
	v.push_front(Test{});
	for (int i = 0; i < v.size(); ++i)
		v[i].show();
}


파일이름: 소스.cpp
파일크기: 1174
저장시간: 2022-04-13 17:08:27 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 4월 13일 수요일(6주 2일)
// 
//	컨테이너
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
//			array		-	유일하게 원소갯수 고정
//			vector		-	깊게 알아볼 가치가 있는 컨테이너
//						-	원소를 마지막 위치에 추가하는데 특화되어있다.
//			deque		-	contiguous 컨테이너가 아니다.
//			foward_list	-
//			list		-
// 중간시험 4.20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <deque>
#include "save.h"
#include "STRING.h"

// using namespace std;
// extern bool 관찰;
class Test {
	char c[1000];
public:
	void show() const {
		std::cout << (long long)this << std::endl;
	}
};


//----
int main()
//----
{
	save("소스.cpp");

	// [확인 2] vector보다 deque이 원소를 더 많이 담을 수 있다고?
	// vector<Test> -
	// deque<Test> -
	std::vector<Test> v;

	while (true) {
		try {
			v.push_back({});
		}
		catch (std::exception& e) {
			std::cout << "벡터가 저장한 원소 갯수 - " << v.size() << std::endl;
			return 0;
		}
	}
}


파일이름: 소스.cpp
파일크기: 1180
저장시간: 2022-04-13 17:08:51 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 4월 13일 수요일(6주 2일)
// 
//	컨테이너
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
//			array		-	유일하게 원소갯수 고정
//			vector		-	깊게 알아볼 가치가 있는 컨테이너
//						-	원소를 마지막 위치에 추가하는데 특화되어있다.
//			deque		-	contiguous 컨테이너가 아니다.
//			foward_list	-
//			list		-
// 중간시험 4.20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <deque>
#include "save.h"
#include "STRING.h"

// using namespace std;
// extern bool 관찰;
class Test {
	char c[1000];
public:
	void show() const {
		std::cout << (long long)this << std::endl;
	}
};


//----
int main()
//----
{
	save("소스.cpp");

	// [확인 2] vector보다 deque이 원소를 더 많이 담을 수 있다고?
	// vector<Test> - 699913
	// deque<Test> -
	std::deque<Test> v;

	while (true) {
		try {
			v.push_back({});
		}
		catch (std::exception& e) {
			std::cout << "벡터가 저장한 원소 갯수 - " << v.size() << std::endl;
			return 0;
		}
	}
}


파일이름: 소스.cpp
파일크기: 1190
저장시간: 2022-04-13 17:09:21 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 4월 13일 수요일(6주 2일)
// 
//	컨테이너
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
//			array		-	유일하게 원소갯수 고정
//			vector		-	깊게 알아볼 가치가 있는 컨테이너
//						-	원소를 마지막 위치에 추가하는데 특화되어있다.
//			deque		-	contiguous 컨테이너가 아니다.
//			foward_list	-
//			list		-
// 중간시험 4.20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <deque>
#include "save.h"
#include "STRING.h"

// using namespace std;
// extern bool 관찰;
class Test {
	char c[1000];
public:
	void show() const {
		std::cout << (long long)this << std::endl;
	}
};


//----
int main()
//----
{
	save("소스.cpp");

	// [확인 2] vector보다 deque이 원소를 더 많이 담을 수 있다고?
	// vector<Test> - 699913
	// deque<Test> - 1984902

	std::deque<Test> v;

	while (true) {
		try {
			v.push_back({});
		}
		catch (std::exception& e) {
			std::cout << "벡터가 저장한 원소 갯수 - " << v.size() << std::endl;
			return 0;
		}
	}
}


파일이름: 소스.cpp
파일크기: 1249
저장시간: 2022-04-13 17:10:38 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 4월 13일 수요일(6주 2일)
// 
//	컨테이너
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
//			array		-	유일하게 원소갯수 고정
//			vector		-	깊게 알아볼 가치가 있는 컨테이너
//						-	원소를 마지막 위치에 추가하는데 특화되어있다.
//			deque		-	contiguous 컨테이너가 아니다.
//			foward_list	-
//			list		-
// 중간시험 4.20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <deque>
#include "save.h"
#include "STRING.h"

// using namespace std;
// extern bool 관찰;
class Test {
	char c[1000];
public:
	void show() const {
		std::cout << (long long)this << std::endl;
	}
};


//----
int main()
//----
{
	save("소스.cpp");

	// [확인 2] vector보다 deque이 원소를 더 많이 담을 수 있다고?
	// vector<Test> - 699913
	// deque<Test> - 1984902

	// vector<int> - 136216567
	// deque<int> - 268435452

	std::vector<int> v;

	while (true) {
		try {
			v.push_back({});
		}
		catch (std::exception& e) {
			std::cout << "벡터가 저장한 원소 갯수 - " << v.size() << std::endl;
			return 0;
		}
	}
}


파일이름: 소스.cpp
파일크기: 1134
저장시간: 2022-04-14 10:47:57 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 4월 13일 수요일(6주 2일)
// 
//	컨테이너
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
//			array		-	유일하게 원소갯수 고정
//			vector		-	깊게 알아볼 가치가 있는 컨테이너
//						-	원소를 마지막 위치에 추가하는데 특화되어있다.
//			deque		-	contiguous 컨테이너가 아니다.
//			foward_list	-
//			list		-
// 중간시험 4.20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <string>
#include <algorithm>
#include <fstream>
#include <deque>
#include "save.h"
#include "STRING.h"

// using namespace std;
// extern bool 관찰;

//----
int main()
//----
{
	save("소스.cpp");

	// [문제] "소스.cpp"의 단어를 deque에 읽어라.
	// 오름차순 정렬하시오
	// 결과를 출력하시오

	std::ifstream in{ "소스.cpp"};

	std::deque<std::string> d;

	std::string s;
	while (in >> s)
		d.push_back(s);

	std::sort(d.begin(), d.end());

	for (const std::string& s : d)
		std::cout << s << '\t';
	std::cout << std::endl;
}


파일이름: 소스.cpp
파일크기: 1355
저장시간: 2022-04-14 11:18:15 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 4월 13일 수요일(6주 2일)
// 
//	컨테이너
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
//			array		-	유일하게 원소갯수 고정
//			vector		-	깊게 알아볼 가치가 있는 컨테이너
//						-	원소를 마지막 위치에 추가하는데 특화되어있다.
//			deque		-	contiguous 컨테이너가 아니다.
//			foward_list	-
//			list		-
// 중간시험 4.20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <string>
#include <algorithm>
#include <fstream>
#include <deque>
#include "save.h"
#include "STRING.h"

// using namespace std;
// extern bool 관찰;

//----
int main()
//----
{
	save("소스.cpp");

	// [문제] "컨테이너.txt" 파일의 단어를 deque에 읽어라.
	// deque에 저장된 각 단어를 오름차순으로 정렬하시오.
	// deque의 단어를 길이 오름차순 정렬하시오.
	// 결과를 출력하시오.

	std::ifstream in{ "컨테이너.txt" };
	std::deque<std::string> d{ std::istream_iterator<std::string>{in}, {} };
	
	std::sort(d.begin(), d.end(), [](const std::string& a, const std::string& b) {return a.length() < b.length(); });
	for (std::string& s : d)
		std::sort(s.begin(), s.end());

	copy(d.begin(), d.end(), std::ostream_iterator<std::string>(std::cout, "\n"));

}


파일이름: 소스.cpp
파일크기: 1357
저장시간: 2022-04-14 11:40:46 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 4월 13일 수요일(6주 2일)
// 
//	컨테이너
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
//			array		-	유일하게 원소갯수 고정
//			vector		-	깊게 알아볼 가치가 있는 컨테이너
//						-	원소를 마지막 위치에 추가하는데 특화되어있다.
//			deque		-	contiguous 컨테이너가 아니다.
//			foward_list	-
//			list		-
// 중간시험 4.20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <string>
#include <algorithm>
#include <fstream>
#include <deque>
#include "save.h"
#include "STRING.h"

// using namespace std;
// extern bool 관찰;

//----
int main()
//----
{
	save("소스.cpp");

	// [문제] "컨테이너.txt" 파일의 단어를 deque에 읽어라.
	// deque에 저장된 각 단어를 오름차순으로 정렬하시오.
	// deque의 단어를 길이 오름차순 정렬하시오.
	// 결과를 출력하시오.

	std::ifstream in{ "컨테이너.txt" };

	// in 단어를 d로 읽어 옴
	std::deque<std::string> d{ std::istream_iterator<std::string>{in}, {} };

	// space란 단어는 몇 번째 단어인가?
	// 참고로 라이브러리는 3번째 단어이다.
	auto p = std::find(d.begin(), d.end(), std::string{ "space" });
	if (p != d.end())
		std::cout << "찾은 단어의 위치 - " << p - d.begin() << std::endl;

}


파일이름: 소스.cpp
파일크기: 1104
저장시간: 2022-04-14 11:44:53 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 4월 13일 수요일(6주 2일)
// 
//	컨테이너
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
//			array		-	유일하게 원소갯수 고정
//			vector		-	깊게 알아볼 가치가 있는 컨테이너
//						-	원소를 마지막 위치에 추가하는데 특화되어있다.
//			deque		-	contiguous 컨테이너가 아니다.
//			foward_list	-
//			list		-
// 중간시험 4.20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <string>
#include <algorithm>
#include <fstream>
#include <list>
#include "save.h"
#include "STRING.h"

// using namespace std;
// extern bool 관찰;

//----
int main()
//----
{
	save("소스.cpp");

	// [문제] "컨테이너.txt" 파일의 단어를 list에 읽어라.
	// 오름차순 정렬하라
	// 결과를 출력하시오.

	std::ifstream in{ "컨테이너.txt" };

	std::list<std::string> cont;
	
	std::string str;
	while (in >> str)
		cont.push_back(str);

	for (const std::string& s : cont)
		std::cout << s << std::endl;
}


파일이름: 소스.cpp
파일크기: 1199
저장시간: 2022-04-14 11:53:19 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 4월 13일 수요일(6주 2일)
// 
//	컨테이너
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
//			array		-	유일하게 원소갯수 고정
//			vector		-	깊게 알아볼 가치가 있는 컨테이너
//						-	원소를 마지막 위치에 추가하는데 특화되어있다.
//			deque		-	contiguous 컨테이너가 아니다.
//			foward_list	-
//			list		-
// 중간시험 4.20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <string>
#include <algorithm>
#include <fstream>
#include <list>
#include "save.h"
#include "STRING.h"

// using namespace std;
// extern bool 관찰;

//----
int main()
//----
{
	save("소스.cpp");

	// [문제] "컨테이너.txt" 파일의 단어를 deque에 읽어라.
	// deque에 저장된 각 단어를 오름차순으로 정렬하시오.
	// deque의 단어를 길이 오름차순 정렬하시오.
	// 결과를 출력하시오.

	std::ifstream in{ "컨테이너.txt" };

	std::list<std::string> cont;

	std::string str;
	while (in >> str)
		cont.push_back(str);

	cont.sort();
	for (const std::string& s : cont)
		std::cout << s << std::endl;

}


파일이름: 소스.cpp
파일크기: 1255
저장시간: 2022-04-14 11:57:12 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 4월 13일 수요일(6주 2일)
// 
//	컨테이너
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
//			array		-	유일하게 원소갯수 고정
//			vector		-	깊게 알아볼 가치가 있는 컨테이너
//						-	원소를 마지막 위치에 추가하는데 특화되어있다.
//			deque		-	contiguous 컨테이너가 아니다.
//			foward_list	-
//			list		-
// 중간시험 4.20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <string>
#include <algorithm>
#include <fstream>
#include <list>
#include "save.h"
#include "STRING.h"

// using namespace std;
// extern bool 관찰;

//----
int main()
//----
{
	save("소스.cpp");

	// [문제] "컨테이너.txt" 파일의 단어를 deque에 읽어라.
	// deque에 저장된 각 단어를 오름차순으로 정렬하시오.
	// deque의 단어를 길이 오름차순 정렬하시오.
	// 앞에서부터 10개만 출력하라
	// 결과를 출력하시오.

	std::ifstream in{ "컨테이너.txt" };

	std::list<std::string> cont;

	std::string str;
	while (in >> str)
		cont.push_back(str);

	cont.sort();
	auto p = cont.cbegin();
	for (int i = 0; i < 10; ++i)
		std::cout << *p++ << std::endl;

}


파일이름: 소스.cpp
파일크기: 1261
저장시간: 2022-04-14 11:59:29 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 4월 13일 수요일(6주 2일)
// 
//	컨테이너
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
//			array		-	유일하게 원소갯수 고정
//			vector		-	깊게 알아볼 가치가 있는 컨테이너
//						-	원소를 마지막 위치에 추가하는데 특화되어있다.
//			deque		-	contiguous 컨테이너가 아니다.
//			foward_list	-
//			list		-
// 중간시험 4.20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <string>
#include <algorithm>
#include <fstream>
#include <list>
#include "save.h"
#include "STRING.h"

// using namespace std;
// extern bool 관찰;

//----
int main()
//----
{
	save("소스.cpp");

	// [문제] "컨테이너.txt" 파일의 단어를 deque에 읽어라.
	// deque에 저장된 각 단어를 오름차순으로 정렬하시오.
	// deque의 단어를 길이 오름차순 정렬하시오.
	// 앞에서부터 10개만 출력하라
	// 결과를 출력하시오.

	std::ifstream in{ "컨테이너.txt" };

	std::list<std::string> cont;

	std::string str;
	while (in >> str)
		cont.push_back(str);
	
	cont.sort();
	auto p = cont.cend();
	--p;
	for (int i = 0; i < 10; ++i)
		std::cout << *p-- << std::endl;

}


파일이름: 소스.cpp
파일크기: 1257
저장시간: 2022-04-14 12:00:11 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 4월 13일 수요일(6주 2일)
// 
//	컨테이너
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
//			array		-	유일하게 원소갯수 고정
//			vector		-	깊게 알아볼 가치가 있는 컨테이너
//						-	원소를 마지막 위치에 추가하는데 특화되어있다.
//			deque		-	contiguous 컨테이너가 아니다.
//			foward_list	-
//			list		-
// 중간시험 4.20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <string>
#include <algorithm>
#include <fstream>
#include <list>
#include "save.h"
#include "STRING.h"

// using namespace std;
// extern bool 관찰;

//----
int main()
//----
{
	save("소스.cpp");

	// [문제] "컨테이너.txt" 파일의 단어를 deque에 읽어라.
	// deque에 저장된 각 단어를 오름차순으로 정렬하시오.
	// deque의 단어를 길이 오름차순 정렬하시오.
	// 앞에서부터 10개만 출력하라
	// 결과를 출력하시오.

	std::ifstream in{ "컨테이너.txt" };

	std::list<std::string> cont;

	std::string str;
	while (in >> str)
		cont.push_back(str);
	
	cont.sort();
	auto p = cont.crbegin();
	for (int i = 0; i < 10; ++i)
		std::cout << *p++ << std::endl;

}


파일이름: 소스.cpp
파일크기: 1298
저장시간: 2022-04-14 12:14:10 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 4월 13일 수요일(6주 2일)
// 
//	컨테이너
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
//			array		-	유일하게 원소갯수 고정
//			vector		-	깊게 알아볼 가치가 있는 컨테이너
//						-	원소를 마지막 위치에 추가하는데 특화되어있다.
//			deque		-	contiguous 컨테이너가 아니다.
//			foward_list	-
//			list		-
// 중간시험 4.20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <string>
#include <algorithm>
#include <fstream>
#include <list>
#include "save.h"
#include "STRING.h"

// using namespace std;
// extern bool 관찰;

//----
int main()
//----
{
	save("소스.cpp");

	// [문제] "컨테이너.txt" 파일의 단어를 list에 읽어라.
	// 오름차순 정렬하라
	// space는 몇 번째 단어인가 출력하라.
	// 주의 1번째부터 시작함

	std::ifstream in{ "컨테이너.txt" };

	std::list<std::string> cont;
	std::string str;
	while (in >> str)
		cont.push_back(str);

	cont.sort();
	auto p = std::find(cont.cbegin(), cont.cend(), "space");
	if (p == cont.cend())
		std::cout << "그런 단어 없어요" << std::endl;
	else
		std::cout << (std::distance(cont.cbegin(), p) + 1) << std::endl;
}


파일이름: 소스.cpp
파일크기: 867
저장시간: 2022-04-21 11:34:31 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 4월 21일 수요일(8주 1일)
// 
//	컨테이너
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
//			array		-	유일하게 원소갯수 고정
//			vector		-	깊게 알아볼 가치가 있는 컨테이너
//						-	원소를 마지막 위치에 추가하는데 특화되어있다.
//						-	random access
//			deque		-	contiguous 컨테이너가 아니다.
//						-	마지막 위치 추가 삭제
//						-	반복자 무효화 없음
//						-	random access 지원(실제론 살짝 느림)
//			foward_list	-	single linked list
//			list		-	임의의 위치에서 삽입과 삭제가 O(1)
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "STRING.h"

using namespace std;
// extern bool 관찰;

//----
int main()
//----
{
	save("소스.cpp");
}


파일이름: 소스.cpp
파일크기: 1130
저장시간: 2022-04-21 12:11:37 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 4월 21일 수요일(8주 1일)
// 
//	컨테이너 - 다른 객체를 저장하는 객체
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
//	
//	반복자 - 포인터를 추상화한 것
//		
//-----------------------------------------------------------------------------

#include <iostream>
#include <iterator>
#include <vector>
#include "save.h"
#include "STRING.h"

// using namespace std;
// extern bool 관찰;
//
//template <class Iter>
//void show(Iter)
//{
//	// concept, modeul, range => c++ 20
//	std::iterator_traits<Iter>::iterator_category c;
//	std::cout << "반복자의 종류 - " << typeid(Iter).name() << typeid(c).name() << std::endl;
//}

//----
int main()
//----
{
	save("소스.cpp");
	save("STRING.h");

	// 반복자의 종류(category)를 구분하고 알아본다.
	// 반복자를 인수로 받는 함수를 만들어 어떤 종류 반복자인지 출력하도록 하자
	
	/*std::vector<int> v;
	show(1);
	show(v.begin());*/

	STRING s{ "1234567890" };

	for (char c : s)
		std::cout << c << " * ";
	std::cout << std::endl;
	
}


파일이름: STRING.h
파일크기: 1016
저장시간: 2022-04-21 12:11:37 GMT+9

//-----------------------------------------------------------------------------
// STRING.h - 자원을 관리하는 STL 관찰용 클래스
// 
// 2022.3.30							Programmed by HS
//-----------------------------------------------------------------------------

#pragma once
#include <iostream>
class STRING {
	int id;				// 생성 시 부여
	size_t num;			// 자원 갯수
	char* p;			// 자원이 있는 곳
	static int cid;		// 객체가 생성될 때 1 증가
public:
	STRING();
	~STRING();
	STRING(const char* str);		
	STRING(const STRING& other);

	// 2022.04.07 추가(이동 생성자, 이동할당연산자)
	STRING(STRING&& other) noexcept;
	STRING& operator=(STRING&& other) noexcept;

	STRING& operator=(const STRING& other);
	STRING operator+(const STRING& rhs) const;
	
	// 2022.04.21 begin(), end() 시작
	char* begin() {
		return p;
	};

	char* end() {
		return p + num;
	}
	size_t getNum() const;			// 2022.3.30 추가
	void print(const char* s);

	friend std::ostream& operator<<(std::ostream&, const STRING&);
};

파일이름: 소스.cpp
파일크기: 662
저장시간: 2022-04-27 15:52:31 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 4월 27일 수요일(8주 2일)
// 
//	컨테이너 - 다른 객체를 저장하는 객체
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
//	
//	It is intended that forward_list have zero space or time overhead
// relative to a hand - written C - style singly linked list
// 
// 반복자 - 포인터를 추상화한 것
//	
//-----------------------------------------------------------------------------

#include <iostream>
#include <iterator>
#include <vector>
#include "save.h"
#include "STRING.h"

//----
int main()
//----
{
	save("소스.cpp");

	
}


파일이름: 소스.cpp
파일크기: 700
저장시간: 2022-04-27 15:53:08 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 4월 27일 수요일(8주 2일)
// 
//	컨테이너 - 다른 객체를 저장하는 객체
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
//	
// 표준문서의 forward_list 설명
// 
//	It is intended that forward_list have zero space or time overhead
// relative to a hand - written C - style singly linked list
// 
// 반복자 - 포인터를 추상화한 것
//	
//-----------------------------------------------------------------------------

#include <iostream>
#include <iterator>
#include <vector>
#include "save.h"
#include "STRING.h"

//----
int main()
//----
{
	save("소스.cpp");

	
}


파일이름: 소스.cpp
파일크기: 707
저장시간: 2022-04-27 16:03:44 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 4월 27일 수요일(8주 2일)
// 
//	컨테이너 - 다른 객체를 저장하는 객체
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
//	
//
// 반복자 - 포인터를 추상화한 것
//	
// Iterators are a generalization of pointers that allow a C++ program
// to work with different data structures.
// (for example, containers and ranges) in a uniform manner.
//-----------------------------------------------------------------------------

#include <iostream>
#include <iterator>
#include <vector>
#include "save.h"
#include "STRING.h"

//----
int main()
//----
{
	save("소스.cpp");

	
}


파일이름: 소스.cpp
파일크기: 958
저장시간: 2022-04-27 16:24:50 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 4월 27일 수요일(8주 2일)
// 
//	컨테이너 - 다른 객체를 저장하는 객체
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
//	
//	오늘 할일
// STRING 반복자를 제공하도록 코딩하자.(표준 컨테이너가 될 수도 있다)
// 반복자는 컨테이너가 제공하는 데이터 타입이다.
// STRING이 iterator와 reverse_iterator를 제공하도록 한다.
// 
// 관계연산자: <, >, <=, >=, ==, !=
//-----------------------------------------------------------------------------

#include <iostream>
#include <iterator>
#include <vector>
#include "save.h"
#include "STRING.h"

//----
int main()
//----
{
	save("소스.cpp");
	STRING str{ "Hello" };

	/*for (auto i = str.begin(); i != str.end(); ++i)
		std::cout << *i << " ";
	std::cout << std::endl;*/

	for (char c : str)					// syntactic sugar
		std::cout << c << " ";
	std::cout << std::endl;
	

	
}


파일이름: STRING.h
파일크기: 1787
저장시간: 2022-04-27 16:32:12 GMT+9

//-----------------------------------------------------------------------------
// STRING.h - 자원을 관리하는 STL 관찰용 클래스
// 
// 2022.3.30							Programmed by HS
//-----------------------------------------------------------------------------


#pragma once
#include <iostream>
#include <compare>
class STRING_iterator {
	char* p;
public:
	STRING_iterator(char* p) : p{ p } {}

	char& operator*() const{
		return *p;
	}

	STRING_iterator& operator++() {
		++p;
		return *this;
	}

	// 관계연산자: <, >, <=, >=, ==, !=
	// 관계연산자를 자동으로 생성하는 우주선 연산자를 사용한다.
	// spaceship operator(three-way comparison operator)

	// withordering, stringordering
	auto operator<=>(const STRING_iterator& rhs) const = default;

	bool operator!=(const STRING_iterator& rhs) const {
		std::cout << "이게 우선 사용" << "\n";
		return p != rhs.p;
	}

};


class STRING {
public:
	// 2022. 4. 27
	using iterator = STRING_iterator;


private:
	int id;				// 생성 시 부여
	size_t num;			// 자원 갯수
	char* p;			// 자원이 있는 곳
	static int cid;		// 객체가 생성될 때 1 증가
public:
	STRING();
	~STRING();
	STRING(const char* str);		
	STRING(const STRING& other);

	// 2022.04.07 추가(이동 생성자, 이동할당연산자)
	STRING(STRING&& other) noexcept;
	STRING& operator=(STRING&& other) noexcept;

	STRING& operator=(const STRING& other);
	STRING operator+(const STRING& rhs) const;
	
	// 2022.04.21 begin(), end() 시작
	// 2022.04.27 begin(), end() 다시 코딩
	iterator begin() const {
		return iterator{ p };
	}

	iterator end() const {
		return iterator{ p + num };
	}

	size_t getNum() const;			// 2022.3.30 추가
	void print(const char* s);

	friend std::ostream& operator<<(std::ostream&, const STRING&);
};


파일이름: 소스.cpp
파일크기: 984
저장시간: 2022-04-28 11:02:08 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 4월 28일 목요일(9주 1일)
// 
//	컨테이너 - 다른 객체를 저장하는 객체
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
//	
//	오늘 할일
// STRING 반복자를 제공하도록 코딩하자.(표준 컨테이너가 될 수도 있다)
// 반복자는 컨테이너가 제공하는 데이터 타입이다.
// STRING의 반복자가 sort()에 사용될 수 있도록 필요한 코딩을 한다
//-----------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <string>
#include <algorithm>
#include "save.h"
#include "STRING.h"

//----
int main()
//----
{

	save("소스.cpp");
	save("STRING.h");

	//std::string str{ "The quick brown fox jumps over the lazy dog" };
	STRING str{ "The quick brown fox jumps over the lazy dog" };
	// [도전] 다음 코드가 실행되도록 필요한 코딩을 하자.
	std::sort(str.begin(), str.end());
	std::cout << str << std::endl;
}


파일이름: STRING.h
파일크기: 3497
저장시간: 2022-04-28 11:02:08 GMT+9

//-----------------------------------------------------------------------------
// STRING.h - 자원을 관리하는 STL 관찰용 클래스
// 
// 2022.3.30							Programmed by HS
//-----------------------------------------------------------------------------


#pragma once
#include <iostream>
#include <compare>
class STRING_iterator {
public:	//	표준 반복자라면 이 다섯가지 타입을 제공해야 한다.
	using iterator_category = std::random_access_iterator_tag;
	using value_type = char;
	using difference_type = ptrdiff_t;
	using pointer = char*;
	using reference = char&;
private:
	char* p;
public:
	STRING_iterator(char* p) : p{ p } {}

	reference operator*() const{
		return *p;
	}

	STRING_iterator& operator++() {
		++p;
		return *this;
	}

	// 2022. 4. 28 sort가 요구하는 --연산
	STRING_iterator& operator--() {
		--p;
		return *this;
	}

	// 관계연산자: <, >, <=, >=, ==, !=
	// 관계연산자를 자동으로 생성하는 우주선 연산자를 사용한다.
	// spaceship operator(three-way comparison operator)

	// withordering, stringordering
	auto operator<=>(const STRING_iterator& rhs) const = default;

	// 강순서(strong order), 약순서(week order), 부분순서(partial order)

	//bool operator!=(const STRING_iterator& rhs) const {
	//	std::cout << "이게 우선 사용" << "\n";
	//	return p != rhs.p;
	//}

	// 2022. 4. 27 sort가 요구하는 - 연산
	difference_type operator-(const STRING_iterator& rhs) const{
		return p - rhs.p;
	}

	// 2022. 4. 28 sort가 요구하는 -연산
	STRING_iterator operator-(const difference_type& d) const {
		return STRING_iterator{ p - d };
	}

	// 2022. 4. 28 sort가 요구하는 +연산
	STRING_iterator operator+(const difference_type& d) const {
		return STRING_iterator{ p + d };
	}

	
};

class STRING_reverse_iterator {
public:	//	표준 반복자라면 이 다섯가지 타입을 제공해야 한다.
	using iterator_category = std::random_access_iterator_tag;
	using value_type = char;
	using difference_type = ptrdiff_t;
	using pointer = char*;
	using reference = char&;
private:
	char* p;
public:
	STRING_reverse_iterator(char* p) : p{ p } {}
	reference operator*() const {
		return *(p - 1);
	}

	STRING_reverse_iterator& operator++() {
		--p;
		return *this;
	}
	auto operator<=>(const STRING_reverse_iterator& rhs) const = default;
	bool operator!=(const STRING_reverse_iterator& rhs) const {
		return p != rhs.p;
	}

};


class STRING {
public:
	// 2022. 4. 27
	using iterator = STRING_iterator;
	using reverse_iterator = STRING_reverse_iterator;

private:
	int id;				// 생성 시 부여
	size_t num;			// 자원 갯수
	char* p;			// 자원이 있는 곳
	static int cid;		// 객체가 생성될 때 1 증가
public:
	STRING();
	~STRING();
	STRING(const char* str);		
	STRING(const STRING& other);

	// 2022.04.07 추가(이동 생성자, 이동할당연산자)
	STRING(STRING&& other) noexcept;
	STRING& operator=(STRING&& other) noexcept;

	STRING& operator=(const STRING& other);
	STRING operator+(const STRING& rhs) const;
	
	// 2022.04.21 begin(), end() 시작
	// 2022.04.27 begin(), end() 다시 코딩
	iterator begin() const {
		return iterator{ p };
	}

	iterator end() const {
		return iterator{ p + num };
	}

	reverse_iterator rbegin() const {
		return reverse_iterator{ p + num };
	}

	reverse_iterator rend() const {
		return reverse_iterator{ p };
	}


	size_t getNum() const;			// 2022.3.30 추가
	void print(const char* s);

	friend std::ostream& operator<<(std::ostream&, const STRING&);
};


파일이름: 소스.cpp
파일크기: 1123
저장시간: 2022-04-28 11:47:56 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 4월 28일 목요일(9주 1일)
// 
//	컨테이너 - 다른 객체를 저장하는 객체
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
//	
//	오늘 할일
// STRING 반복자를 제공하도록 코딩하자.(표준 컨테이너가 될 수도 있다)
// 반복자는 컨테이너가 제공하는 데이터 타입이다.
// STRING의 반복자가 sort()에 사용될 수 있도록 필요한 코딩을 한다
//-----------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <algorithm>
#include "save.h"
#include "STRING.h"

//----
int main()
//----
{
	save("소스.cpp");
	std::ifstream in{ "소스.cpp" };
	std::vector<STRING> v{ std::istream_iterator<STRING>{in}, {} };
	
	// [문제] v의 원소를 오름차순으로 정렬하라.

	std::sort(v.begin(), v.end(), [](STRING& a, STRING& b) {
		std::string tmpA{ a.getChar() };
		std::string tmpB{ b.getChar() };

		return tmpA < tmpB;
	});


	for (const STRING& i : v)
		std::cout << i << "\t";
	std::cout << std::endl;

}


파일이름: 소스.cpp
파일크기: 1118
저장시간: 2022-04-28 11:51:05 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 4월 28일 목요일(9주 1일)
// 
//	컨테이너 - 다른 객체를 저장하는 객체
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
//	
//	오늘 할일
// STRING 반복자를 제공하도록 코딩하자.(표준 컨테이너가 될 수도 있다)
// 반복자는 컨테이너가 제공하는 데이터 타입이다.
// STRING의 반복자가 sort()에 사용될 수 있도록 필요한 코딩을 한다
//-----------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <algorithm>
#include "save.h"
#include "STRING.h"

//----
int main()
//----
{
	save("소스.cpp");
	std::ifstream in{ "소스.cpp" };
	std::vector<STRING> v{ std::istream_iterator<STRING>{in}, {} };
	
	// [문제] v의 원소를 오름차순으로 정렬하라.

	std::sort(v.begin(), v.end(), [](STRING& lhs, STRING& rhs) {
		return std::lexicographical_compare(lhs.begin(), lhs.end(), rhs.begin(), rhs.end());
	});


	for (const STRING& i : v)
		std::cout << i << "\t";
	std::cout << std::endl;

}


파일이름: 소스.cpp
파일크기: 994
저장시간: 2022-04-28 11:52:48 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 4월 28일 목요일(9주 1일)
// 
//	컨테이너 - 다른 객체를 저장하는 객체
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
//	
//	오늘 할일
// STRING 반복자를 제공하도록 코딩하자.(표준 컨테이너가 될 수도 있다)
// 반복자는 컨테이너가 제공하는 데이터 타입이다.
// STRING의 반복자가 sort()에 사용될 수 있도록 필요한 코딩을 한다
//-----------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <algorithm>
#include "save.h"
#include "STRING.h"

//----
int main()
//----
{
	save("소스.cpp");
	std::ifstream in{ "소스.cpp" };
	std::vector<STRING> v{ std::istream_iterator<STRING>{in}, {} };
	
	// [문제] v의 원소를 오름차순으로 정렬하라.

	std::sort(v.begin(), v.end());


	for (const STRING& i : v)
		std::cout << i << "\t";
	std::cout << std::endl;

}


파일이름: 소스.cpp
파일크기: 1142
저장시간: 2022-04-28 11:58:43 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 4월 28일 목요일(9주 1일)
// 
//	컨테이너 - 다른 객체를 저장하는 객체
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
//	
//	오늘 할일
// STRING 반복자를 제공하도록 코딩하자.(표준 컨테이너가 될 수도 있다)
// 반복자는 컨테이너가 제공하는 데이터 타입이다.
// STRING의 반복자가 sort()에 사용될 수 있도록 필요한 코딩을 한다
//-----------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <algorithm>
#include "save.h"
#include "STRING.h"

//----
int main()
//----
{
	save("소스.cpp");
	std::ifstream in{ "소스.cpp" };
	std::vector<STRING> v{ std::istream_iterator<STRING>{in}, {} };
	
	// [문제] v의 원소를 오름차순으로 정렬하라.
	// 어디서든 비교가능하도록 < 가 있으면 됨
	
	std::sort(v.begin(), v.end());

	// v의 원소인 STRING을 오름차순으로 정렬하라.
	for(STRING& s : v)
		std::sort(s.begin(), s.end());

	for (const STRING& i : v)
		std::cout << i << "\t";
	std::cout << std::endl;

}


파일이름: 소스.cpp
파일크기: 1182
저장시간: 2022-04-28 11:59:55 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 4월 28일 목요일(9주 1일)
// 
//	컨테이너 - 다른 객체를 저장하는 객체
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
//	
//	오늘 할일
// STRING 반복자를 제공하도록 코딩하자.(표준 컨테이너가 될 수도 있다)
// 반복자는 컨테이너가 제공하는 데이터 타입이다.
// STRING의 반복자가 sort()에 사용될 수 있도록 필요한 코딩을 한다
//-----------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <algorithm>
#include "save.h"
#include "STRING.h"

//----
int main()
//----
{
	save("소스.cpp");
	std::ifstream in{ "소스X.txt" };
	std::vector<STRING> v{ std::istream_iterator<STRING>{in}, {} };
	
	// [문제] v의 원소를 오름차순으로 정렬하라.
	// 어디서든 비교가능하도록 < 가 있으면 됨
	
	std::sort(v.begin(), v.end());

	// v의 원소인 STRING을 오름차순으로 정렬하라.
	for (STRING& s : v)
		std::sort(s.begin(), s.end(), [](char a, char b) { return a > b; });

	for (const STRING& i : v)
		std::cout << i << "\t";
	std::cout << std::endl;

}


파일이름: 소스.cpp
파일크기: 1329
저장시간: 2022-05-04 15:37:31 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 4월 28일 목요일(9주 1일)
// 
//	컨테이너 - 다른 객체를 저장하는 객체
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
// 
// 반복자를 이해했다면 제네릭 함수를 만들어 볼 수 있겠다
// 반복자 => 포인터를 일반화하고 추상화한 것
// Pointer => 무언가를 가르키고 있는 것
// Pointer로 할 수 있는 일 => 가르키고 있는 값을 알아올 수 있다, 
//-----------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include "save.h"
#include "STRING.h"

template <class T, class Ty>
T my_find(T begin, T end, Ty target);

template <class T, class Ty>
T my_find(T begin, T end, Ty target)
{
	// While 문으로 쓰기
	while (begin != end)
	{
		if (*begin == target)
			return begin;
		++begin;
	}
	return end;
}

//----
int main()
//----
{
	save("소스.cpp");
	STRING s{"Hello, world"};
	
	// [문제] s에 어떤 문자가 몇번째 출력하자.
	while (true)
	{
		std::cout << "찾으려는 문자는? :";
		char c;
		std::cin >> c;
		auto p = my_find(s.begin(), s.end(), c);
		if (p != s.end())
			std::cout << std::distance(s.begin(), p) + 1 << "번째 문자입니다." << std::endl;
		else
			std::cout << c << "는 없는 문자입니다." << std::endl;
	}
}


파일이름: 소스.cpp
파일크기: 1412
저장시간: 2022-05-04 15:46:44 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 4월 28일 목요일(9주 1일)
// 
//	컨테이너 - 다른 객체를 저장하는 객체
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
// 
// 반복자를 이해했다면 제네릭 함수를 만들어 볼 수 있겠다
// 반복자 => 포인터를 일반화하고 추상화한 것
// Pointer => 무언가를 가르키고 있는 것
// Pointer로 할 수 있는 일 => 가르키고 있는 값을 알아올 수 있다, 
//-----------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include "save.h"
#include "STRING.h"

template <class T, class Ty>
T my_find(T begin, T end, Ty target);

template <class T, class Ty>
T my_find(T begin, T end, Ty target)
{
	// While 문으로 쓰기
	while (begin != end)
	{
		if (*begin == target)
			return begin;
		++begin;
	}
	return end;
}

//----
int main()
//----
{
	save("소스.cpp");
	
	// [문제] STRING에서 'k'보다 큰 문자가 몇번째인지 출력하라
	
	while (true)
	{
		std::cout << "단어를 입력하세요: ";
		STRING s;		// 컴파일러가 루프 최적화를 시켜줌 (loop optimization)

		std::cin >> s;
		auto p = std::find_if(s.begin(), s.end(), [](char c) {return 'k' < c; });
	
		if (p == s.end())
			std::cout << "k보다 큰 글자 없다" << std::endl;
		else
			std::cout << std::distance(s.begin(), p) + 1 << " 위치에서 발견" << std::endl;

	}
	
}


파일이름: 소스.cpp
파일크기: 1141
저장시간: 2022-05-04 15:47:47 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 4월 28일 목요일(9주 1일)
// 
//	컨테이너 - 다른 객체를 저장하는 객체
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
// 
// 반복자를 이해했다면 제네릭 함수를 만들어 볼 수 있겠다
// 반복자 => 포인터를 일반화하고 추상화한 것
// Pointer => 무언가를 가르키고 있는 것
// Pointer로 할 수 있는 일 => 가르키고 있는 값을 알아올 수 있다, 
//-----------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include "save.h"
#include "STRING.h"

//----
int main()
//----
{
	save("소스.cpp");
	
	// [문제] STRING에서 처음 대문자가 출현하는 위치를 출력하라
	
	while (true)
	{
		std::cout << "단어를 입력하세요: ";
		STRING s;		// 컴파일러가 루프 최적화를 시켜줌 (loop optimization)

		std::cin >> s;
		auto p = std::find_if(s.begin(), s.end(), [](char c) {return isupper(c); });
	
		if (p == s.end())
			std::cout << "대문자는 없다" << std::endl;
		else
			std::cout << std::distance(s.begin(), p) + 1 << " 위치에서 발견" << std::endl;

	}
	
}


파일이름: 소스.cpp
파일크기: 1217
저장시간: 2022-05-04 16:03:59 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 4월 28일 목요일(9주 1일)
// 
//	컨테이너 - 다른 객체를 저장하는 객체
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
// 
// 반복자를 이해했다면 제네릭 함수를 만들어 볼 수 있겠다
//-----------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include "save.h"
#include "STRING.h"

template <class Iter,  class Call>
Iter my_find_if(Iter b, Iter e, Call f);

template <class Iter, class Call>
Iter my_find_if(Iter b, Iter e, Call f)
{
	while (b != e)
	{
		if (f(*b))
			return b;
		++b;
	}
	return e;
}

//----
int main()
//----
{
	save("소스.cpp");	
	// [문제] STRING에서 처음 대문자가 출현하는 위치를 출력하라
	while (true)
	{
		std::cout << "단어를 입력하세요: ";
		STRING s;		// 컴파일러가 루프 최적화를 시켜줌 (loop optimization)

		std::cin >> s;
		auto p = my_find_if(s.begin(), s.end(), [](char c) {return isupper(c); });
	
		if (p == s.end())
			std::cout << "대문자는 없다" << std::endl;
		else
			std::cout << std::distance(s.begin(), p) + 1 << " 위치에서 발견" << std::endl;

	}
	
}


파일이름: 소스.cpp
파일크기: 1231
저장시간: 2022-05-04 16:04:51 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 4월 28일 목요일(9주 1일)
// 
//	컨테이너 - 다른 객체를 저장하는 객체
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
// 
// 반복자를 이해했다면 제네릭 함수를 만들어 볼 수 있겠다
//-----------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include "save.h"
#include "STRING.h"

template <class Iter,  class Call>
Iter my_find_if(Iter b, Iter e, Call f);

template <class Iter, class Call>
Iter my_find_if(Iter b, Iter e, Call f)
{
	while (b != e)
	{
		if (f(*b))
			return b;
		++b;
	}
	return e;
}

bool f(char c)
{
	return isupper(c);
}

//----
int main()
//----
{
	save("소스.cpp");	
	// [문제] STRING에서 처음 대문자가 출현하는 위치를 출력하라
	while (true)
	{
		std::cout << "단어를 입력하세요: ";
		STRING s;		// 컴파일러가 루프 최적화를 시켜줌 (loop optimization)

		std::cin >> s;
		auto p = my_find_if(s.begin(), s.end(), f);
	
		if (p == s.end())
			std::cout << "대문자는 없다" << std::endl;
		else
			std::cout << std::distance(s.begin(), p) + 1 << " 위치에서 발견" << std::endl;

	}
	
}


파일이름: 소스.cpp
파일크기: 1326
저장시간: 2022-05-04 16:08:12 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 4월 28일 목요일(9주 1일)
// 
//	컨테이너 - 다른 객체를 저장하는 객체
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
// 
// 반복자를 이해했다면 제네릭 함수를 만들어 볼 수 있겠다
//-----------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include "save.h"
#include "STRING.h"

template <class Iter,  class Call>
Iter my_find_if(Iter b, Iter e, Call f);

template <class Iter, class Call>
Iter my_find_if(Iter b, Iter e, Call f)
{
	while (b != e)
	{
		if (f(*b))
			return b;
		++b;
	}
	return e;
}

class XXX
{
public:
	bool operator()(char c)
	{
		std::cout << "이거 호출되고 있음" << std::endl;
		return isupper(c);
	}
};

//----
int main()
//----
{
	save("소스.cpp");	
	// [문제] STRING에서 처음 대문자가 출현하는 위치를 출력하라
	while (true)
	{
		std::cout << "단어를 입력하세요: ";
		STRING s;		// 컴파일러가 루프 최적화를 시켜줌 (loop optimization)

		std::cin >> s;
		auto p = my_find_if(s.begin(), s.end(), XXX());
	
		if (p == s.end())
			std::cout << "대문자는 없다" << std::endl;
		else
			std::cout << std::distance(s.begin(), p) + 1 << " 위치에서 발견" << std::endl;

	}
	
}


파일이름: 소스.cpp
파일크기: 1355
저장시간: 2022-05-04 16:09:04 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 4월 28일 목요일(9주 1일)
// 
//	컨테이너 - 다른 객체를 저장하는 객체
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
// 
// 반복자를 이해했다면 제네릭 함수를 만들어 볼 수 있겠다
//-----------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include "save.h"
#include "STRING.h"

template <class Iter,  class Call>
Iter my_find_if(Iter b, Iter e, Call f);

template <class Iter, class Call>
Iter my_find_if(Iter b, Iter e, Call f)
{
	while (b != e)
	{
		if (f(*b))
			return b;
		++b;
	}
	return e;
}

// function object(Functor)
class XXX
{
public:
	bool operator()(char c)
	{
		std::cout << "이거 호출되고 있음" << std::endl;
		return isupper(c);
	}
};

//----
int main()
//----
{
	save("소스.cpp");	
	// [문제] STRING에서 처음 대문자가 출현하는 위치를 출력하라
	while (true)
	{
		std::cout << "단어를 입력하세요: ";
		STRING s;		// 컴파일러가 루프 최적화를 시켜줌 (loop optimization)

		std::cin >> s;
		auto p = my_find_if(s.begin(), s.end(), XXX());
	
		if (p == s.end())
			std::cout << "대문자는 없다" << std::endl;
		else
			std::cout << std::distance(s.begin(), p) + 1 << " 위치에서 발견" << std::endl;

	}
	
}


파일이름: 소스.cpp
파일크기: 713
저장시간: 2022-05-04 16:16:05 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 4월 28일 목요일(9주 1일)
// 
//	컨테이너 - 다른 객체를 저장하는 객체
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
// 
// 반복자를 이해했다면 제네릭 함수를 만들어 볼 수 있겠다
//-----------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include "save.h"
#include "STRING.h"


//----
int main()
//----
{
	save("소스.cpp");	
	
	//	키보드에서 입력한 문자를 그대로 화면에 출력하라.
	//	copy를 사용할 것

	std::copy(std::istream_iterator<char> {std::cin}, {}, std::ostream_iterator<char>{std::cout, "-"});
	
	
}


파일이름: 소스.cpp
파일크기: 937
저장시간: 2022-05-04 16:22:08 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 4월 28일 목요일(9주 1일)
// 
//	컨테이너 - 다른 객체를 저장하는 객체
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
// 
// 반복자를 이해했다면 제네릭 함수를 만들어 볼 수 있겠다
//-----------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include "save.h"
#include "STRING.h"

template<class Input_Iter, class Output_Iter>
Output_Iter my_copy(Input_Iter first, Input_Iter last, Output_Iter d_first)
{
	while (first != last)
	{
		*d_first = *first;
		++first;
		++d_first;
	}
	return d_first;
}


//----
int main()
//----
{
	save("소스.cpp");
	//	키보드에서 입력한 문자를 그대로 화면에 출력하라.
	//	copy를 사용할 것

	my_copy(std::istream_iterator<char> {std::cin}, {}, std::ostream_iterator<char>{std::cout, "-"});
	
	
}


파일이름: 소스.cpp
파일크기: 932
저장시간: 2022-05-04 16:30:40 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 4월 28일 목요일(9주 1일)
// 
//	컨테이너 - 다른 객체를 저장하는 객체
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
// 
// 반복자를 이해했다면 제네릭 함수를 만들어 볼 수 있겠다
//-----------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include "save.h"
#include "STRING.h"

template<class Input_Iter, class Output_Iter>
Output_Iter my_copy(Input_Iter first, Input_Iter last, Output_Iter d_first)
{
	while (first != last)
	{
		*d_first = *first;
		++first;
		++d_first;
	}
	return d_first;
}


//----
int main()
//----
{
	save("소스.cpp");
	//	키보드에서 입력한 문자를 그대로 화면에 출력하라.
	//	copy를 사용할 것

	my_copy(std::istream_iterator<char> {std::cin}, {}, std::ostream_iterator<char>{std::cout});
	
	
}


파일이름: 소스.cpp
파일크기: 853
저장시간: 2022-05-04 16:33:14 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 4월 28일 목요일(9주 1일)
// 
//	컨테이너 - 다른 객체를 저장하는 객체
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
// 
// 반복자를 이해했다면 제네릭 함수를 만들어 볼 수 있겠다
//-----------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include "save.h"
#include "STRING.h"

template<class SrcIter, class DestIter>
DestIter my_copy(SrcIter b, SrcIter e, DestIter d)
{
	while (b != e)
		*d++ = *b++;
	return d;
}


//----
int main()
//----
{
	save("소스.cpp");
	//	키보드에서 입력한 문자를 그대로 화면에 출력하라.
	//	copy를 사용할 것

	my_copy(std::istream_iterator<char> {std::cin}, {}, std::ostream_iterator<char>{std::cout, "-"});
	
	
}


파일이름: 소스.cpp
파일크기: 853
저장시간: 2022-05-04 16:33:54 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 4월 28일 목요일(9주 1일)
// 
//	컨테이너 - 다른 객체를 저장하는 객체
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
// 
// 반복자를 이해했다면 제네릭 함수를 만들어 볼 수 있겠다
//-----------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include "save.h"
#include "STRING.h"

template<class SrcIter, class DestIter>
DestIter my_copy(SrcIter b, SrcIter e, DestIter d)
{
	while (b != e)
		*d++ = *b++;
	return d;
}


//----
int main()
//----
{
	save("소스.cpp");
	//	키보드에서 입력한 문자를 그대로 화면에 출력하라.
	//	copy를 사용할 것

	my_copy(std::istream_iterator<char> {std::cin}, {}, std::ostream_iterator<char>{std::cout, "-"});
	
	
}


파일이름: 소스.cpp
파일크기: 873
저장시간: 2022-05-04 16:34:09 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 4월 28일 목요일(9주 1일)
// 
//	컨테이너 - 다른 객체를 저장하는 객체
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
// 
// 반복자를 이해했다면 제네릭 함수를 만들어 볼 수 있겠다
//-----------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include "save.h"
#include "STRING.h"

template<class SrcIter, class DestIter>
DestIter my_copy(SrcIter b, SrcIter e, DestIter d)
{
	while (b != e)
	{
		*d = *b;
		++b;
		++d;
	}
	return d;
}


//----
int main()
//----
{
	save("소스.cpp");
	//	키보드에서 입력한 문자를 그대로 화면에 출력하라.
	//	copy를 사용할 것

	my_copy(std::istream_iterator<char> {std::cin}, {}, std::ostream_iterator<char>{std::cout, "-"});
	
	
}


파일이름: 소스.cpp
파일크기: 873
저장시간: 2022-05-04 16:34:18 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 4월 28일 목요일(9주 1일)
// 
//	컨테이너 - 다른 객체를 저장하는 객체
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
// 
// 반복자를 이해했다면 제네릭 함수를 만들어 볼 수 있겠다
//-----------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include "save.h"
#include "STRING.h"

template<class SrcIter, class DestIter>
DestIter my_copy(SrcIter b, SrcIter e, DestIter d)
{
	while (b != e)
	{
		*d = *b;
		++b;
		++d;
	}
	return d;
}


//----
int main()
//----
{
	save("소스.cpp");
	//	키보드에서 입력한 문자를 그대로 화면에 출력하라.
	//	copy를 사용할 것

	my_copy(std::istream_iterator<char> {std::cin}, {}, std::ostream_iterator<char>{std::cout, "-"});
	
	
}


파일이름: 소스.cpp
파일크기: 941
저장시간: 2022-05-04 16:41:53 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 4일 목요일(9주 2일)
// 
//	컨테이너 - 다른 객체를 저장하는 객체
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
// 
// 반복자를 이해했다면 제네릭 함수를 만들어 볼 수 있겠다
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "STRING.h"

template<class SrcIter, class DestIter>
void my_copy(SrcIter b, SrcIter e, DestIter d)
{
	while (b != e)
	{
		*d = *b;
		++b;
		++d;
	}
}


//----
int main()
//----
{
	save("소스.cpp");
	//	키보드에서 입력한 문자를 벡터에 저장하라.
	//	copy를 사용할 것
	std::vector<char> v;
	v.reserve(100);
	my_copy(std::istream_iterator<char> {std::cin}, {}, v.begin());
	
	for (char c : v)
		std::cout << c << "-";
	std::cout << std::endl;
}


파일이름: 소스.cpp
파일크기: 955
저장시간: 2022-05-04 16:51:38 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 4일 목요일(9주 2일)
// 
//	컨테이너 - 다른 객체를 저장하는 객체
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
// 
// 반복자를 이해했다면 제네릭 함수를 만들어 볼 수 있겠다
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "STRING.h"

template<class SrcIter, class DestIter>
void my_copy(SrcIter b, SrcIter e, DestIter d)
{
	while (b != e)
	{
		*d = *b;
		++b;
		++d;
	}
}


//----
int main()
//----
{
	save("소스.cpp");
	//	키보드에서 입력한 문자를 벡터에 저장하라.
	//	copy를 사용할 것
	std::vector<char> v;
	v.reserve(100);
	std::copy(std::istream_iterator<char> {std::cin}, {}, std::back_inserter(v));
	
	for (char c : v)
		std::cout << c << "-";
	std::cout << std::endl;
}


파일이름: 소스.cpp
파일크기: 824
저장시간: 2022-05-04 17:05:04 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 4일 목요일(9주 2일)
// 
//	컨테이너 - 다른 객체를 저장하는 객체
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
// 
// 반복자를 이해했다면 제네릭 함수를 만들어 볼 수 있겠다
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "STRING.h"

void print(int a[]);		// 배열은 인자로 전달되면 포인터가 된다(decay);
void print(int a[])
{
	for (int i = 0; i < 10; ++i)
		std::cout << a[i] << "-";
	std::cout << std::endl;
}

//----
int main()
//----
{
	save("소스.cpp");

	int a[10]{ 1,2,3,4,5 };
	// [문제] print 함수는 a를 인자로 받아 전체 원소를 출력한다.
	// 선언하고 정의하고 호출하라

	print(a);
	
}


파일이름: 소스.cpp
파일크기: 824
저장시간: 2022-05-04 17:05:48 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 4일 목요일(9주 2일)
// 
//	컨테이너 - 다른 객체를 저장하는 객체
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
// 
// 반복자를 이해했다면 제네릭 함수를 만들어 볼 수 있겠다
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "STRING.h"

void print(int*);		// 배열이 인자로 전달되면 포인터가 된다(type decay)
void print(int* a)
{
	for (int i = 0; i < 10; ++i)
		std::cout << a[i] << "-";
	std::cout << std::endl;
}

//----
int main()
//----
{
	save("소스.cpp");

	int a[10]{ 1,2,3,4,5 };
	// [문제] print 함수는 a를 인자로 받아 전체 원소를 출력한다.
	// 선언하고 정의하고 호출하라

	print(a);
	
}


파일이름: 소스.cpp
파일크기: 1151
저장시간: 2022-05-04 17:11:44 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 4일 목요일(9주 2일)
// 
//	컨테이너 - 다른 객체를 저장하는 객체
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
// 
// 반복자를 이해했다면 제네릭 함수를 만들어 볼 수 있겠다
// 
// C++20 span - contiguous 컨테이너와 연결된 view를 말함.
//				배열이 인자로 전달될 때 size()를 알 수 없는 문제를 해결
//				[], array, vector, string, STRING
//				-> 얘들을 일관되게 취급하려고 만든 view
//-----------------------------------------------------------------------------

#include <iostream>
#include <span>
#include "save.h"
#include "STRING.h"

void print(std::span<int>);		// 배열이 인자로 전달되면 포인터가 된다(type decay)
void print(std::span<int> a)
{
	std::cout << "전체 메모리 크기 - " << a.size_bytes() << std::endl;
	for (int i = 0; i < a.size(); ++i)
		std::cout << a[i] << "-";
	std::cout << std::endl;
}

//----
int main()
//----
{
	save("소스.cpp");

	int a[10]{ 1,2,3,4,5 };
	// [문제] print 함수는 a를 인자로 받아 전체 원소를 출력한다.
	// 선언하고 정의하고 호출하라

	print(a);
	
}


파일이름: 소스.cpp
파일크기: 1309
저장시간: 2022-05-05 10:51:50 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 4일 목요일(10주 1일)
// 
//	컨테이너 - 다른 객체를 저장하는 객체
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
// 
// Associative Container - set, multi_set, map, multi_map
// set - 언제나 key를 compare로 정렬하고 있다. 찾기/추가/삭제가 O(log N)
//-----------------------------------------------------------------------------

#include <iostream>
#include <span>
#include <vector>
#include "save.h"
#include "STRING.h"

void print(std::span<int>);
void print(std::span<int> a)
{
	std::cout << "전체 메모리 크기 - " << a.size_bytes() << std::endl;
	for (int i = 0; i < a.size(); ++i)
		std::cout << a[i] << "-";
	std::cout << std::endl;
}

void print(std::span<char> a)
{
	std::cout << "전체 char 메모리 크기 - " << a.size_bytes() << std::endl;
	for (int i = 0; i < a.size(); ++i)
		std::cout << a[i] << "-";
	std::cout << std::endl;
}

//----
int main()
//----
{
	save("소스.cpp");
	// [문제] print 함수는 a를 인자로 받아 전체 원소를 출력한다.
	// 선언하고 정의하고 호출하라

	int a[10]{ 1,2,3,4,5 };
	print(a);

	std::vector<int> v{ 1,2,3,4,5 };
	print(v);

	STRING s{ "1234567890" };
	print(std::span<char>((char*)&(*s.begin()), 10));
}


파일이름: 소스.cpp
파일크기: 808
저장시간: 2022-05-05 10:55:39 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 4일 목요일(10주 1일)
// 
//	컨테이너 - 다른 객체를 저장하는 객체
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
// 
// Associative Container - set, multi_set, map, multi_map
// set - 언제나 key를 compare로 정렬하고 있다. 찾기/추가/삭제가 O(log N)
//-----------------------------------------------------------------------------

#include <iostream>
#include <numeric>
#include <vector>
#include <format>
#include "save.h"
#include "STRING.h"


//----
int main()
//----
{
	save("소스.cpp");
	
	std::vector<int> v(100);
	std::iota(v.begin(), v.end(), 1);

	for (int i = 0; i < v.size(); ++i)
		std::cout << std::format("{:4}", v[i]);
	std::cout << std::endl;
}


파일이름: 소스.cpp
파일크기: 1300
저장시간: 2022-05-05 11:09:31 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 4일 목요일(10주 1일)
// 
//	컨테이너 - 다른 객체를 저장하는 객체
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
// 
// Associative Container - set, multi_set, map, multi_map
// set - 언제나 key를 compare로 정렬하고 있다. 찾기/추가/삭제가 O(log N)
//-----------------------------------------------------------------------------

#include <iostream>
#include <numeric>
#include <set>
#include <vector>
#include <format>
#include <random>
#include "save.h"
#include "STRING.h"

std::random_device rd;
std::default_random_engine dre{ rd() };

//----
int main()
//----
{
	save("소스.cpp");
	
	std::vector<int> v(100);
	std::iota(v.begin(), v.end(), 1);		// 1 - 100;
	std::shuffle(v.begin(), v.end(), dre);


	// 아무 컨테이너나 다른 컨테이너를 생성하는데 사용가능
	std::set<int> s(v.begin(), v.end(), std::less<int>());

	// 반복자를 이용해서 역방향 출력하라
	for (std::set<int>::reverse_iterator i = s.crbegin(); i != s.crend(); ++i)
		std::cout << std::format("{:4}", *i);
	std::cout << std::endl;
	std::cout << std::endl;

	/*for (int i = 0; i < v.size(); ++i)
		std::cout << std::format("{:4}", v[i]);
	std::cout << std::endl;*/

	
}


파일이름: 소스.cpp
파일크기: 1540
저장시간: 2022-05-05 11:21:35 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 4일 목요일(10주 1일)
// 
//	컨테이너 - 다른 객체를 저장하는 객체
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
// 
// Associative Container - set, multi_set, map, multi_map
// set - 언제나 key를 compare로 정렬하고 있다. 찾기/추가/삭제가 O(log N)
//-----------------------------------------------------------------------------

#include <iostream>
#include <numeric>
#include <set>
#include <vector>
#include <format>
#include <random>
#include "save.h"
#include "STRING.h"

std::random_device rd;
std::default_random_engine dre{ rd() };

class 기준 {
public:
	bool operator()(int a, int b) const
	{
		return a > b;
	}
};

//----
int main()
//----
{
	save("소스.cpp");

	//std::vector<int> v(100);
	//std::iota(v.begin(), v.end(), 1);		// 1 - 100;
	//std::shuffle(v.begin(), v.end(), dre);


	//// 아무 컨테이너나 다른 컨테이너를 생성하는데 사용가능
	//// 내림차순으로 정렬하는 set 생성
	//std::set<int> s(v.begin(), v.end(), 비교);

	//// 반복자를 이용해서 출력하라
	//for (std::set<int>::iterator i = s.cbegin(); i != s.cend(); ++i)
	//	std::cout << std::format("{:4}", *i);
	//std::cout << std::endl;
	//std::cout << std::endl;

	///*for (int i = 0; i < v.size(); ++i)
	//	std::cout << std::format("{:4}", v[i]);
	//std::cout << std::endl;*/

	std::set<int, 기준> s{ 1, 3, 5, 2, 4 };

	for (int n : s)
		std::cout << n << " ";
	std::cout << std::endl;
	
}


파일이름: 소스.cpp
파일크기: 945
저장시간: 2022-05-05 11:33:22 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 4일 목요일(10주 1일)
// 
//	컨테이너 - 다른 객체를 저장하는 객체
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
// 
// Associative Container - set, multi_set, map, multi_map
// set - 언제나 key를 compare로 정렬하고 있다. 찾기/추가/삭제가 O(log N)
//-----------------------------------------------------------------------------

#include <iostream>
#include <numeric>
#include <set>
#include <vector>
#include <format>
#include <random>
#include "save.h"
#include "STRING.h"

std::random_device rd;
std::default_random_engine dre{ rd() };

class 기준 {
public:
	bool operator()(int a, int b) const
	{
		return a > b;
	}
};

//----
int main()
//----
{
	save("소스.cpp");

	std::set<int, 기준> s{ 1, 3, 5, 2, 4 };

	for (int n : s)
		std::cout << n << " ";
	std::cout << std::endl;
	
}


파일이름: 소스.cpp
파일크기: 1086
저장시간: 2022-05-05 11:46:22 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 4일 목요일(10주 1일)
// 
//	컨테이너 - 다른 객체를 저장하는 객체
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
// 
// Associative Container - set, multi_set, map, multi_map
// set - 언제나 key를 compare로 정렬하고 있다. 찾기/추가/삭제가 O(log N)
//		- set의 주요 동작을 알아본다. (빨리 찾기 위한 컨테이너)
//		- 내가 만든 자료형(class Dog)을 set에 넣어 관리
//		- 중복되는 데이터를 하나로만 저장(multiset을 이용해야함)
//-----------------------------------------------------------------------------

#include <iostream>
#include <set>
#include <string>
#include <fstream>
#include "save.h"
#include "STRING.h"

//----
int main()
//----
{
	save("소스.cpp");

	// [문제] "소스.cpp"의 단어를 set에 저장한 후 출려하라.
	std::ifstream in{ "소스.cpp" };
	std::multiset<std::string> s{ std::istream_iterator<std::string> {in}, {} };

	for (auto i{ s.cbegin() }; i != s.cend(); ++i)
		std::cout << *i << "\n";
	std::cout << std::endl;
	
}


파일이름: 소스.cpp
파일크기: 1231
저장시간: 2022-05-05 11:52:24 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 4일 목요일(10주 1일)
// 
//	컨테이너 - 다른 객체를 저장하는 객체
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
// 
// Associative Container - set, multi_set, map, multi_map
// set - 언제나 key를 compare로 정렬하고 있다. 찾기/추가/삭제가 O(log N)
//		- set의 주요 동작을 알아본다. (빨리 찾기 위한 컨테이너)
//		- 내가 만든 자료형(class Dog)을 set에 넣어 관리
//		- 중복되는 데이터를 하나로만 저장(multiset을 이용해야함)
//-----------------------------------------------------------------------------

#include <iostream>
#include <set>
#include <string>
#include <fstream>
#include "save.h"
#include "STRING.h"

//----
int main()
//----
{
	save("소스.cpp");

	std::ifstream in{ "소스.cpp" };
	std::multiset<std::string> s{ std::istream_iterator<std::string> {in}, {} };

	// [문제] 찾는 단어를 물어보고 찾아주자.
	while (true)
	{
		std::string str;
		std::cout << "찾는 단어는? ";

		if (std::cin >> str)
		{
			auto p = s.find(str);
			if (p != s.end())
				std::cout << "찾았습니다.\n";
			else
				std::cout << "없는 단어입니다.\n";
		}
		else
			break;
	}
	
}


파일이름: 소스.cpp
파일크기: 1175
저장시간: 2022-05-05 11:54:10 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 4일 목요일(10주 1일)
// 
//	컨테이너 - 다른 객체를 저장하는 객체
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
// 
// Associative Container - set, multi_set, map, multi_map
// set - 언제나 key를 compare로 정렬하고 있다. 찾기/추가/삭제가 O(log N)
//		- set의 주요 동작을 알아본다. (빨리 찾기 위한 컨테이너)
//		- 내가 만든 자료형(class Dog)을 set에 넣어 관리
//		- 중복되는 데이터를 하나로만 저장(multiset을 이용해야함)
//-----------------------------------------------------------------------------

#include <iostream>
#include <set>
#include <string>
#include <fstream>
#include "save.h"
#include "STRING.h"

//----
int main()
//----
{
	save("소스.cpp");

	std::ifstream in{ "소스.cpp" };
	std::multiset<std::string> s{ std::istream_iterator<std::string> {in}, {} };

	// [문제] 찾는 단어를 물어보고 찾아주자.
	while (true)
	{
		std::string str;
		std::cout << "찾는 단어는? ";

		if (std::cin >> str)
		{
			std::cout << std::boolalpha << s.contains(str) << std::endl;		// c++ 20
		}
		else
			break;
	}
	
}


파일이름: 소스.cpp
파일크기: 1787
저장시간: 2022-05-05 12:08:58 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 4일 목요일(10주 1일)
// 
//	컨테이너 - 다른 객체를 저장하는 객체
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
// 
// Associative Container - set, multi_set, map, multi_map
// set - 언제나 key를 compare로 정렬하고 있다. 찾기/추가/삭제가 O(log N)
//		- set의 주요 동작을 알아본다. (빨리 찾기 위한 컨테이너)
//		- 내가 만든 자료형(class Dog)을 set에 넣어 관리
//		- 중복되는 데이터를 하나로만 저장(multiset을 이용해야함)
//-----------------------------------------------------------------------------

#include <iostream>
#include <list>
#include <set>
#include <string>
#include <random>
#include "save.h"
#include "STRING.h"


std::default_random_engine dre;
std::uniform_int_distribution<int> uid{ 'a', 'z' };
std::uniform_int_distribution<int> uidN{ 1, 10000 };

class Dog {
	std::string name;
	int n;
public:
	Dog() {
		for (int i = 0; i < 10; ++i)
			name += uid(dre);
		n = uidN(dre);
	}

	void show() const {
		std::cout << name << " - " << n << std::endl;
	}
};

//----
int main()
//----
{
	save("소스.cpp");

	std::list<Dog> s;
	for (int i = 0; i < 1000; ++i)
		s.insert(s.begin(), Dog{});

	for (auto i = s.cbegin(); i != s.cend(); ++i)
		i->show();


	//// [문제] 찾는 단어를 물어보고 몇 개인지 알려주자.(multiset)
	//while (true)
	//{
	//	std::string str;
	//	std::cout << "찾는 단어는? ";

	//	std::cin >> str;
	//	auto [상한, 하한] = s.equal_range(str);		//	structured-binding
	//	
	//	if (int cnt = std::distance(하한, 상한)) {
	//		std::cout << str << " - " << cnt << "개 발견" << std::endl;
	//	}

	//	else
	//	{
	//		std::cout << "없는 단어입니다." << std::endl;
	//	}
	//}
}


파일이름: 소스.cpp
파일크기: 1500
저장시간: 2022-05-05 12:17:02 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 4일 목요일(10주 1일)
// 
//	컨테이너 - 다른 객체를 저장하는 객체
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
// 
// Associative Container - set, multi_set, map, multi_map
// set - 언제나 key를 compare로 정렬하고 있다. 찾기/추가/삭제가 O(log N)
//		- set의 주요 동작을 알아본다. (빨리 찾기 위한 컨테이너)
//		- 내가 만든 자료형(class Dog)을 set에 넣어 관리
//		- 중복되는 데이터를 하나로만 저장(multiset을 이용해야함)
//-----------------------------------------------------------------------------

#include <iostream>
#include <list>
#include <set>
#include <string>
#include <random>
#include "save.h"
#include "STRING.h"


std::default_random_engine dre;
std::uniform_int_distribution<int> uid{ 'a', 'z' };
std::uniform_int_distribution<int> uidN{ 1, 10000 };

class Dog {
	std::string name;
	int n;
public:
	Dog() {
		for (int i = 0; i < 10; ++i)
			name += uid(dre);
		n = uidN(dre);
	}

	void show() const {
		std::cout << name << " - " << n << std::endl;
	}
	
	friend class 기준;
};

class 기준 {
public:
	bool operator() (const Dog& a, const Dog& b) const{
		return a.name < b.name;
	}
};

//----
int main()
//----
{
	save("소스.cpp");

	std::set<Dog, 기준> s;		// 이름 오름차순 정렬하는 set
	for (int i = 0; i < 1000; ++i)
		s.insert(Dog{});

	for (auto i = s.cbegin(); i != s.cend(); ++i)
		i->show();

}


파일이름: 소스.cpp
파일크기: 1549
저장시간: 2022-05-05 12:19:26 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 4일 목요일(10주 1일)
// 
//	컨테이너 - 다른 객체를 저장하는 객체
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
// 
// Associative Container - set, multi_set, map, multi_map
// set - 언제나 key를 compare로 정렬하고 있다. 찾기/추가/삭제가 O(log N)
//		- set의 주요 동작을 알아본다. (빨리 찾기 위한 컨테이너)
//		- 내가 만든 자료형(class Dog)을 set에 넣어 관리
//		- 중복되는 데이터를 하나로만 저장(multiset을 이용해야함)
//-----------------------------------------------------------------------------

#include <iostream>
#include <list>
#include <set>
#include <string>
#include <random>
#include "save.h"
#include "STRING.h"


std::default_random_engine dre;
std::uniform_int_distribution<int> uid{ 'a', 'z' };
std::uniform_int_distribution<int> uidN{ 1, 10000 };

class Dog {
	std::string name;
	int n;
public:
	Dog() {
		for (int i = 0; i < 10; ++i)
			name += uid(dre);
		n = uidN(dre);
	}

	void show() const {
		std::cout << name << " - " << n << std::endl;
	}
	
	std::string getName() const{
		return name;
	}
};

class 정렬기준 {
public:
	bool operator() (const Dog& a, const Dog& b) const{
		return a.getName() < b.getName();
	};
};

//----
int main()
//----
{
	save("소스.cpp");

	std::set<Dog, 정렬기준> s;		// 이름 오름차순 정렬하는 set
	for (int i = 0; i < 1000; ++i)
		s.insert(Dog{});

	for (auto i = s.cbegin(); i != s.cend(); ++i)
		i->show();

}


파일이름: 소스.cpp
파일크기: 1645
저장시간: 2022-05-05 12:21:14 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 4일 목요일(10주 1일)
// 
//	컨테이너 - 다른 객체를 저장하는 객체
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
// 
// Associative Container - set, multi_set, map, multi_map
// set - 언제나 key를 compare로 정렬하고 있다. 찾기/추가/삭제가 O(log N)
//		- set의 주요 동작을 알아본다. (빨리 찾기 위한 컨테이너)
//		- 내가 만든 자료형(class Dog)을 set에 넣어 관리
//		- 중복되는 데이터를 하나로만 저장(multiset을 이용해야함)
//-----------------------------------------------------------------------------

#include <iostream>
#include <list>
#include <set>
#include <string>
#include <random>
#include "save.h"
#include "STRING.h"


std::default_random_engine dre;
std::uniform_int_distribution<int> uid{ 'a', 'z' };
std::uniform_int_distribution<int> uidN{ 1, 10000 };

class Dog {
	std::string name;
	int n;
public:
	Dog() {
		for (int i = 0; i < 10; ++i)
			name += uid(dre);
		n = uidN(dre);
	}

	void show() const {
		std::cout << name << " - " << n << std::endl;
	}
	
	std::string getName() const {
		return name;
	}

	int getN() const {
		return n;
	}
};

class 정렬기준 {
public:
	bool operator() (const Dog& a, const Dog& b) const{
		return a.getN() < b.getN();
	};
};

//----
int main()
//----
{
	save("소스.cpp");

	std::set<Dog, 정렬기준> s;		// n 기준 오름차순 정렬하는 set
	for (int i = 0; i < 1000; ++i)
		s.insert(Dog{});

	for (auto i = s.cbegin(); i != s.cend(); ++i)
		i->show();

	std::cout << "셋의 원소 수 - " << s.size() << std::endl;
}


파일이름: 소스.cpp
파일크기: 1650
저장시간: 2022-05-05 12:21:23 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 4일 목요일(10주 1일)
// 
//	컨테이너 - 다른 객체를 저장하는 객체
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
// 
// Associative Container - set, multi_set, map, multi_map
// set - 언제나 key를 compare로 정렬하고 있다. 찾기/추가/삭제가 O(log N)
//		- set의 주요 동작을 알아본다. (빨리 찾기 위한 컨테이너)
//		- 내가 만든 자료형(class Dog)을 set에 넣어 관리
//		- 중복되는 데이터를 하나로만 저장(multiset을 이용해야함)
//-----------------------------------------------------------------------------

#include <iostream>
#include <list>
#include <set>
#include <string>
#include <random>
#include "save.h"
#include "STRING.h"


std::default_random_engine dre;
std::uniform_int_distribution<int> uid{ 'a', 'z' };
std::uniform_int_distribution<int> uidN{ 1, 10000 };

class Dog {
	std::string name;
	int n;
public:
	Dog() {
		for (int i = 0; i < 10; ++i)
			name += uid(dre);
		n = uidN(dre);
	}

	void show() const {
		std::cout << name << " - " << n << std::endl;
	}
	
	std::string getName() const {
		return name;
	}

	int getN() const {
		return n;
	}
};

class 정렬기준 {
public:
	bool operator() (const Dog& a, const Dog& b) const{
		return a.getN() < b.getN();
	};
};

//----
int main()
//----
{
	save("소스.cpp");

	std::multiset<Dog, 정렬기준> s;		// n 기준 오름차순 정렬하는 set
	for (int i = 0; i < 1000; ++i)
		s.insert(Dog{});

	for (auto i = s.cbegin(); i != s.cend(); ++i)
		i->show();

	std::cout << "셋의 원소 수 - " << s.size() << std::endl;
}


파일이름: 소스.cpp
파일크기: 1651
저장시간: 2022-05-11 15:42:55 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 11일 목요일(10주 2일)
// 
//	컨테이너 - 다른 객체를 저장하는 객체
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
// 
// Associative Container - set, multi_set, map, multi_map
// set - 언제나 key를 compare로 정렬하고 있다. 찾기/추가/삭제가 O(log N)
//		- set의 주요 동작을 알아본다. (빨리 찾기 위한 컨테이너)
//		- 내가 만든 자료형(class Dog)을 set에 넣어 관리
//		- 중복되는 데이터를 하나로만 저장(multiset을 이용해야함)
//-----------------------------------------------------------------------------

#include <iostream>
#include <list>
#include <set>
#include <string>
#include <random>
#include "save.h"
#include "STRING.h"


std::default_random_engine dre;
std::uniform_int_distribution<int> uid{ 'a', 'z' };
std::uniform_int_distribution<int> uidN{ 1, 10000 };

class Dog {
	std::string name;
	int n;
public:
	Dog() {
		for (int i = 0; i < 10; ++i)
			name += uid(dre);
		n = uidN(dre);
	}

	void show() const {
		std::cout << name << " - " << n << std::endl;
	}
	
	std::string getName() const {
		return name;
	}

	int getN() const {
		return n;
	}
};

class 정렬기준 {
public:
	bool operator() (const Dog& a, const Dog& b) const{
		return a.getN() < b.getN();
	};
};

//----
int main()
//----
{
	save("소스.cpp");

	std::multiset<Dog, 정렬기준> s;		// n 기준 오름차순 정렬하는 set
	for (int i = 0; i < 1000; ++i)
		s.insert(Dog{});

	for (auto i = s.cbegin(); i != s.cend(); ++i)
		i->show();

	std::cout << "셋의 원소 수 - " << s.size() << std::endl;
}


파일이름: 소스.cpp
파일크기: 1994
저장시간: 2022-05-11 16:02:44 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 11일 목요일(10주 2일)
// 
//	컨테이너 - 다른 객체를 저장하는 객체
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
// 
// Associative Container - set, multi_set, map, multi_map
// set - 언제나 key를 compare로 정렬하고 있다. 찾기/추가/삭제가 O(log N)
//		- set의 주요 동작을 알아본다. (빨리 찾기 위한 컨테이너)
//		- 내가 만든 자료형(class Dog)을 set에 넣어 관리
//		- 중복되는 데이터를 하나로만 저장(multiset을 이용해야함)
//-----------------------------------------------------------------------------

#include <iostream>
#include <list>
#include <set>
#include <string>
#include <random>
#include "save.h"
#include "STRING.h"


std::default_random_engine dre;
std::uniform_int_distribution<int> uid{ 'a', 'z' };
std::uniform_int_distribution<int> uidN{ 1, 10000 };

class Dog {
	std::string name;
	int n;
public:
	Dog() {
		for (int i = 0; i < 10; ++i)
			name += uid(dre);
		n = uidN(dre);
	}

	bool operator<(const Dog& rhs) const {
		return n < rhs.n;
	}
	
	std::string getName() const {
		return name;
	}

	int getN() const {
		return n;
	}

	void show() const {
		std::cout << name << " - " << n << std::endl;
	}
};

class 정렬기준{
public:
	bool operator()(const Dog& a, const Dog& b) const{
		return a.getN() < b.getN();
	}
};

//----
int main()
//----
{
	save("소스.cpp");

	// set에 내가 만든 자료형 Dog 을 넣고 싶다.
	// 정렬기준 n 오름차순으로 항상 정렬하는 set을 만들고 싶다

	std::set<Dog, 정렬기준> s;
	for (int i = 0; i < 1000; ++i)
		s.emplace();	// 생성자 인자만 넘기면 됨

	for (const Dog& dog : s)
		dog.show();

	// 기준이 없다면?
	// 1. less<Dog>가  있나 살펴본다.
	// 2. class Dog이 < 연산자를 제공하나?
	// - 2.1 멤버 - 코딩가능하면 멤버로 만드는게 우선이다.
	// - 2.2 전역 - 멤버로 코딩하는게 곤란하면 만든다
	// 3. 기준을 직접 템플릿의 인자로 제공한다. decltype

}


파일이름: 소스.cpp
파일크기: 1970
저장시간: 2022-05-11 16:03:32 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 11일 목요일(10주 2일)
// 
//	컨테이너 - 다른 객체를 저장하는 객체
//		Sequence		-	임의의 원소의 값을 읽고 쓰거나 추가할 수 있다.
// 
// Associative Container - set, multi_set, map, multi_map
// set - 언제나 key를 compare로 정렬하고 있다. 찾기/추가/삭제가 O(log N)
//		- set의 주요 동작을 알아본다. (빨리 찾기 위한 컨테이너)
//		- 내가 만든 자료형(class Dog)을 set에 넣어 관리
//		- 중복되는 데이터를 하나로만 저장(multiset을 이용해야함)
//-----------------------------------------------------------------------------

#include <iostream>
#include <list>
#include <set>
#include <string>
#include <random>
#include "save.h"
#include "STRING.h"


std::default_random_engine dre;
std::uniform_int_distribution<int> uid{ 'a', 'z' };
std::uniform_int_distribution<int> uidN{ 1, 10000 };

class Dog {
	std::string name;
	int n;
public:
	Dog() {
		for (int i = 0; i < 10; ++i)
			name += uid(dre);
		n = uidN(dre);
	}

	bool operator<(const Dog& rhs) const {
		return n < rhs.n;
	}
	
	std::string getName() const {
		return name;
	}

	int getN() const {
		return n;
	}

	void show() const {
		std::cout << name << " - " << n << std::endl;
	}
};

auto 정렬기준 = [](const Dog& a, const Dog& b) {
	return a.getN() < b.getN();
};

//----
int main()
//----
{
	save("소스.cpp");

	// set에 내가 만든 자료형 Dog 을 넣고 싶다.
	// 정렬기준 n 오름차순으로 항상 정렬하는 set을 만들고 싶다

	std::set<Dog, decltype(정렬기준)> s;
	for (int i = 0; i < 1000; ++i)
		s.emplace();	// 생성자 인자만 넘기면 됨

	for (const Dog& dog : s)
		dog.show();

	// 기준이 없다면?
	// 1. less<Dog>가  있나 살펴본다.
	// 2. class Dog이 < 연산자를 제공하나?
	// - 2.1 멤버 - 코딩가능하면 멤버로 만드는게 우선이다.
	// - 2.2 전역 - 멤버로 코딩하는게 곤란하면 만든다
	// 3. 기준을 직접 템플릿의 인자로 제공한다. decltype

}


파일이름: 소스.cpp
파일크기: 894
저장시간: 2022-05-11 16:35:39 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 11일 목요일(10주 2일)
// 
// Associative Container - set, multi_set, map, multi_map
// 5/25(수) - 졸업연구설명회
// 15주차 수요일 기말시험 예정
//-----------------------------------------------------------------------------

#include <iostream>
#include <set>
#include <format>
#include "save.h"
#include "STRING.h"

class 길이순 {
public:
	bool operator()(const STRING& a, const STRING& b) const{
		return a.getNum() < b.getNum();
	}
};

//----
int main()
//----
{
	save("소스.cpp");

	// 키보드에서 입력한 단어를 set<STRING>에 넣어라
	// set<STRING>의 정렬기준은 단어길이 오름차순이다.
	// set을 화면출력하라.

	std::set<STRING, 길이순> s{ std::istream_iterator<STRING>{std::cin}, {} };

	for (const STRING& string : s)
		std::cout << string << "\n";
}


파일이름: 소스.cpp
파일크기: 1573
저장시간: 2022-05-11 17:05:18 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 11일 목요일(10주 2일)
// 
// Sequential - array, vector, deque, forwawrd_list, list
// Associative Container - set, multi_set, map, multi_map
// Unordered Associative - unordered_set, unordered_multiset, unordered_map
//							unoredered_multimap
// 
// map<key, value, key_compare>
// 
// C++ 20 Range
// => 코딩하면서 에러를 더 줄이기 위해
// 
// 5/25(수) - 졸업연구설명회(6교시 2:30 ~ 3:20)
//-----------------------------------------------------------------------------

#include <iostream>
#include <string>
#include <vector>
#include <map>
#include "save.h"
#include "STRING.h"

//----
int main()
//----
{
	save("소스.cpp");

	// key: 영화제목, value: 배우들

	std::map<std::string, std::vector<std::string>> movie;
	movie.insert({ "기생충", {"이선균", "조여정", "최우식", "박소담"} });

	std::pair<std::string, std::vector<std::string>>p{ "쇼생크탈출", {"팀로빈스"} };
	movie.insert(p);

	movie.insert(std::make_pair(std::string("메멘토"), std::vector<std::string>{ "가이피어스" }));

	// 현재 리스트 출력
	for (const std::pair<std::string, std::vector<std::string>>& m : movie){
		std::cout << m.first << " - ";
		for (const std::string& actor : m.second)
			std::cout << actor << " ";
		std::cout << std::endl;
	}
	
	// 영화제목을 입력받아 있으면 배우를 출력한다.
	while (true)
	{
		std::cout << "영화 제목을 입력해주세요: ";
		std::string title;
		std::cin >> title;

		auto p = movie.find(title);
	}
}


파일이름: 소스.cpp
파일크기: 1528
저장시간: 2022-05-11 17:07:09 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 11일 목요일(10주 2일)
// 
// Sequential - array, vector, deque, forwawrd_list, list
// Associative Container - set, multi_set, map, multi_map
// Unordered Associative - unordered_set, unordered_multiset, unordered_map
//							unoredered_multimap
// 
// map<key, value, key_compare>
// 
// C++ 20 Range
// => 코딩하면서 에러를 더 줄이기 위해
// 
// 5/25(수) - 졸업연구설명회(6교시 2:30 ~ 3:20)
//-----------------------------------------------------------------------------

#include <iostream>
#include <string>
#include <vector>
#include <map>
#include "save.h"
#include "STRING.h"

//----
int main()
//----
{
	save("소스.cpp");

	// key: 영화제목, value: 배우들

	std::map<std::string, std::vector<std::string>> movie;
	movie.insert({ "기생충", {"이선균", "조여정", "최우식", "박소담"} });

	std::pair<std::string, std::vector<std::string>>p{ "쇼생크탈출", {"팀로빈스"} };
	movie.insert(p);

	movie.insert(std::make_pair(std::string("메멘토"), std::vector<std::string>{ "가이피어스" }));

	// 현재 리스트 출력
	for (const auto& [제목, 배우들] : movie){
		std::cout << 제목 << " - ";
		for (const auto& 배우 : 배우들)
			std::cout << 배우 << " ";
		std::cout << std::endl;
	}
	
	// 영화제목을 입력받아 있으면 배우를 출력한다.
	while (true)
	{
		std::cout << "영화 제목을 입력해주세요: ";
		std::string title;
		std::cin >> title;

		auto p = movie.find(title);
	}
}


파일이름: 소스.cpp
파일크기: 1780
저장시간: 2022-05-11 17:14:25 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 11일 목요일(10주 2일)
// 
// Sequential - array, vector, deque, forwawrd_list, list
// Associative Container - set, multi_set, map, multi_map
// Unordered Associative - unordered_set, unordered_multiset, unordered_map
//							unoredered_multimap
// 
// map<key, value, key_compare>
// 
// C++ 20 Range
// => 코딩하면서 에러를 더 줄이기 위해
// 
// 5/25(수) - 졸업연구설명회(6교시 2:30 ~ 3:20)
//-----------------------------------------------------------------------------

#include <iostream>
#include <string>
#include <vector>
#include <map>
#include "save.h"
#include "STRING.h"

//----
int main()
//----
{
	save("소스.cpp");

	// key: 영화제목, value: 배우들

	std::map<std::string, std::vector<std::string>> movie;
	movie.insert({ "기생충", {"이선균", "조여정", "최우식", "박소담"} });

	std::pair<std::string, std::vector<std::string>>p{ "쇼생크탈출", {"팀로빈스"} };
	movie.insert(p);

	movie.insert(std::make_pair(std::string("메멘토"), std::vector<std::string>{ "가이피어스" }));

	// 현재 리스트 출력
	for (const auto& [제목, 배우들] : movie){
		std::cout << 제목 << " - ";
		for (const auto& 배우 : 배우들)
			std::cout << 배우 << " ";
		std::cout << std::endl;
	}
	
	// 영화제목을 입력받아 있으면 배우를 출력한다.
	while (true)
	{
		std::cout << "영화 제목을 입력해주세요: ";
		std::string title;
		std::cin >> title;

		auto p = movie.find(title);
		if (p != movie.end())
		{
			const auto& [제목, 배우들] = *p;
			std::cout << 제목 << " - ";
			for (const auto& 배우 : 배우들)
				std::cout << 배우 << " ";
			std::cout << std::endl;
		}

		else
			std::cout << "없습니다." << std::endl;
	}
}


파일이름: 소스.cpp
파일크기: 843
저장시간: 2022-05-12 10:38:59 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 11일 목요일(10주 2일)
// 
// Associative Container - set, multi_set, map, multi_map
// 
// map<key, value, key_compare>
//		- 연관배열(associative array)로 사용할 수 있다.
// 
// => 코딩하면서 에러를 더 줄이기 위해
// 
// 5/25(수) - 졸업연구설명회(6교시 2:30 ~ 3:20)
//-----------------------------------------------------------------------------

#include <iostream>
#include <string>
#include <map>
#include "save.h"
#include "STRING.h"

//----
int main()
//----
{
	save("소스.cpp");

	// 이름과 전화번호
	std::map<std::string, std::string> m;
	m.insert(std::pair("홍길동", "01012345678"));
	m["마우스"] = "12345678";
	for (auto [이름, 번호] : m)
		std::cout << 이름 << " - " << 번호 << std::endl;



}


파일이름: 소스.cpp
파일크기: 1204
저장시간: 2022-05-12 10:44:37 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 12일 목요일(11주 1일)
// 
// Associative Container - set, multi_set, map, multi_map
// 
// map<key, value, key_compare>
//		- 연관배열(associative array)로 사용할 수 있다.
// 
// => 코딩하면서 에러를 더 줄이기 위해
// 
// 5/25(수) - 졸업연구설명회(6교시 2:30 ~ 3:20)
//-----------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <map>
#include "save.h"
#include "STRING.h"

//----
int main()
//----
{
	save("소스.cpp");

	// 이름과 전화번호
	std::map<std::string, std::string> m;
	m.insert(std::pair("홍길동", "01012345678"));
	m["마우스"] = "12345678";
	for (auto [이름, 번호] : m)
		std::cout << 이름 << " - " << 번호 << std::endl;

	// [문제] e-class에서 frankenstein.txt를 다운받아라.
	// 파일을 읽어 std::vector<string>에 저장한 후 모두 몇 단어인지 화면에 출력하라.

	std::ifstream in{ "Frankenstein.txt" };
	std::vector<std::string> v{ std::istream_iterator<std::string> {in}, {} };

	std::cout << "총 " << v.size() << "단어 입니다." << std::endl;
}


파일이름: 소스.cpp
파일크기: 1204
저장시간: 2022-05-12 10:44:46 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 12일 목요일(11주 1일)
// 
// Associative Container - set, multi_set, map, multi_map
// 
// map<key, value, key_compare>
//		- 연관배열(associative array)로 사용할 수 있다.
// 
// => 코딩하면서 에러를 더 줄이기 위해
// 
// 5/25(수) - 졸업연구설명회(6교시 2:30 ~ 3:20)
//-----------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <map>
#include "save.h"
#include "STRING.h"

//----
int main()
//----
{
	save("소스.cpp");

	// 이름과 전화번호
	std::map<std::string, std::string> m;
	m.insert(std::pair("홍길동", "01012345678"));
	m["마우스"] = "12345678";
	for (auto [이름, 번호] : m)
		std::cout << 이름 << " - " << 번호 << std::endl;

	// [문제] e-class에서 frankenstein.txt를 다운받아라.
	// 파일을 읽어 std::vector<string>에 저장한 후 모두 몇 단어인지 화면에 출력하라.

	std::ifstream in{ "Frankenstein.txt" };
	std::vector<std::string> v{ std::istream_iterator<std::string> {in}, {} };

	std::cout << "총 " << v.size() << "단어 입니다." << std::endl;
}


파일이름: 소스.cpp
파일크기: 1290
저장시간: 2022-05-12 10:49:26 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 12일 목요일(11주 1일)
// 
// Associative Container - set, multi_set, map, multi_map
// 
// map<key, value, key_compare>
//		- 연관배열(associative array)로 사용할 수 있다.
// 
// => 코딩하면서 에러를 더 줄이기 위해
// 
// 5/25(수) - 졸업연구설명회(6교시 2:30 ~ 3:20)
//-----------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <map>
#include "save.h"
#include "STRING.h"

//----
int main()
//----
{
	save("소스.cpp");

	// 이름과 전화번호
	std::map<std::string, std::string> m;
	m.insert(std::pair("홍길동", "01012345678"));
	m["마우스"] = "12345678";
	for (auto [이름, 번호] : m)
		std::cout << 이름 << " - " << 번호 << std::endl;

	// [문제] e-class에서 frankenstein.txt를 다운받아라.
	// 파일을 읽어 std::vector<string>에 저장한 후 모두 몇 단어인지 화면에 출력하라.

	std::ifstream in{ "Frankenstein.txt" };
	std::vector<std::string> v{ std::istream_iterator<std::string> {in}, {} };

	for (const std::string& s : v)
		std::cout << s << " ";
	std::cout<<std::endl;
	std::cout << "총 " << v.size() << "단어 입니다." << std::endl;

}


파일이름: 소스.cpp
파일크기: 2569
저장시간: 2022-05-12 11:16:49 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 12일 목요일(11주 1일)
// 
// Associative Container - set, multi_set, map, multi_map
// 
// map<key, value, key_compare>
//		- 연관배열(associative array)로 사용할 수 있다.
// 
// => 코딩하면서 에러를 더 줄이기 위해
// 
// 5/25(수) - 졸업연구설명회(6교시 2:30 ~ 3:20)
//-----------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <algorithm>
#include <vector>
#include <string>
#include <map>
#include "save.h"
#include "STRING.h"

//----
int main()
//----
{
	save("소스.cpp");

	// 이름과 전화번호
	std::map<std::string, std::string> m;
	m.insert(std::pair("홍길동", "01012345678"));
	m["마우스"] = "12345678";
	for (auto [이름, 번호] : m)
		std::cout << 이름 << " - " << 번호 << std::endl;

	// [문제] e-class에서 frankenstein.txt를 다운받아라.
	// 파일을 읽어 std::vector<string>에 저장한 후 모두 몇 단어인지 화면에 출력하라.

	std::ifstream in{ "Frankenstein.txt" };
	std::vector<std::string> v{ std::istream_iterator<std::string> {in}, {} };

	std::cout << "총 " << v.size() << "단어 입니다." << std::endl;

	std::cout << "가장 긴 단어는 " << *std::max_element(v.begin(), v.end(), [](const std::string& a, const std::string& b) { return a.length() < b.length(); }) 
		<< "입니다" << std::endl;

	// [문제] 이 소설에서 각 소문자의 갯수를 세서 출력하라.
	std::map<char, int> alphanum;
	for (const std::string& s : v)
	{
		for (char c : s)
		{
			if (islower(c))
				alphanum[c]++;
		}
	}

	// 결과 출력
	for (auto [소문자, 갯수] : alphanum)
		std::cout << "[" << 소문자 << "] - " << 갯수 << std::endl;

	alphanum.begin();
	// [문제] 갯수 기준 내림차순으로 출력하라
	std::cout << "==================================================================" << std::endl;
	std::map<int, char, std::greater<int>> ic;
	for (auto [소문자, 갯수] : alphanum)
		ic[갯수] = 소문자;
	
	for (auto [갯수, 소문자] : ic)
		std::cout << "[" << 소문자 << "] - " << 갯수 << std::endl;

	std::vector<std::pair<char, int>> tmpV{ std::map<char, int>::iterator {alphanum.begin()},  std::map<char, int>::iterator {alphanum.end()} };
	std::sort(tmpV.begin(), tmpV.end(), [](std::pair<char, int>& a, std::pair<char, int>& b) {return a.second > b.second; });
	std::cout << "==================================================================" << std::endl;
	for (auto [소문자, 갯수] : tmpV)
		std::cout << "[" << 소문자 << "] - " << 갯수 << std::endl;
}


파일이름: 소스.cpp
파일크기: 2485
저장시간: 2022-05-12 11:23:23 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 12일 목요일(11주 1일)
// 
// Associative Container - set, multi_set, map, multi_map
// 
// map<key, value, key_compare>
//		- 연관배열(associative array)로 사용할 수 있다.
// 
// => 코딩하면서 에러를 더 줄이기 위해
// 
// 5/25(수) - 졸업연구설명회(6교시 2:30 ~ 3:20)
//-----------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <algorithm>
#include <vector>
#include <string>
#include <map>
#include "save.h"
#include "STRING.h"

//----
int main()
//----
{
	save("소스.cpp");

	// 이름과 전화번호
	std::map<std::string, std::string> m;
	m.insert(std::pair("홍길동", "01012345678"));
	m["마우스"] = "12345678";
	for (auto [이름, 번호] : m)
		std::cout << 이름 << " - " << 번호 << std::endl;

	// [문제] e-class에서 frankenstein.txt를 다운받아라.
	// 파일을 읽어 std::vector<string>에 저장한 후 모두 몇 단어인지 화면에 출력하라.

	std::ifstream in{ "Frankenstein.txt" };
	std::vector<std::string> v{ std::istream_iterator<std::string> {in}, {} };

	std::cout << "총 " << v.size() << "단어 입니다." << std::endl;

	std::cout << "가장 긴 단어는 " << *std::max_element(v.begin(), v.end(), [](const std::string& a, const std::string& b) { return a.length() < b.length(); }) 
		<< "입니다" << std::endl;

	// [문제] 이 소설에서 각 소문자의 갯수를 세서 출력하라.
	std::map<char, int> alphanum;
	for (const std::string& s : v)
	{
		for (char c : s)
		{
			if (islower(c))
				alphanum[c]++;
		}
	}

	// 결과 출력
	for (auto [소문자, 갯수] : alphanum)
		std::cout << "[" << 소문자 << "] - " << 갯수 << std::endl;

	alphanum.begin();
	// [문제] 갯수 기준 내림차순으로 출력하라
	std::cout << "==================================================================" << std::endl;
	std::map<int, char, std::greater<int>> ic;
	for (auto [소문자, 갯수] : alphanum)
		ic[갯수] = 소문자;
	
	for (auto [갯수, 소문자] : ic)
		std::cout << "[" << 소문자 << "] - " << 갯수 << std::endl;

	std::vector<std::pair<char, int>> 벡터{ alphanum.begin(),  alphanum.end() };
	std::sort(벡터.begin(), 벡터.end(), [](const auto& a, const auto& b) {return a.second > b.second; });
	std::cout << "==================================================================" << std::endl;
	for (auto [소문자, 갯수] : 벡터)
		std::cout << "[" << 소문자 << "] - " << 갯수 << std::endl;
}


파일이름: 소스.cpp
파일크기: 1774
저장시간: 2022-05-12 11:43:28 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 12일 목요일(11주 1일)
// 
// Associative Container - set, multi_set, map, multi_map
// 
// map<key, value, key_compare>
//		- 연관배열(associative array)로 사용할 수 있다.
// 
// => 코딩하면서 에러를 더 줄이기 위해
// 
// 5/25(수) - 졸업연구설명회(6교시 2:30 ~ 3:20)
//-----------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <algorithm>
#include <vector>
#include <string>
#include <map>
#include "save.h"
#include "STRING.h"

//----
int main()
//----
{
	save("소스.cpp");

	// 이름과 전화번호
	std::map<std::string, std::string> m;
	m.insert(std::pair("홍길동", "01012345678"));
	m["마우스"] = "12345678";
	for (auto [이름, 번호] : m)
		std::cout << 이름 << " - " << 번호 << std::endl;

	// [문제] e-class에서 frankenstein.txt를 다운받아라.
	// 파일을 읽어 std::vector<string>에 저장한 후 모두 몇 단어인지 화면에 출력하라.

	std::ifstream in{ "Frankenstein.txt" };
	std::vector<std::string> v{ std::istream_iterator<std::string> {in}, {} };

	std::cout << "총 " << v.size() << "단어 입니다." << std::endl;
	
	// [문제] 가장 많이 사용된 단어 순으로 출력하라.
	std::map<std::string, int> simap;
	for (const std::string& s : v)
		simap[s]++;

	std::map<int, std::string, std::greater<int>> ismap;
	for (const auto& [단어, 숫자] : simap)
		ismap[숫자] = 단어;

	//// 다 출력
	//for (const auto& [숫자, 단어] : ismap)
	//	std::cout << "[ " << 단어 << " ] - " << 숫자 << std::endl;

	// 20개만 출력
	auto p = ismap.begin();
	for (int i = 0; i < 20; ++i)
	{
		std::cout << "[ " << p->second << " ] - " << p->first << std::endl;
		++p;
	}

}


파일이름: 소스.cpp
파일크기: 2017
저장시간: 2022-05-12 11:56:45 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 12일 목요일(11주 1일)
// 
// Associative Container - set, multi_set, map, multi_map
// 
// map<key, value, key_compare>
//		- 연관배열(associative array)로 사용할 수 있다.
// 
// => 코딩하면서 에러를 더 줄이기 위해
// 
// 5/25(수) - 졸업연구설명회(6교시 2:30 ~ 3:20)
//-----------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <algorithm>
#include <vector>
#include <string>
#include <map>
#include "save.h"
#include "STRING.h"

//----
int main()
//----
{
	save("소스.cpp");

	// 이름과 전화번호
	std::map<std::string, std::string> m;
	m.insert(std::pair("홍길동", "01012345678"));
	m["마우스"] = "12345678";
	for (auto [이름, 번호] : m)
		std::cout << 이름 << " - " << 번호 << std::endl;

	// [문제] e-class에서 frankenstein.txt를 다운받아라.
	// 파일을 읽어 std::vector<string>에 저장한 후 모두 몇 단어인지 화면에 출력하라.

	std::ifstream in{ "Frankenstein.txt" };
	std::vector<std::string> v{ std::istream_iterator<std::string> {in}, {} };

	std::cout << "총 " << v.size() << "단어 입니다." << std::endl;
	// v - 75041

	// [문제] 가장 많이 사용된 단어 순으로 출력하라.
	std::map<std::string, int> simap;
	for (const std::string& s : v)
		simap[s]++;

	int num = 0;
	// [문제] 검증해보자.
	for (const auto& [단어, 숫자] : simap)
		num += 숫자;
	// simap - 75041
	std::cout << "총 " << num << "단어입니다." << std::endl;
	
	std::multimap<int, std::string, std::greater<int>> ismap;
	for (const auto& [단어, 숫자] : simap)
		ismap.insert({ 숫자, 단어 });

	
	// 뒤에서 20개만 출력
	auto p = ismap.begin();
	for (int i = 0; i < 20; ++i)
	{
		std::cout << "[" << p->second << "] - " << p->first << std::endl;
		++p;
	}

	num = 0;
	// [문제] 검증해보자.
	for (const auto& [숫자, 단어] : ismap)
		num += 숫자;

	std::cout << "총 " << num << "단어입니다." << std::endl;
}


파일이름: 소스.cpp
파일크기: 1206
저장시간: 2022-05-12 12:03:56 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 12일 목요일(11주 1일)
// 
// Associative Container - set, multi_set, map, multi_map
// 
// map<key, value, key_compare>
//		- 연관배열(associative array)로 사용할 수 있다.
// 
// => 코딩하면서 에러를 더 줄이기 위해
// 
// 5/25(수) - 졸업연구설명회(6교시 2:30 ~ 3:20)
//-----------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <algorithm>
#include <vector>
#include <string>
#include <map>
#include "save.h"
#include "STRING.h"

//----
int main()
//----
{
	save("소스.cpp");
	
	// [문제] e-class에서 frankenstein.txt를 다운받아라.
	// 파일을 읽어 std::vector<string>에 저장한 후 모두 몇 단어인지 화면에 출력하라.

	std::ifstream in{ "Frankenstein.txt" };
	std::vector<std::string> v{ std::istream_iterator<std::string> {in}, {} };

	std::cout << "총 " << v.size() << "단어 입니다." << std::endl;

	// 길이가 10글자인 단어만 화면에 출력하라.
	std::copy_if(v.begin(), v.end(), std::ostream_iterator<std::string> {std::cout, "\n"},
		[](const std::string& s) {
		return s.length() == 16;
	});
}


파일이름: 소스.cpp
파일크기: 1090
저장시간: 2022-05-12 12:13:55 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 12일 목요일(11주 1일)
// 
// Associative Container - set, multi_set, map, multi_map
// 
// map<key, value, key_compare>
//		- 연관배열(associative array)로 사용할 수 있다.
// 
// => 코딩하면서 에러를 더 줄이기 위해
// 
// 5/25(수) - 졸업연구설명회(6교시 2:30 ~ 3:20)
//-----------------------------------------------------------------------------

#include <iostream>
#include <map>
#include <array>
#include <random>
#include "save.h"
#include "STRING.h"

std::array<int, 1000'0000> a;
std::default_random_engine dre;
std::uniform_int_distribution uid{1, 1000'0000};
//----
int main()
//----
{
	save("소스.cpp");
	
	//[문제] 유니폼분포가 진짜 유니폼하냐?
	// 결과를 출력해서 알아본다.
	
	for (int& n : a)
		n = uid(dre);
	
	// 이때 a의 값을 10구간으로 나누어 갯수를 센후 출력하라
	std::map<int, int> iimap;
	for (int n : a)
		iimap[n / 100'000]++;

	for (auto [구간, 갯수] : iimap)
	{
		std::cout << 구간 << " - " << 갯수 << std::endl;
	}
}


파일이름: 소스.cpp
파일크기: 1100
저장시간: 2022-05-18 15:37:09 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 18일 목요일(11주 2일)
// 
// Unoredered Associative Container - set, multi_set, map, multi_map
//	- 어떻게 메모리가 구성되어 있나? - 그림으로 알아본다.
//  - 내가 만든 STRING이 순서 없는 set의 원소가 되려면?
// 
// 컨테이너의 찾기 실력 비교 - vector / set /  unordered_set
// 5/25(수) - 졸업연구설명회(6교시 2:30 ~ 3:20)
//-----------------------------------------------------------------------------

#include <iostream>
#include <unordered_set>
#include "save.h"
#include "STRING.h"

//--- 

//----
int main()
//----
{
	save("소스.cpp");
	std::unordered_set<int> us{ 1,3,2,4 };
	for (int n : us)
		std::cout << n << " ";
	std::cout << std::endl;

	us.insert(-1);
	std::cout << "=============================================\n";

	for (int n : us)
		std::cout << n << " ";
	std::cout << std::endl;

	us.insert(100);
	std::cout << "=============================================\n";

	for (int n : us)
		std::cout << n << " ";
	std::cout << std::endl;

}


파일이름: 소스.cpp
파일크기: 967
저장시간: 2022-05-18 15:48:56 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 18일 목요일(11주 2일)
// 
// Unoredered Associative Container - set, multi_set, map, multi_map
//	- 어떻게 메모리가 구성되어 있나? - 그림으로 알아본다.
//  - 내가 만든 STRING이 순서 없는 set의 원소가 되려면?
// 
// 컨테이너의 찾기 실력 비교 - vector / set /  unordered_set
// 5/25(수) - 졸업연구설명회(6교시 2:30 ~ 3:20)
//-----------------------------------------------------------------------------

#include <iostream>
#include <unordered_set>
#include "save.h"
#include "STRING.h"

//
//

//----
int main()
//----
{
	save("소스.cpp");
	std::unordered_set<int> us{ 1,3,2,4 };		//일 대 일 대응하게 만드는게 제일 빨리 원소를 찾는 방법, 해시함수(hasher), bucket, rehashing
	
	while (true){
		// 메모리 내용 출력
		for (int i = 0; i < us.bucket_count(); ++i)
			std::cout << "[" << i << "] " << std::endl;
		
		// 원소 추가
	}

}


파일이름: 소스.cpp
파일크기: 1180
저장시간: 2022-05-18 15:53:22 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 18일 목요일(11주 2일)
// 
// Unoredered Associative Container - set, multi_set, map, multi_map
//	- 어떻게 메모리가 구성되어 있나? - 그림으로 알아본다.
//  - 내가 만든 STRING이 순서 없는 set의 원소가 되려면?
// 
// 컨테이너의 찾기 실력 비교 - vector / set /  unordered_set
// 5/25(수) - 졸업연구설명회(6교시 2:30 ~ 3:20)
//-----------------------------------------------------------------------------

#include <iostream>
#include <unordered_set>
#include "save.h"
#include "STRING.h"

//
//

//----
int main()
//----
{
	save("소스.cpp");
	std::unordered_set<int> us{ 1,3,2,4 };		//일 대 일 대응하게 만드는게 제일 빨리 원소를 찾는 방법, 해시함수(hasher), bucket, rehashing
	
	while (true){
		// 메모리 내용 출력
		for (int i = 0; i < us.bucket_count(); ++i) {
			std::cout << "[" << i << "]";
			for (auto p = us.begin(i); p != us.end(i); ++p)
				std::cout << " -> " << *p;
			std::cout << std::endl;
		}
		std::cout << std::endl;
		// 원소 추가
		int num;
		std::cout << "추가할 int는? ";
		std::cin >> num;
		us.insert(num);
	}

}


파일이름: 소스.cpp
파일크기: 1185
저장시간: 2022-05-18 15:55:10 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 18일 목요일(11주 2일)
// 
// Unoredered Associative Container - set, multi_set, map, multi_map
//	- 어떻게 메모리가 구성되어 있나? - 그림으로 알아본다.
//  - 내가 만든 STRING이 순서 없는 set의 원소가 되려면?
// 
// 컨테이너의 찾기 실력 비교 - vector / set /  unordered_set
// 5/25(수) - 졸업연구설명회(6교시 2:30 ~ 3:20)
//-----------------------------------------------------------------------------

#include <iostream>
#include <unordered_set>
#include "save.h"
#include "STRING.h"

//
//

//----
int main()
//----
{
	save("소스.cpp");
	std::unordered_multiset<int> us{ 1,3,2,4 };		//일 대 일 대응하게 만드는게 제일 빨리 원소를 찾는 방법, 해시함수(hasher), bucket, rehashing
	
	while (true){
		// 메모리 내용 출력
		for (int i = 0; i < us.bucket_count(); ++i) {
			std::cout << "[" << i << "]";
			for (auto p = us.begin(i); p != us.end(i); ++p)
				std::cout << " -> " << *p;
			std::cout << std::endl;
		}
		std::cout << std::endl;
		// 원소 추가
		int num;
		std::cout << "추가할 int는? ";
		std::cin >> num;
		us.insert(num);
	}

}


파일이름: 소스.cpp
파일크기: 1509
저장시간: 2022-05-18 16:14:36 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 18일 목요일(11주 2일)
// 
// Unoredered Associative Container - set, multi_set, map, multi_map
//	- 어떻게 메모리가 구성되어 있나? - 그림으로 알아본다.
//  - 내가 만든 STRING이 순서 없는 set의 원소가 되려면?
// 
// 컨테이너의 찾기 실력 비교 - vector / set /  unordered_set
// 5/25(수) - 졸업연구설명회(6교시 2:30 ~ 3:20)
//-----------------------------------------------------------------------------

#include <iostream>
#include <string>
#include <unordered_set>
#include "save.h"
#include "STRING.h"

//
// using namespace std;
//

// 템플릿의 특수화
template <>
class std::hash<STRING> {
public:
	size_t operator()(const STRING& str) const {
		auto val = std::hash<std::string>()({ str.begin(), str.end() });
		std::cout << "해셔의 출력 - " << val << ", 메모리 위치 - " 
			<< val % 8 << std::endl;	// 모듈레이션
		return val;
	};
};


//----
int main()
//----
{
	save("소스.cpp");
	std::unordered_multiset<STRING, std::hash<STRING>> us{ "Standard", "Template", "Library" };

	
	while (true){
		// 메모리 내용 출력
		for (int i = 0; i < us.bucket_count(); ++i) {
			std::cout << "[" << i << "]";
			for (auto p = us.begin(i); p != us.end(i); ++p)
				std::cout << " -> " << *p;
			std::cout << std::endl;
		}
		std::cout << std::endl;
		// 원소 추가
		STRING str;
		std::cout << "추가할 STRING는? ";
		std::cin >> str;
		us.insert(str);
	}

}


파일이름: 소스.cpp
파일크기: 1807
저장시간: 2022-05-18 16:44:32 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 18일 목요일(11주 2일)
// 
// 컨테이너의 찾기 실력 비교 - vector/ set/ unordered_set
// int 1000'0000개에서 int 1'000개가 있는지 확인
// 
// 컨테이너의 찾기 실력 비교 - vector / set /  unordered_set
// 5/25(수) - 졸업연구설명회(6교시 2:30 ~ 3:20)
//-----------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <vector>
#include <set>
#include <algorithm>
#include <random>
#include <chrono>
#include "save.h"
#include "STRING.h"

//
// using namespace std;
//

// 정수 1000만개 저장할 메모리
std::array<int, 1000'0000> numbers;

// 컨테이너에 있는지 찾아볼 int 값들
std::array<int, 10000> toFind;

std::default_random_engine dre;
std::uniform_int_distribution<int> uid{ 1, 1'0000'0000 };

//----
int main()
//----
{
	save("소스.cpp");
	
	// 1000만개의 random int
	for (int& n : numbers)
		n = uid(dre);
	
	// 찾아야할 int
	for (int& n : toFind)
		n = uid(dre);

	
	{	// 벡터의 찾기 실력을 알아본다.
		std::vector<int> v{ numbers.begin(), numbers.end() };
		
		std::cout << "벡터의 원소 수 - " << v.size() << std::endl;

		// 시간 재기 시작
		int cnt{};
		auto start = std::chrono::steady_clock::now();
		for (int n : toFind)
		{
			auto p = std::find(v.begin(), v.end(), n);
			if (p != v.end())
				cnt++;
		}
		auto stop = std::chrono::steady_clock::now();
		// 시간 재기 끝

		auto et = std::chrono::duration_cast<std::chrono::microseconds>(stop - start).count();
		std::cout << "걸린 시간 - " << et << "μs" << std::endl;
		std::cout << "찾아야 할 int 개수 - " << toFind.size() << std::endl;
		std::cout << cnt << std::endl << std::endl;
	}
	std::cout << "끝\n";
}


파일이름: 소스.cpp
파일크기: 2445
저장시간: 2022-05-18 16:47:38 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 18일 목요일(11주 2일)
// 
// 컨테이너의 찾기 실력 비교 - vector/ set/ unordered_set
// int 1000'0000개에서 int 1'000개가 있는지 확인
// 
// 컨테이너의 찾기 실력 비교 - vector / set /  unordered_set
// 5/25(수) - 졸업연구설명회(6교시 2:30 ~ 3:20)
//-----------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <vector>
#include <set>
#include <algorithm>
#include <random>
#include <chrono>
#include "save.h"
#include "STRING.h"

//
// using namespace std;
//

// 정수 1000만개 저장할 메모리
std::array<int, 1000'0000> numbers;

// 컨테이너에 있는지 찾아볼 int 값들
std::array<int, 1000> toFind;

std::default_random_engine dre;
std::uniform_int_distribution<int> uid{ 1, 1'0000'0000 };

//----
int main()
//----
{
	save("소스.cpp");
	
	// 1000만개의 random int
	for (int& n : numbers)
		n = uid(dre);
	
	// 찾아야할 int
	for (int& n : toFind)
		n = uid(dre);

	
	{	// 벡터의 찾기 실력을 알아본다.
		std::vector<int> v{ numbers.begin(), numbers.end() };
		
		std::cout << "벡터의 원소 수 - " << v.size() << std::endl;

		// 시간 재기 시작
		int cnt{};
		auto start = std::chrono::steady_clock::now();
		for (int n : toFind)
		{
			auto p = std::find(v.begin(), v.end(), n);
			if (p != v.end())
				cnt++;
		}
		auto stop = std::chrono::steady_clock::now();
		// 시간 재기 끝

		auto et = std::chrono::duration_cast<std::chrono::microseconds>(stop - start).count();
		std::cout << "걸린 시간 O(n) - " << et << "μs" << std::endl;
		std::cout << "찾아야 할 int 개수 - " << toFind.size() << std::endl;
		std::cout << cnt << std::endl << std::endl;
	}

	{	// 셋의 찾기 실력을 알아본다.
		std::set<int> s{ numbers.begin(), numbers.end() };

		std::cout << "셋의 원소 수 - " << s.size() << std::endl;

		// 시간 재기 시작
		int cnt{};
		auto start = std::chrono::steady_clock::now();
		for (int n : toFind)
		{
			if (s.contains(n))
				++cnt;
		}
		auto stop = std::chrono::steady_clock::now();
		// 시간 재기 끝

		auto et = std::chrono::duration_cast<std::chrono::microseconds>(stop - start).count();
		std::cout << "걸린 시간 O(log n) - " << et << "μs" << std::endl;
		std::cout << "셋에서 찾은 개수 - " << toFind.size() << std::endl;
		std::cout << cnt << std::endl << std::endl;
	}
}


파일이름: 소스.cpp
파일크기: 3161
저장시간: 2022-05-18 16:49:41 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 18일 목요일(11주 2일)
// 
// 컨테이너의 찾기 실력 비교 - vector/ set/ unordered_set
// int 1000'0000개에서 int 1'000개가 있는지 확인
// 
// 컨테이너의 찾기 실력 비교 - vector / set /  unordered_set
// 5/25(수) - 졸업연구설명회(6교시 2:30 ~ 3:20)
//-----------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <vector>
#include <set>
#include <unordered_set>
#include <algorithm>
#include <random>
#include <chrono>
#include "save.h"
#include "STRING.h"

//
// using namespace std;
//

// 정수 1000만개 저장할 메모리
std::array<int, 1000'0000> numbers;

// 컨테이너에 있는지 찾아볼 int 값들
std::array<int, 1000> toFind;

std::default_random_engine dre;
std::uniform_int_distribution<int> uid{ 1, 1'0000'0000 };

//----
int main()
//----
{
	save("소스.cpp");
	
	// 1000만개의 random int
	for (int& n : numbers)
		n = uid(dre);
	
	// 찾아야할 int
	for (int& n : toFind)
		n = uid(dre);

	
	{	// 벡터의 찾기 실력을 알아본다.
		std::vector<int> v{ numbers.begin(), numbers.end() };
		
		std::cout << "벡터의 원소 수 - " << v.size() << std::endl;

		// 시간 재기 시작
		int cnt{};
		auto start = std::chrono::steady_clock::now();
		for (int n : toFind)
		{
			auto p = std::find(v.begin(), v.end(), n);
			if (p != v.end())
				cnt++;
		}
		auto stop = std::chrono::steady_clock::now();
		// 시간 재기 끝

		auto et = std::chrono::duration_cast<std::chrono::microseconds>(stop - start).count();
		std::cout << "걸린 시간 O(n) - " << et << "μs" << std::endl;
		std::cout << "찾아야 할 int 개수 - " << toFind.size() << std::endl;
		std::cout << cnt << std::endl << std::endl;
	}

	{	// 셋의 찾기 실력을 알아본다.
		std::set<int> s{ numbers.begin(), numbers.end() };

		std::cout << "셋의 원소 수 - " << s.size() << std::endl;

		// 시간 재기 시작
		int cnt{};
		auto start = std::chrono::steady_clock::now();
		for (int n : toFind)
		{
			if (s.contains(n))
				++cnt;
		}
		auto stop = std::chrono::steady_clock::now();
		// 시간 재기 끝

		auto et = std::chrono::duration_cast<std::chrono::microseconds>(stop - start).count();
		std::cout << "걸린 시간 O(log n) - " << et << "μs" << std::endl;
		std::cout << "셋에서 찾은 개수 - " << toFind.size() << std::endl;
		std::cout << cnt << std::endl << std::endl;
	}

	{	// 언오더드셋의 찾기 실력을 알아본다.
		std::unordered_set<int> us{ numbers.begin(), numbers.end() };

		std::cout << "언오더드셋의 원소 수 - " << us.size() << std::endl;

		// 시간 재기 시작
		int cnt{};
		auto start = std::chrono::steady_clock::now();
		for (int n : toFind)
		{
			if (us.contains(n))
				++cnt;
		}
		auto stop = std::chrono::steady_clock::now();
		// 시간 재기 끝

		auto et = std::chrono::duration_cast<std::chrono::microseconds>(stop - start).count();
		std::cout << "걸린 시간 O(1) - " << et << "μs" << std::endl;
		std::cout << "언오더드셋에서 찾은 개수 - " << toFind.size() << std::endl;
		std::cout << cnt << std::endl << std::endl;
	}
}


파일이름: 소스.cpp
파일크기: 3215
저장시간: 2022-05-18 16:56:12 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 18일 목요일(11주 2일)
// 
// 컨테이너의 찾기 실력 비교 - vector/ set/ unordered_set
// int 1000'0000개에서 int 1'000개가 있는지 확인
// 
// 컨테이너의 찾기 실력 비교 - vector / set /  unordered_set
// 5/25(수) - 졸업연구설명회(6교시 2:30 ~ 3:20)
//-----------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <vector>
#include <set>
#include <unordered_set>
#include <algorithm>
#include <random>
#include <chrono>
#include "save.h"
#include "STRING.h"

//
// using namespace std;
//

// 정수 저장할 메모리
std::array<int, 1000> numbers;

// 컨테이너에 있는지 찾아볼 int 값들
std::array<int, 10> toFind;

std::default_random_engine dre;
std::uniform_int_distribution<int> uid{ 1, 1'0000'0000 };

//----
int main()
//----
{
	save("소스.cpp");
	
	// random int
	for (int& n : numbers)
		n = uid(dre);
	
	// 찾아야할 int
	for (int& n : toFind)
		n = uid(dre);

	
	{	// 벡터의 찾기 실력을 알아본다.
		std::vector<int> v{ numbers.begin(), numbers.end() };
		
		std::cout << "벡터의 원소 수 - " << v.size() << std::endl;

		// 시간 재기 시작
		int cnt{};
		auto start = std::chrono::steady_clock::now();
		for (int n : toFind)
		{
			auto p = std::find(v.begin(), v.end(), n);
			if (p != v.end())
				cnt++;
		}
		auto stop = std::chrono::steady_clock::now();
		// 시간 재기 끝

		auto et = std::chrono::duration_cast<std::chrono::microseconds>(stop - start).count();
		std::cout << "걸린 시간 O(n) - " << et << "μs" << std::endl;
		std::cout << "찾아야 할 int 개수 - " << toFind.size() << std::endl;
		std::cout << "벡처에서 찾은 개수 - " << cnt << std::endl << std::endl;
	}

	{	// 셋의 찾기 실력을 알아본다.
		std::set<int> s{ numbers.begin(), numbers.end() };

		std::cout << "셋의 원소 수 - " << s.size() << std::endl;

		// 시간 재기 시작
		int cnt{};
		auto start = std::chrono::steady_clock::now();
		for (int n : toFind)
		{
			if (s.contains(n))
				++cnt;
		}
		auto stop = std::chrono::steady_clock::now();
		// 시간 재기 끝

		auto et = std::chrono::duration_cast<std::chrono::microseconds>(stop - start).count();
		std::cout << "걸린 시간 O(log n) - " << et << "μs" << std::endl;
		std::cout << "찾아야 할 int 개수 - " << toFind.size() << std::endl;
		std::cout << "셋에서 찾은 개수 - " << cnt << std::endl << std::endl;
	}

	{	// 언오더드셋의 찾기 실력을 알아본다.
		std::unordered_set<int> us{ numbers.begin(), numbers.end() };

		std::cout << "언오더드셋의 원소 수 - " << us.size() << std::endl;

		// 시간 재기 시작
		int cnt{};
		auto start = std::chrono::steady_clock::now();
		for (int n : toFind)
		{
			if (us.contains(n))
				++cnt;
		}
		auto stop = std::chrono::steady_clock::now();
		// 시간 재기 끝

		auto et = std::chrono::duration_cast<std::chrono::microseconds>(stop - start).count();
		std::cout << "걸린 시간 O(1) - " << et << "μs" << std::endl;
		std::cout << "찾아야 할 int 개수 - " << toFind.size() << std::endl;
		std::cout << "언오더드셋에서 찾은 개수 - " << cnt << std::endl << std::endl;
	}
}


파일이름: 소스.cpp
파일크기: 3995
저장시간: 2022-05-18 17:00:57 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 18일 목요일(11주 2일)
// 
// 컨테이너의 찾기 실력 비교 - vector/ set/ unordered_set
// int 1000'0000개에서 int 1'000개가 있는지 확인
// 
// 컨테이너의 찾기 실력 비교 - vector / set /  unordered_set
// 5/25(수) - 졸업연구설명회(6교시 2:30 ~ 3:20)
//-----------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <vector>
#include <set>
#include <unordered_set>
#include <algorithm>
#include <random>
#include <chrono>
#include "save.h"
#include "STRING.h"

//
// using namespace std;
//

// 정수 저장할 메모리
std::array<int, 1000'0000> numbers;

// 컨테이너에 있는지 찾아볼 int 값들
std::array<int, 3000> toFind;

std::default_random_engine dre;
std::uniform_int_distribution<int> uid{ 1, 1'0000'0000 };

//----
int main()
//----
{
	save("소스.cpp");
	
	// random int
	for (int& n : numbers)
		n = uid(dre);
	
	// 찾아야할 int
	for (int& n : toFind)
		n = uid(dre);

	
	{	// 벡터의 찾기 실력을 알아본다.
		std::vector<int> v{ numbers.begin(), numbers.end() };
		
		std::cout << "벡터의 원소 수 - " << v.size() << std::endl;

		// 시간 재기 시작
		int cnt{};
		auto start = std::chrono::steady_clock::now();
		for (int n : toFind)
		{
			auto p = std::find(v.begin(), v.end(), n);
			if (p != v.end())
				cnt++;
		}
		auto stop = std::chrono::steady_clock::now();
		// 시간 재기 끝

		auto et = std::chrono::duration_cast<std::chrono::microseconds>(stop - start).count();
		std::cout << "걸린 시간 O(n) - " << et << "μs" << std::endl;
		std::cout << "찾아야 할 int 개수 - " << toFind.size() << std::endl;
		std::cout << "벡처에서 찾은 개수 - " << cnt << std::endl << std::endl;
	}

	{	// 정렬된 벡터의 찾기 실력을 알아본다.
		std::vector<int> v{ numbers.begin(), numbers.end() };
		std::sort(v.begin(), v.end());
		std::cout << "정렬된 벡터의 원소 수 - " << v.size() << std::endl;

		// 시간 재기 시작
		int cnt{};
		auto start = std::chrono::steady_clock::now();
		for (int n : toFind)
		{
			if(std::binary_search(v.begin(), v.end(), n))
				cnt++;
		}
		auto stop = std::chrono::steady_clock::now();
		// 시간 재기 끝

		auto et = std::chrono::duration_cast<std::chrono::microseconds>(stop - start).count();
		std::cout << "걸린 시간 O(log n) - " << et << "μs" << std::endl;
		std::cout << "찾아야 할 int 개수 - " << toFind.size() << std::endl;
		std::cout << "정렬된 벡처에서 찾은 개수 - " << cnt << std::endl << std::endl;
	}

	{	// 셋의 찾기 실력을 알아본다.
		std::set<int> s{ numbers.begin(), numbers.end() };

		std::cout << "셋의 원소 수 - " << s.size() << std::endl;

		// 시간 재기 시작
		int cnt{};
		auto start = std::chrono::steady_clock::now();
		for (int n : toFind)
		{
			if (s.contains(n))
				++cnt;
		}
		auto stop = std::chrono::steady_clock::now();
		// 시간 재기 끝

		auto et = std::chrono::duration_cast<std::chrono::microseconds>(stop - start).count();
		std::cout << "걸린 시간 O(log n) - " << et << "μs" << std::endl;
		std::cout << "찾아야 할 int 개수 - " << toFind.size() << std::endl;
		std::cout << "셋에서 찾은 개수 - " << cnt << std::endl << std::endl;
	}

	{	// 언오더드셋의 찾기 실력을 알아본다.
		std::unordered_set<int> us{ numbers.begin(), numbers.end() };

		std::cout << "언오더드셋의 원소 수 - " << us.size() << std::endl;

		// 시간 재기 시작
		int cnt{};
		auto start = std::chrono::steady_clock::now();
		for (int n : toFind)
		{
			if (us.contains(n))
				++cnt;
		}
		auto stop = std::chrono::steady_clock::now();
		// 시간 재기 끝

		auto et = std::chrono::duration_cast<std::chrono::microseconds>(stop - start).count();
		std::cout << "걸린 시간 O(1) - " << et << "μs" << std::endl;
		std::cout << "찾아야 할 int 개수 - " << toFind.size() << std::endl;
		std::cout << "언오더드셋에서 찾은 개수 - " << cnt << std::endl << std::endl;
	}
}


파일이름: 소스.cpp
파일크기: 975
저장시간: 2022-05-19 10:50:54 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 18일 목요일(11주 2일)
// 
// 알고리즘
// - non-modifying sequence operations (원소를 수정하지 않는 알고리즘)
// - modifying sequence operations
// - sorting operations
// - partition
// 
// 
// 5/25(수) - 졸업연구설명회(6교시 2:30 ~ 3:20)
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "STRING.h"

//
// using namespace std;
//

//----
int main()
//----
{
	save("소스.cpp");
	
	std::vector<STRING> v{ "Standard", "Template", "Library" };

	// v에 STRING이 있는데 첫글자가 다 대문자야?
	bool res = std::all_of(v.cbegin(), v.cend(), [](const STRING& s) {return isupper(s.getC()); });

	if (res)
		std::cout << "첫 글자는 다 대문자" << std::endl;
	else
		std::cout << "소문자로 시작하는 단어도 있다" << std::endl;
}


파일이름: 소스.cpp
파일크기: 1164
저장시간: 2022-05-19 10:56:45 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 18일 목요일(11주 2일)
// 
// 알고리즘
// - non-modifying sequence operations (원소를 수정하지 않는 알고리즘)
// - modifying sequence operations
// - sorting operations
// - partition
// 
// 
// 5/25(수) - 졸업연구설명회(6교시 2:30 ~ 3:20)
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "STRING.h"

//
// using namespace std;
//

template<class InputIt, class pred>
bool allof(InputIt begin, InputIt end, pred mypred)
{
	for (; begin != end; ++begin)
	{
		if (!mypred(*begin))
			return false;
	}
	return true;
}

//----
int main()
//----
{
	save("소스.cpp");
	
	std::vector<STRING> v{ "Standard", "Template", "Library" };

	// v에 STRING이 있는데 첫글자가 다 대문자야?
	bool res = allof(v.cbegin(), v.cend(), [](const STRING& s) {return isupper(s.getC()); });

	if (res)
		std::cout << "첫 글자는 다 대문자" << std::endl;
	else
		std::cout << "소문자로 시작하는 단어도 있다" << std::endl;
}


파일이름: 소스.cpp
파일크기: 1171
저장시간: 2022-05-19 11:00:57 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 18일 목요일(11주 2일)
// 
// 알고리즘
// - non-modifying sequence operations (원소를 수정하지 않는 알고리즘)
// - modifying sequence operations
// - sorting operations
// - partition
// 
// 
// 5/25(수) - 졸업연구설명회(6교시 2:30 ~ 3:20)
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "STRING.h"

//
// using namespace std;
//

template<class 반복자, class 단항판단함수>
bool allof(반복자 시작, 반복자 끝, 단항판단함수 함수)
{
	while (시작 != 끝){
		if (!함수(*시작))
			return false;
		++시작;
	}
	return true;
}



//----
int main()
//----
{
	save("소스.cpp");
	
	std::vector<STRING> v{ "Standard", "Template", "Library" };

	// v에 STRING이 있는데 첫글자가 다 대문자야?
	bool res = allof(v.cbegin(), v.cend(), [](const STRING& s) {return isupper(s.getC()); });

	if (res)
		std::cout << "첫 글자는 다 대문자" << std::endl;
	else
		std::cout << "소문자로 시작하는 단어도 있다" << std::endl;
}


파일이름: 소스.cpp
파일크기: 923
저장시간: 2022-05-19 11:05:14 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 18일 목요일(11주 2일)
// 
// 알고리즘
// - non-modifying sequence operations (원소를 수정하지 않는 알고리즘)
// - modifying sequence operations
// - sorting operations
// - partition
// 
// 
// 5/25(수) - 졸업연구설명회(6교시 2:30 ~ 3:20)
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "STRING.h"

//
// using namespace std;
//


//----
int main()
//----
{
	save("소스.cpp");
	
	std::vector<STRING> v{ "Standard", "Template", "Library" };

	// v에 STRING이 있는데 첫글자가 다 대문자야?
	
	std::for_each(v.begin(), v.end(), [](const STRING& s) {
		for (auto& c : s)
			c = toupper(c);
	});

	for (const auto& string : v)
		std::cout << string << std::endl;
}


파일이름: 소스.cpp
파일크기: 809
저장시간: 2022-05-19 11:06:58 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 18일 목요일(11주 2일)
// 
// 알고리즘
// - non-modifying sequence operations (원소를 수정하지 않는 알고리즘)
// - modifying sequence operations
// - sorting operations
// - partition
// 
// 
// 5/25(수) - 졸업연구설명회(6교시 2:30 ~ 3:20)
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "STRING.h"

//
// using namespace std;
//


//----
int main()
//----
{
	save("소스.cpp");
	
	std::vector<STRING> v{ "Standard", "Template", "Library" };

	STRING toFind = STRING{ "Template" };
	std::cout << std::count(v.begin(), v.end(), toFind) << std::endl;
	
}


파일이름: 소스.cpp
파일크기: 853
저장시간: 2022-05-19 11:08:29 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 18일 목요일(11주 2일)
// 
// 알고리즘
// - non-modifying sequence operations (원소를 수정하지 않는 알고리즘)
// - modifying sequence operations
// - sorting operations
// - partition
// 
// 
// 5/25(수) - 졸업연구설명회(6교시 2:30 ~ 3:20)
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "STRING.h"

//
// using namespace std;
//


//----
int main()
//----
{
	save("소스.cpp");
	
	std::vector<STRING> v{ "Standard", "Template", "Library" };

	STRING toFind = STRING{ "Template" };
	std::cout << std::count_if(v.begin(), v.end(), [](const STRING& s) { return s.getC() == 'T'; }) << std::endl;
	
}


파일이름: 소스.cpp
파일크기: 943
저장시간: 2022-05-19 11:32:22 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 18일 목요일(11주 2일)
// 
// 알고리즘
// - non-modifying sequence operations (원소를 수정하지 않는 알고리즘)
// - modifying sequence operations
// - sorting operations
// - partition
// 
// 
// 5/25(수) - 졸업연구설명회(6교시 2:30 ~ 3:20)
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include "save.h"
#include "STRING.h"

//
// using namespace std;
//


//----
int main()
//----
{
	save("소스.cpp");
	
	std::string s1{ "abcdefghij" };
	std::string s2{ "abcdfghikklll" };

	auto [시작, 끝] = std::mismatch(s1.begin(), s1.end(), s2.begin(), s2.end());
	std::string s3{ 시작, s1.end() };
	std::string s4{ 끝, s2.end() };

	std::cout << s3 << std::endl;
	std::cout << s4 << std::endl;

}


파일이름: 소스.cpp
파일크기: 1066
저장시간: 2022-05-19 11:41:20 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 18일 목요일(11주 2일)
// 
// 알고리즘
// - non-modifying sequence operations (원소를 수정하지 않는 알고리즘)
// - modifying sequence operations
// - sorting operations
// - partition
// 
// 
// 5/25(수) - 졸업연구설명회(6교시 2:30 ~ 3:20)
//-----------------------------------------------------------------------------

#include <iostream>
#include <thread>
#include <chrono>
#include <format>
#include <algorithm>
#include <string>
#include "save.h"
#include "STRING.h"

//
// using namespace std;
//

using namespace std::chrono_literals;

//----
int main()
//----
{
	save("소스.cpp");
	
	std::string str{ "South Korea and Japan just don't get along. " };
	// 전광판처럼 흘러가게 코딩할래?

	for (int i = 0; i < 8; ++i)
		std::cout << std::endl;
	while (true){
		std::rotate(str.rbegin(), str.rbegin() + 1, str.rend());
		std::cout << std::format("{:^80}", str) << "\r";
		std::this_thread::sleep_for(100ms);
	}

}


파일이름: 소스.cpp
파일크기: 1068
저장시간: 2022-05-19 11:43:16 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 18일 목요일(11주 2일)
// 
// 알고리즘
// - non-modifying sequence operations (원소를 수정하지 않는 알고리즘)
// - modifying sequence operations
// - sorting operations
// - partition
// 
// 
// 5/25(수) - 졸업연구설명회(6교시 2:30 ~ 3:20)
//-----------------------------------------------------------------------------

#include <iostream>
#include <thread>
#include <chrono>
#include <format>
#include <algorithm>
#include <string>
#include "save.h"
#include "STRING.h"

//
// using namespace std;
//

using namespace std::chrono_literals;

//----
int main()
//----
{
	save("소스.cpp");
	
	std::string str{ "South Korea and Japan just don't get along. " };
	// 전광판처럼 흘러가게 코딩할래?

	for (int i = 0; i < 8; ++i)
		std::cout << std::endl;
	while (true){
		std::rotate(str.rbegin(), str.rbegin() + 1, str.rend());
		std::cout << std::format("[{:^80}]", str) << "\r";
		std::this_thread::sleep_for(100ms);
	}

}


파일이름: 소스.cpp
파일크기: 1075
저장시간: 2022-05-19 11:43:47 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 18일 목요일(11주 2일)
// 
// 알고리즘
// - non-modifying sequence operations (원소를 수정하지 않는 알고리즘)
// - modifying sequence operations
// - sorting operations
// - partition
// 
// 
// 5/25(수) - 졸업연구설명회(6교시 2:30 ~ 3:20)
//-----------------------------------------------------------------------------

#include <iostream>
#include <thread>
#include <chrono>
#include <format>
#include <algorithm>
#include <string>
#include "save.h"
#include "STRING.h"

//
// using namespace std;
//

using namespace std::chrono_literals;

//----
int main()
//----
{
	save("소스.cpp");
	
	std::string str{ "[South Korea and Japan just don't get along.]" };
	// 전광판처럼 흘러가게 코딩할래?

	for (int i = 0; i < 8; ++i)
		std::cout << std::endl;
	while (true){
		std::rotate(str.rbegin() + 1, str.rbegin() + 2, str.rend() - 1);
		std::cout << std::format("{:^80}", str) << "\r";
		std::this_thread::sleep_for(100ms);
	}

}


파일이름: 소스.cpp
파일크기: 1040
저장시간: 2022-05-25 15:36:08 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 18일 목요일(11주 2일)
// 
// 알고리즘
// - non-modifying sequence operations (원소를 수정하지 않는 알고리즘)
// - modifying sequence operations
// - sorting operations
// - partition
// 
// 
// 5/25(수) - 졸업연구설명회(6교시 2:30 ~ 3:20)
// 6/15(수) - 15주 1일 기말시험
// 6/16(목) - 강의 정리
//-----------------------------------------------------------------------------

#include <iostream>
#include <thread>
#include <chrono>
#include <format>
#include <algorithm>
#include <string>
#include "save.h"
#include "STRING.h"

//
// using namespace std;
//

//----
int main()
//----
{
	save("소스.cpp");
	
	std::string str{ "abcdefghijklmnopqrstuvwxyz" };
	
	// str에서 opq라는 string이 있니?

	std::string toFind{ "opq" };
	
	if (std::search(str.begin(), str.end(), toFind.begin(), toFind.end()) != str.end())
		std::cout << "있음" << std::endl;
	else
		std::cout << "없음" << std::endl;
}


파일이름: 소스.cpp
파일크기: 949
저장시간: 2022-05-25 15:38:48 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 25일 목요일(12주 2일)
// 
// 알고리즘
// - non-modifying sequence operations (원소를 수정하지 않는 알고리즘)
// - modifying sequence operations
// - sorting operations
// - partition
// 
// 
// 5/25(수) - 졸업연구설명회(6교시 2:30 ~ 3:20)
// 6/15(수) - 15주 1일 기말시험
// 6/16(목) - 강의 정리
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include "save.h"
#include "STRING.h"

//
// using namespace std;
//

//----
int main()
//----
{
	save("소스.cpp");

	// [문제] copy는 왜 mutating 알고리즘인가?
	std::vector v{ 1, 2, 3 };
	std::copy(v.begin(), v.end(), std::ostream_iterator<int> {std::cout});
	std::cout << std::endl;
	for (int n : v)
		std::cout << n << ' ';
	std::cout<< std::endl;
}


파일이름: 소스.cpp
파일크기: 983
저장시간: 2022-05-25 15:43:21 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 25일 목요일(12주 2일)
// 
// 알고리즘
// - non-modifying sequence operations (원소를 수정하지 않는 알고리즘)
// - modifying sequence operations
// - sorting operations
// - partition
// 
// 
// 5/25(수) - 졸업연구설명회(6교시 2:30 ~ 3:20)
// 6/15(수) - 15주 1일 기말시험
// 6/16(목) - 강의 정리
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include "save.h"
#include "STRING.h"

//
// using namespace std;
//

//----
int main()
//----
{
	save("소스.cpp");

	// [문제] copy는 왜 mutating 알고리즘인가? - 목적지가 자기 자신이 될 수도 있으니까!
	std::vector v{ 1, 2, 3 };

	std::copy(v.begin(), v.end(), inserter(v, v.begin() + 1));
	
	std::cout << std::endl;
	for (int n : v)
		std::cout << n << ' ';
	std::cout<< std::endl;
}


파일이름: 소스.cpp
파일크기: 1179
저장시간: 2022-05-25 15:51:22 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 25일 목요일(12주 2일)
// 
// 알고리즘
// - non-modifying sequence operations (원소를 수정하지 않는 알고리즘)
// - modifying sequence operations
// - sorting operations
// - partition
// 
// 
// 5/25(수) - 졸업연구설명회(6교시 2:30 ~ 3:20)
// 6/15(수) - 15주 1일 기말시험
// 6/16(목) - 강의 정리
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include "save.h"
#include "STRING.h"

//
// using namespace std;
//

//----
int main()
//----
{
	save("소스.cpp");
	std::vector tmp{ 1, 2, 3 };
	std::vector v{ 1, 2, 3, 4, 5, 6,7, 8, 9, 10 };
	// [문제] v에서 짝수를 제거하라. erase-remove idiom이 원칙이지만
	// C++20부터는 지원되는 전역 erase 함수로도 해결할 수 있다.

	// remove_if는 일치 하지 않는 반복자를 리턴
	v.erase(std::remove_if(v.begin(), v.end(), [](int i) {return i % 2 == 0; }), v.end());
	std::erase_if(v, [](int n) {return n % 2 == 0; });

	for (int n : v)
		std::cout << n << " ";
	std::cout << std::endl;
	
}


파일이름: 소스.cpp
파일크기: 1183
저장시간: 2022-05-25 15:54:00 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 25일 목요일(12주 2일)
// 
// 알고리즘
// - non-modifying sequence operations (원소를 수정하지 않는 알고리즘)
// - modifying sequence operations
// - sorting operations
// - partition
// 
// 
// 5/25(수) - 졸업연구설명회(6교시 2:30 ~ 3:20)
// 6/15(수) - 15주 1일 기말시험
// 6/16(목) - 강의 정리
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include "save.h"
#include "STRING.h"

//
// using namespace std;
//

//----
int main()
//----
{
	save("소스.cpp");
	std::vector tmp{ 1, 2, 3 };
	std::vector v{ 1, 2, 3, 4, 5, 6,7, 8, 9, 10 };
	// [문제] v에서 짝수를 제거하라. erase-remove idiom이 원칙이지만
	// C++20부터는 지원되는 전역 erase 함수로도 해결할 수 있다.

	// remove_if는 일치 하지 않는 반복자를 리턴
	v.erase(std::remove_if(v.begin(), v.end(), [](int i) {return i % 2 == 0; }), v.end());
	std::erase_if(v, [](int n) {return n % 2 == 0; });


	for (int n : tmp)
		std::cout << n << " ";
	std::cout << std::endl;
	
}


파일이름: 소스.cpp
파일크기: 1185
저장시간: 2022-05-25 16:04:38 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 25일 목요일(12주 2일)
// 
// 알고리즘
// - non-modifying sequence operations (원소를 수정하지 않는 알고리즘)
// - modifying sequence operations
// - sorting operations
// - partition
// 
// 
// 5/25(수) - 졸업연구설명회(6교시 2:30 ~ 3:20)
// 6/15(수) - 15주 1일 기말시험
// 6/16(목) - 강의 정리
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <random>
#include <numeric>	// iota
#include <algorithm>
#include "save.h"
#include "STRING.h"

//
// using namespace std;
//

std::random_device rd;
std::default_random_engine dre{ rd() };

//----
int main()
//----
{
	save("소스.cpp");

	// [문제] 로또 예산 번호를 출력
	std::vector<int> v(45);		// int{}를 45번 호출
	std::iota(v.begin(), v.end(), 1);
	/*for (int n : v)
		std::cout << n << " ";
	std::cout << std::endl;*/

	// 랜덤한 수 n개를 화면에 출력
	for (int i = 0; i < 10; ++i)
	{
		std::sample(v.begin(), v.end(), std::ostream_iterator<int> {std::cout, " "}, 6, dre);
		std::cout << std::endl;
	}
}


파일이름: 소스.cpp
파일크기: 887
저장시간: 2022-05-25 16:09:33 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 25일 목요일(12주 2일)
// 
// 알고리즘
// - non-modifying sequence operations (원소를 수정하지 않는 알고리즘)
// - modifying sequence operations
// - sorting operations
// - partition
// 
// 
// 5/25(수) - 졸업연구설명회(6교시 2:30 ~ 3:20)
// 6/15(수) - 15주 1일 기말시험
// 6/16(목) - 강의 정리
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "STRING.h"

//
// using namespace std;
//

//----
int main()
//----
{
	save("소스.cpp");

	// unique - 연속된 중복 원소를 삭제한다.
	std::vector<int> v{ 1, 2, 3, 3, 3, 5, 3 };
	std::unique(v.begin(), v.end());
	
	for (int n : v)
		std::cout << n << " ";
	std::cout << std::endl;

}


파일이름: 소스.cpp
파일크기: 905
저장시간: 2022-05-25 16:09:54 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 25일 목요일(12주 2일)
// 
// 알고리즘
// - non-modifying sequence operations (원소를 수정하지 않는 알고리즘)
// - modifying sequence operations
// - sorting operations
// - partition
// 
// 
// 5/25(수) - 졸업연구설명회(6교시 2:30 ~ 3:20)
// 6/15(수) - 15주 1일 기말시험
// 6/16(목) - 강의 정리
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "STRING.h"

//
// using namespace std;
//

//----
int main()
//----
{
	save("소스.cpp");

	// unique - 연속된 중복 원소를 삭제한다.
	std::vector<int> v{ 1, 2, 3, 3, 3, 5, 3 };
	v.erase(std::unique(v.begin(), v.end()), v.end());
	
	for (int n : v)
		std::cout << n << " ";
	std::cout << std::endl;

}


파일이름: 소스.cpp
파일크기: 1412
저장시간: 2022-05-25 16:46:44 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 25일 목요일(12주 2일)
// 
// 알고리즘 - 분리 / 정렬 관련 함수들
//		partition
//		nth_element
//		partial_sort
//		stable_sort
// 
//
// 6/15(수) - 15주 1일 기말시험
// 6/16(목) - 강의 정리
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>
#include <random>
#include <format>
#include "save.h"
#include "STRING.h"

//
// using namespace std;
//

std::default_random_engine dre;

template <class Iter>
void print(Iter begin, Iter end)
{
	while (begin != end)
	{
		std::cout << std::format("{:4d}", *begin);
		++begin;
	}
	std::cout << std::endl;
}

//----
int main()
//----
{
	save("소스.cpp");
	std::vector<int> v(100);
	std::iota(v.begin(), v.end(), 1);
	std::cout << "vector<int>의 값" << std::endl;
	print(v.begin(), v.end());
	{
		std::shuffle(v.begin(), v.end(), dre);
		std::cout << "partition 이전" << std::endl;
		print(v.begin(), v.end());

		// [문제] 홀수와 짝수로 분리한 수 출력하라.
		auto p = std::partition(v.begin(), v.end(), [](int n) { return n % 2; });
		std::cout << "partition 후" << std::endl;
		std::cout << "홀수" << std::endl;
		print(v.begin(), p);
		std::cout << "짝수" << std::endl;
		print(p, v.end());
	}
}


파일이름: 소스.cpp
파일크기: 1929
저장시간: 2022-05-25 16:55:27 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 25일 목요일(12주 2일)
// 
// 알고리즘 - 분리 / 정렬 관련 함수들
//		partition
//		nth_element
//		partial_sort
//		stable_sort
// 
//
// 6/15(수) - 15주 1일 기말시험
// 6/16(목) - 강의 정리
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>
#include <random>
#include <format>
#include "save.h"
#include "STRING.h"

//
// using namespace std;
//

std::default_random_engine dre;

template <class Iter>
void print(Iter begin, Iter end)
{
	while (begin != end)
	{
		std::cout << std::format("{:4d}", *begin);
		++begin;
	}
	std::cout << std::endl;
}

//----
int main()
//----
{
	save("소스.cpp");
	std::vector<int> v(100);
	std::iota(v.begin(), v.end(), 1);
	std::cout << "vector<int>의 값" << std::endl;
	print(v.begin(), v.end());
	{
		// 기준에 따라 분리
		std::shuffle(v.begin(), v.end(), dre);
		std::cout << "partition 이전" << std::endl;
		print(v.begin(), v.end());

		// [문제] 홀수와 짝수로 분리한 수 출력하라.
		auto p = std::partition(v.begin(), v.end(), [](int n) { return n % 2; });
		std::cout << "partition 후" << std::endl;
		std::cout << "홀수" << std::endl;
		print(v.begin(), p);
		std::cout << "짝수" << std::endl;
		print(p, v.end());
	}

	{
		// 선착순 20등까지만 통과 - 1등부터 20등까지 순서는 중요하지 않다.
		std::shuffle(v.begin(), v.end(), dre);
		std::cout << "nth_element 이전" << std::endl;
		print(v.begin(), v.end());

		// 20등까지만 통과
		// 리턴값이 없음(어차피 내가 주는 값 까지만 보여주니까)
		std::nth_element(v.begin(), v.begin() + 20, v.end());
		std::cout << "20등 이내" << std::endl;
		print(v.begin(), v.begin() + 20);
		std::cout << "나머지" << std::endl;
		print(v.begin() + 20, v.end());
	}
}


파일이름: 소스.cpp
파일크기: 2390
저장시간: 2022-05-25 17:00:30 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 25일 목요일(12주 2일)
// 
// 알고리즘 - 분리 / 정렬 관련 함수들
//		partition
//		nth_element
//		partial_sort
//		stable_sort
// 
// 복잡도 확인해야함
// 6/15(수) - 15주 1일 기말시험
// 6/16(목) - 강의 정리
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>
#include <random>
#include <format>
#include "save.h"
#include "STRING.h"

//
// using namespace std;
//

std::random_device rd;
std::default_random_engine dre{ rd() };

template <class Iter>
void print(Iter begin, Iter end)
{
	while (begin != end)
	{
		std::cout << std::format("{:4d}", *begin);
		++begin;
	}
	std::cout << std::endl;
}

//----
int main()
//----
{
	save("소스.cpp");
	std::vector<int> v(100);
	std::iota(v.begin(), v.end(), 1);
	std::cout << "vector<int>의 값" << std::endl;
	print(v.begin(), v.end());
	{
		// 기준에 따라 분리
		std::shuffle(v.begin(), v.end(), dre);
		std::cout << "partition 이전" << std::endl;
		print(v.begin(), v.end());

		// [문제] 홀수와 짝수로 분리한 수 출력하라.
		auto p = std::partition(v.begin(), v.end(), [](int n) { return n % 2; });
		std::cout << "partition 후" << std::endl;
		std::cout << "홀수" << std::endl;
		print(v.begin(), p);
		std::cout << "짝수" << std::endl;
		print(p, v.end());
	}

	{
		// 선착순 40등까지만 통과 - 1등부터 40등까지 순서는 중요하지 않다.
		std::shuffle(v.begin(), v.end(), dre);
		std::cout << "nth_element 이전" << std::endl;
		print(v.begin(), v.end());

		// 40등까지만 통과
		// 리턴값이 없음(어차피 내가 주는 값 까지만 보여주니까)
		std::nth_element(v.begin(), v.begin() + 40, v.end());
		std::cout << "40등 이내" << std::endl;
		print(v.begin(), v.begin() + 40);
		std::cout << "나머지" << std::endl;
		print(v.begin() + 40, v.end());
	}

	{
		// 1등부터 50등까지만 정렬 나머지는 무시
		std::shuffle(v.begin(), v.end(), dre);
		std::cout << "partial_sort 이전" << std::endl;
		print(v.begin(), v.end());

		// 50등까지만 정렬
		std::partial_sort(v.begin(), v.begin() + 50, v.end());
		std::cout << "50등 이내" << std::endl;
		print(v.begin(), v.begin() + 50);
		std::cout << "나머지" << std::endl;
		print(v.begin() + 50, v.end());
	}
}


파일이름: 소스.cpp
파일크기: 2676
저장시간: 2022-05-25 17:03:33 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 25일 목요일(12주 2일)
// 
// 알고리즘 - 분리 / 정렬 관련 함수들
//		partition
//		nth_element
//		partial_sort
//		stable_sort
// 
// 복잡도 확인해야함
// 6/15(수) - 15주 1일 기말시험
// 6/16(목) - 강의 정리
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>
#include <random>
#include <format>
#include "save.h"
#include "STRING.h"

//
// using namespace std;
//

std::random_device rd;
std::default_random_engine dre{ rd() };

template <class Iter>
void print(Iter begin, Iter end)
{
	while (begin != end)
	{
		std::cout << std::format("{:4d}", *begin);
		++begin;
	}
	std::cout << std::endl << std::endl;
}

//----
int main()
//----
{
	save("소스.cpp");
	std::vector<int> v(100);
	std::iota(v.begin(), v.end(), 1);
	std::cout << "vector<int>의 값" << std::endl;
	print(v.begin(), v.end());
	{
		// 기준에 따라 분리
		std::shuffle(v.begin(), v.end(), dre);
		std::cout << "partition 이전" << std::endl;
		print(v.begin(), v.end());

		// [문제] 홀수와 짝수로 분리한 수 출력하라.
		auto p = std::partition(v.begin(), v.end(), [](int n) { return n % 2; });
		std::cout << "partition 후" << std::endl;
		std::cout << "홀수" << std::endl;
		print(v.begin(), p);
		std::cout << "짝수" << std::endl;
		print(p, v.end());
	}

	{
		// 선착순 40등까지만 통과 - 1등부터 40등까지 순서는 중요하지 않다.
		std::shuffle(v.begin(), v.end(), dre);
		std::cout << "nth_element 이전" << std::endl;
		print(v.begin(), v.end());

		// 40등까지만 통과
		// 리턴값이 없음(어차피 내가 주는 값 까지만 보여주니까)
		std::nth_element(v.begin(), v.begin() + 40, v.end());
		std::cout << "40등 이내" << std::endl;
		print(v.begin(), v.begin() + 40);
		std::cout << "나머지" << std::endl;
		print(v.begin() + 40, v.end());
	}

	{
		// 1등부터 50등까지만 정렬 나머지는 무시
		std::shuffle(v.begin(), v.end(), dre);
		std::cout << "partial_sort 이전" << std::endl;
		print(v.begin(), v.end());

		// 50등까지만 정렬
		std::partial_sort(v.begin(), v.begin() + 50, v.end());
		std::cout << "50등까지 정렬" << std::endl;
		print(v.begin(), v.begin() + 50);
		std::cout << "나머지" << std::endl;
		print(v.begin() + 50, v.end());
	}

	{
		// 전체 정렬
		std::shuffle(v.begin(), v.end(), dre);
		std::cout << "sort 이전" << std::endl;
		print(v.begin(), v.end());

		// 전체 정렬
		std::sort(v.begin(), v.end());
		std::cout << "전체 정렬 결과" << std::endl;
		print(v.begin(), v.end());
	}
}


파일이름: 소스.cpp
파일크기: 1109
저장시간: 2022-05-25 17:12:40 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 25일 목요일(12주 2일)
// 
// 알고리즘 - 분리 / 정렬 관련 함수들
//		partition
//		nth_element
//		partial_sort
//		stable_sort
// 
// 복잡도 확인해야함
// 6/15(수) - 15주 1일 기말시험
// 6/16(목) - 강의 정리
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>
#include <random>
#include <format>
#include "save.h"
#include "STRING.h"

//
// using namespace std;
//

std::random_device rd;
std::default_random_engine dre{ rd() };
std::uniform_int_distribution uid{ 1, 10 };
struct Dog
{
	int num1;
	int num2;

	Dog() {
		num1 = uid(dre);
		num2 = uid(dre);
	}

};

//----
int main()
//----
{
	save("소스.cpp");
	std::vector<Dog> dogs(10);	//Dog{} 20번 호출
	// num1기준 오름차순 정렬
	std::sort(dogs.begin(), dogs.end(), [](Dog a, Dog b) {return a.num1 < b.num1; });
	for (Dog dog : dogs)
		std::cout << dog.num1 << ", " << dog.num2 << std::endl;
}

파일이름: 소스.cpp
파일크기: 1183
저장시간: 2022-05-25 17:14:27 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 25일 목요일(12주 2일)
// 
// 알고리즘 - 분리 / 정렬 관련 함수들
//		partition
//		nth_element
//		partial_sort
//		stable_sort
// 
// 복잡도 확인해야함
// 6/15(수) - 15주 1일 기말시험
// 6/16(목) - 강의 정리
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <algorithm>
#include <random>
#include "save.h"
#include "STRING.h"

//
// using namespace std;
//

std::random_device rd;
std::default_random_engine dre{ rd() };
std::uniform_int_distribution uid{ 1, 9};
struct Dog
{
	int num1;
	int num2;

	Dog() {
		num1 = uid(dre);
		num2 = uid(dre);
	}

};

//----
int main()
//----
{
	save("소스.cpp");
	std::vector<Dog> dogs(10);	//Dog{} 20번 호출
	// num1기준 오름차순 정렬
	std::sort(dogs.begin(), dogs.end(), [](Dog a, Dog b) {return a.num1 < b.num1; });
	std::sort(dogs.begin(), dogs.end(), [](Dog a, Dog b) {return a.num2 < b.num2; });
	for (Dog dog : dogs)
		std::cout << dog.num1 << " - " << dog.num2 << std::endl;
	// num2기준 오름차순 정렬

}

파일이름: 소스.cpp
파일크기: 1191
저장시간: 2022-05-25 17:17:30 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 25일 목요일(12주 2일)
// 
// 알고리즘 - 분리 / 정렬 관련 함수들
//		partition
//		nth_element
//		partial_sort
//		stable_sort
// 
// 복잡도 확인해야함
// 6/15(수) - 15주 1일 기말시험
// 6/16(목) - 강의 정리
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <algorithm>
#include <random>
#include "save.h"
#include "STRING.h"

//
// using namespace std;
//

std::random_device rd;
std::default_random_engine dre{ rd() };
std::uniform_int_distribution uid{ 1, 9};
struct Dog
{
	int num1;
	int num2;

	Dog() {
		num1 = uid(dre);
		num2 = uid(dre);
	}

};

//----
int main()
//----
{
	save("소스.cpp");
	std::vector<Dog> dogs(100);	//Dog{} 20번 호출
	// num1기준 오름차순 정렬
	std::sort(dogs.begin(), dogs.end(), [](Dog a, Dog b) {return a.num1 < b.num1; });
	std::stable_sort(dogs.begin(), dogs.end(), [](Dog a, Dog b) {return a.num2 < b.num2; });
	for (Dog dog : dogs)
		std::cout << dog.num1 << " - " << dog.num2 << std::endl;
	// num2기준 오름차순 정렬

}

파일이름: 소스.cpp
파일크기: 562
저장시간: 2022-05-26 10:36:43 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 26일 목요일(13주 1일)
// 
//  concepts
//		range/view
// 
// 6/15(수) - 15주 1일 기말시험
// 6/16(목) - 강의 정리
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"

//----
int main()
//----
{
	save("소스.cpp");
	std::vector<int> v{ 1,2,3,4,5 };
	std::cout << "반복자간 거리 - " << std::distance(v.begin(), v.end()) << std::endl;
}

파일이름: 소스.cpp
파일크기: 681
저장시간: 2022-05-26 10:39:52 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 26일 목요일(13주 1일)
// 
//  concepts
//		range/view
// 
// 6/15(수) - 15주 1일 기말시험
// 6/16(목) - 강의 정리
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"

std::vector<int>::difference_type 
dist(std::vector<int>::iterator b, std::vector<int>::iterator e)
{
	return e - b;
}

//----
int main()
//----
{
	save("소스.cpp");
	std::vector<int> v{ 1,2,3,4,5 };
	std::cout << "반복자간 거리 - " << dist(v.begin(), v.end()) << std::endl;

}

파일이름: 소스.cpp
파일크기: 634
저장시간: 2022-05-26 10:40:24 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 26일 목요일(13주 1일)
// 
//  concepts
//		range/view
// 
// 6/15(수) - 15주 1일 기말시험
// 6/16(목) - 강의 정리
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"

template <class Iter>
long long dist(Iter b, Iter e)
{
	return e - b;
}

//----
int main()
//----
{
	save("소스.cpp");
	std::vector<int> v{ 1,2,3,4,5 };
	std::cout << "반복자간 거리 - " << dist(v.begin(), v.end()) << std::endl;

}

파일이름: 소스.cpp
파일크기: 671
저장시간: 2022-05-26 10:44:05 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 26일 목요일(13주 1일)
// 
//  concepts
//		range/view
// 
// 6/15(수) - 15주 1일 기말시험
// 6/16(목) - 강의 정리
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"

template <class Iter>
long long dist(Iter b, Iter e)
{
	return e - b;
}

//---------
int main()
//---------
{
	save("소스.cpp");
	std::vector<int> v{ 1,2,3,4,5 };
	std::cout << "반복자간 거리 - " << dist(v.begin(), v.end()) << std::endl;
	std::cout << dist(1, 100);
}

파일이름: 소스.cpp
파일크기: 1006
저장시간: 2022-05-26 11:00:16 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 26일 목요일(13주 1일)
// 
//  concepts
//		range/view
// 
// 6/15(수) - 15주 1일 기말시험
// 6/16(목) - 강의 정리
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <type_traits>
#include "save.h"
#include "STRING.h"

template <class T>
long long dist(T b, T e)
{
	// 이 코드는 반복자에서만 실행되면 좋겠어.
	// T는 정말 반복자인가?
	// 템플릿 코드에서는 전달되는 자료형 T가 조건을 만족하는지 검사할 필요가 있다.
	// -> type traits를 사용하면 된다.
	return e - b;
}

//---------
int main()
//---------
{
	save("소스.cpp");
	std::vector<int> v{ 1,2,3,4,5 };
	std::cout << "반복자간 거리 - " << dist(v.begin(), v.end()) << std::endl;
	std::cout << dist(1, 100);	// iterator를 위한 함수를 만들었는데 int를 집어넣어서 사용이 가능하네?
								// => 그럼 iterator에서만 돌아가게 할 수 있나?


}

파일이름: 소스.cpp
파일크기: 1119
저장시간: 2022-05-26 11:11:30 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 26일 목요일(13주 1일)
// 
//  concepts
//		range/view
// 
// 6/15(수) - 15주 1일 기말시험
// 6/16(목) - 강의 정리
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <iterator>
#include "save.h"
#include "STRING.h"

using namespace std;

template <class T>
long long dist(T b, T e)
{
	// T가 반복자일때만 실행되게 하자
	// 랜덤 반복자만 실행되게 할 수 있나?
	/*if (std::is_same_v<typename iterator_traits<T>::iterator_category, random_access_iterator_tag>)
		std::cout << "랜덤반복자네~" << std::endl;
	else
		std::cout << "랜덤반복자 아닌데?" << std::endl;*/
	
	return 1;
}

//---------
int main()
//---------
{
	save("소스.cpp");
	std::vector<int> v{ 1,2,3,4,5 };
	std::cout << "반복자간 거리 - " << dist(v.begin(), v.end()) << std::endl;
	std::cout << dist(1, 100);	// iterator를 위한 함수를 만들었는데 int를 집어넣어서 사용이 가능하네?
								// => 그럼 iterator에서만 돌아가게 할 수 있나?


}

파일이름: 소스.cpp
파일크기: 1106
저장시간: 2022-05-26 11:13:28 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 26일 목요일(13주 1일)
// 
//  concepts
//		range/view
// 
// 6/15(수) - 15주 1일 기말시험
// 6/16(목) - 강의 정리
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <iterator>
#include "save.h"
#include "STRING.h"

using namespace std;

template <class T>
long long dist(T b, T e)
{
	// T가 반복자일때만 실행되게 하자
	// 랜덤 반복자만 실행되게 할 수 있나?
	/*if (is_same_v<typename iterator_traits<T>::iterator_category, input_iterator_tag>)
		std::cout << "랜덤반복자네~" << std::endl;
	else
		std::cout << "랜덤반복자 아닌데?" << std::endl;*/
	
	return 1;
}

//---------
int main()
//---------
{
	save("소스.cpp");
	std::vector<int> v{ 1,2,3,4,5 };
	std::cout << "반복자간 거리 - " << dist(v.begin(), v.end()) << std::endl;
	std::cout << dist(1, 100);	// iterator를 위한 함수를 만들었는데 int를 집어넣어서 사용이 가능하네?
								// => 그럼 iterator에서만 돌아가게 할 수 있나?


}

파일이름: 소스.cpp
파일크기: 968
저장시간: 2022-05-26 11:17:34 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 26일 목요일(13주 1일)
// 
//  concepts
//		range/view
// 
// 6/15(수) - 15주 1일 기말시험
// 6/16(목) - 강의 정리
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <iterator>
#include "save.h"
#include "STRING.h"

using namespace std;

template <class T>
long long dist(T b, T e)
{
	// T가 반복자일때만 실행되게 하자
	// 랜덤 반복자만 실행되게 할 수 있나?
	/*if (is_base_of_v < input_iterator_tag, typename iterator_traits<T>::iterator_category)
	{
		std::cout << "랜덤반복자네~" << std::endl;
	}
	else
	{
		std::cout << "랜덤반복자 아닌데?" << std::endl;
	}*/
	
	return 1;
}

//---------
int main()
//---------
{
	save("소스.cpp");
	std::vector<int> v{ 1,2,3,4,5 };
	std::cout << "반복자간 거리 - " << dist(v.begin(), v.end()) << std::endl;

}

파일이름: 소스.cpp
파일크기: 891
저장시간: 2022-05-26 11:18:05 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 26일 목요일(13주 1일)
// 
//  concepts
//		range/view
// 
// 6/15(수) - 15주 1일 기말시험
// 6/16(목) - 강의 정리
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <iterator>
#include "save.h"
#include "STRING.h"

using namespace std;

template <class T>
long long dist(T b, T e)
{
	// T가 반복자일때만 실행되게 하자
	// 랜덤 반복자만 실행되게 할 수 있나?
	if (is_base_of_v < input_iterator_tag, typename iterator_traits<T>::iterator_category>)
		std::cout << "랜덤반복자네~" << std::endl;
	
	return 1;
}

//---------
int main()
//---------
{
	save("소스.cpp");
	std::vector<int> v{ 1,2,3,4,5 };
	std::cout << "반복자간 거리 - " << dist(v.begin(), v.end()) << std::endl;

}

파일이름: 소스.cpp
파일크기: 1011
저장시간: 2022-05-26 11:19:53 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 26일 목요일(13주 1일)
// 
//  concepts
//		range/view
// 
// 6/15(수) - 15주 1일 기말시험
// 6/16(목) - 강의 정리
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <iterator>
#include <list>
#include "save.h"
#include "STRING.h"


template <class T>
long long dist(T b, T e)
{
	// T가 반복자일때만 실행되게 하자
	// 랜덤 반복자만 실행되게 할 수 있나?
	if (std::is_base_of_v<std::input_iterator_tag, typename std::iterator_traits<T>::iterator_category>)
		std::cout << "반복자네~" << std::endl;
	else
		std::cout << "반복자가 아님" << std::endl;
	
	return 1;
}

//---------
int main()
//---------
{
	save("소스.cpp");
	std::vector<int> v{ 1,2,3,4,5 };
	std::cout << "반복자간 거리 - " << dist(v.begin(), v.end()) << std::endl;

	std::list<int> lst{ 1,2,3 };
	dist(lst.begin(), lst.end());
}

파일이름: 소스.cpp
파일크기: 985
저장시간: 2022-05-26 11:22:27 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 26일 목요일(13주 1일)
// 
//  concepts
//		range/view
// 
// 6/15(수) - 15주 1일 기말시험
// 6/16(목) - 강의 정리
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <iterator>
#include <list>
#include "save.h"
#include "STRING.h"


template <class T>
long long dist(T b, T e)
{
	// T가 반복자일때만 실행되게 하자
	// 랜덤 반복자만 실행되게 할 수 있나?
	if (std::is_base_of_v<std::input_iterator_tag, typename std::iterator_traits<T>::iterator_category>)
		std::cout << "반복자네~" << std::endl;
	else
		std::cout << "반복자가 아님" << std::endl;
	
	return 1;
}

//---------
int main()
//---------
{
	save("소스.cpp");
	std::vector<int> v{ 1,2,3,4,5 };
	std::cout << "반복자간 거리 - " << dist(v.begin(), v.end()) << std::endl;

	int arr[10];
	dist(arr, arr + 1);
}

파일이름: 소스.cpp
파일크기: 979
저장시간: 2022-05-26 11:23:22 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 26일 목요일(13주 1일)
// 
//  concepts
//		range/view
// 
// 6/15(수) - 15주 1일 기말시험
// 6/16(목) - 강의 정리
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <iterator>
#include <list>
#include "save.h"
#include "STRING.h"


template <class T>
long long dist(T b, T e)
{
	// T가 반복자일때만 실행되게 하자
	// 랜덤 반복자만 실행되게 할 수 있나?
	if (std::is_base_of_v<std::input_iterator_tag, typename std::iterator_traits<T>::iterator_category>)
		std::cout << "반복자네~" << std::endl;
	else
		std::cout << "반복자가 아님" << std::endl;
	
	return 1;
}

//---------
int main()
//---------
{
	save("소스.cpp");
	std::vector<int> v{ 1,2,3,4,5 };
	dist(v.begin(), v.end());

	int arr[10];
	dist(arr, arr + 1);

	STRING s;
	dist(s.begin(), s.end());
}

파일이름: 소스.cpp
파일크기: 1235
저장시간: 2022-05-26 11:28:08 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 26일 목요일(13주 1일)
// 
//  concepts
//		range/view
// 
// 6/15(수) - 15주 1일 기말시험
// 6/16(목) - 강의 정리
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <list>
#include "save.h"
#include "STRING.h"


template <class T>
long long dist(T b, T e)
{
	
	if (std::is_base_of_v<std::input_iterator_tag, typename std::iterator_traits<T>::iterator_category>)
	{
		// 만일 T가 랜덤반복자라면
		//		e - b가 거리이다.
		if (std::is_same_v<std::random_access_iterator_tag, typename std::iterator_traits<T>::iterator_category>)
			return e - b;
	}
	else
	{
		// 그렇지 않다면
		//		b부터 몇 번 이동하는 지 세야한다.

		return 100;
	}
}

//---------
int main()
//---------
{
	save("소스.cpp");
	std::vector<int> v{ 1,2,3,4,5 };
	std::cout << dist(v.begin(), v.end()) << std::endl;

	/*std::list<int> lst{ 1,2,3,4,5 };
	std::cout << dist(lst.begin(), lst.end()) << std::endl;*/

	int arr[10];
	std::cout << dist(arr, arr + 1) << std::endl;

	STRING s;
	std::cout << dist(s.begin(), s.end()) << std::endl;
}

파일이름: 소스.cpp
파일크기: 1424
저장시간: 2022-05-26 11:32:56 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 26일 목요일(13주 1일)
// 
//  concepts
//		range/view
// 
// 6/15(수) - 15주 1일 기말시험
// 6/16(목) - 강의 정리
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <list>
#include "save.h"
#include "STRING.h"


template <class T>
long long dist(T b, T e)
{
	
	if (std::is_base_of_v<std::input_iterator_tag, typename std::iterator_traits<T>::iterator_category>)
	{
		// 만일 T가 랜덤반복자라면
		//		e - b가 거리이다.
		if constexpr(std::is_same_v<std::random_access_iterator_tag, typename std::iterator_traits<T>::iterator_category>)
			return e - b;
		// 랜덤반복자가 아닌 경우에도 e-b 문장이 생성되어 컴파일 오류가 발생
		// - 이전 해결 기법 - tag dispatching으로 해결
		// c++ 17부터는 constexpr if로 선택적 컴파일 가능
		else
		{
			// 그렇지 않다면
			//		b부터 몇 번 이동하는 지 세야한다.

			return 100;
		}
	}
	
}

//---------
int main()
//---------
{
	save("소스.cpp");
	std::vector<int> v{ 1,2,3,4,5 };
	std::cout << dist(v.begin(), v.end()) << std::endl;

	std::list<int> lst{ 1,2,3,4,5 };
	std::cout << dist(lst.begin(), lst.end()) << std::endl;

	int arr[10];
	std::cout << dist(arr, arr + 1) << std::endl;

	STRING s;
	std::cout << dist(s.begin(), s.end()) << std::endl;
}

파일이름: 소스.cpp
파일크기: 835
저장시간: 2022-05-26 11:59:17 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 26일 목요일(13주 1일)
// 
//  concepts
//		range/view
// 
// 6/15(수) - 15주 1일 기말시험
// 6/16(목) - 강의 정리
//-----------------------------------------------------------------------------

#include <iostream>
#include <concepts>
#include <vector>
#include <deque>
#include "save.h"
#include "STRING.h"

template<std::contiguous_iterator T>
void f(T a, T b)
{
	std::cout << "Coniguous 반복자입니다." << std::endl;
}

//---------
int main()
//---------
{
	save("소스.cpp");
	// [문제] contiguous iterator일때만 작동되는 함수 f를 만들고 싶다.

	std::vector<int> v;
	f(v.begin(), v.end());		// v는 contiguous
	std::deque<int> dq;
	//f(dq.begin(), dq.end());	// d는 랜덤이지 contiguous가 아니다.
}

파일이름: 소스.cpp
파일크기: 1068
저장시간: 2022-05-26 12:11:55 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 26일 목요일(13주 1일)
// 
//  concepts
//		range/view
// 
// 6/15(수) - 15주 1일 기말시험
// 6/16(목) - 강의 정리
//-----------------------------------------------------------------------------

#include <iostream>
#include <concepts>
#include <vector>
#include <list>
#include "save.h"
#include "STRING.h"

template<std::input_iterator Iter>
long long dist(Iter b, Iter e)
{
	if constexpr (std::is_same_v<std::random_access_iterator_tag, typename std::iterator_traits<Iter>::iterator_category>)
		return e - b;
	int step{};
	while (b != e) {
		++step; ++b;
	}
	return step;
}


//---------
int main()
//---------
{
	save("소스.cpp");
	// [문제] 표준 distance와 같은 dist를 구현하라.

	std::vector<int> v{ 1,2,3,4,5,6,7,8 };
	std::cout << dist(v.begin(), v.end()) << std::endl;		// v는 contiguous
	std::list<int> lst{ 1,2,3,4 };
	std::cout << dist(lst.begin(), lst.end()) << std::endl;	// d는 랜덤이지 contiguous가 아니다.
}

파일이름: 소스.cpp
파일크기: 585
저장시간: 2022-05-26 12:17:47 GMT+9

//-----------------------------------------------------------------------------
// 2022. 1학기 STL 5월 26일 목요일(13주 1일)
// 
//  concepts
//		range/view
// 
// 6/15(수) - 15주 1일 기말시험
// 6/16(목) - 강의 정리
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <list>
#include <ranges>
#include <algorithm>
#include "save.h"
#include "STRING.h"

//---------
int main()
//---------
{
	save("소스.cpp");
	/*std::list<int> lst{ 1,2,3 };
	std::sort()
	std::ranges::sort(lst);*/
}